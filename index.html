<!DOCTYPE html>
<!--
  City Explorer - Smart Route Planning App
  Copyright ¬© 2026 Eitan Fisher. All Rights Reserved.
  
  This application and its source code are protected by copyright.
  Unauthorized copying, distribution, or modification is prohibited.
-->
<html lang="he" dir="rtl">
<script>
// Set language direction before page renders to avoid flash
(function() {
  var lang = localStorage.getItem('city_explorer_lang') || 'he';
  var dir = lang === 'he' ? 'rtl' : 'ltr';
  document.documentElement.lang = lang;
  document.documentElement.dir = dir;
})();
</script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>City Explorer</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/x-icon" href="favicon.ico?v=3">
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32x32.png?v=3">
    <link rel="apple-touch-icon" sizes="180x180" href="icon-180x180.png?v=3">
    <meta name="theme-color" content="#be123c">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BKK Explorer">
    <style>
      /* Disable pull-to-refresh on mobile */
      html, body {
        overscroll-behavior-y: contain;
      }
      @keyframes slideUp {
        from {
          transform: translateY(100px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes slideDown {
        from {
          transform: translateY(-30px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(6px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes headerShimmer {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      .view-fade-in {
        animation: fadeIn 0.2s ease-out;
      }
      
      /* Custom Scrollbar - Thin and Subtle */
      .overflow-y-auto::-webkit-scrollbar {
        width: 6px;
      }
      
      .overflow-y-auto::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 10px;
      }
      
      .overflow-y-auto::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 10px;
      }
      
      .overflow-y-auto::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      
      /* Firefox */
      .overflow-y-auto {
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f1f5f9;
        -webkit-overflow-scrolling: touch;
        will-change: scroll-position;
        transform: translateZ(0);
      }
      
      /* GPU-accelerated scroll containers */
      .overflow-auto, .overflow-y-auto, .overflow-x-auto {
        -webkit-overflow-scrolling: touch;
      }
      
      /* Contain layout for list items to prevent cascade reflows */
      .space-y-0\.5 > *, .space-y-1 > *, .space-y-2 > *, .space-y-3 > * {
        contain: layout style;
      }
      
      /* Reduce paint during scroll - disable hover effects on touch */
      @media (hover: none) and (pointer: coarse) {
        .hover\:bg-emerald-100:hover,
        .hover\:bg-orange-50:hover,
        .hover\:bg-blue-100:hover,
        .hover\:bg-red-100:hover,
        .hover\:bg-gray-100:hover {
          background-color: inherit !important;
        }
        .hover\:underline:hover {
          text-decoration: inherit !important;
        }
      }
    </style>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Firebase SDK - sequential loading with Promise -->
    <script>
    window.__firebaseReady = new Promise(function(resolve) {
      var libs = ['firebase-app-compat.js','firebase-database-compat.js','firebase-storage-compat.js'];
      var loaded = 0;
      var failed = false;
      
      function loadNext() {
        if (failed || loaded >= libs.length) {
          resolve(!failed);
          return;
        }
        var s = document.createElement('script');
        s.src = 'https://www.gstatic.com/firebasejs/9.22.0/' + libs[loaded];
        s.onload = function() {
          loaded++;
          console.log('[FIREBASE] Loaded: ' + libs[loaded-1]);
          loadNext();
        };
        s.onerror = function() {
          console.warn('[FIREBASE] Blocked: ' + libs[loaded]);
          failed = true;
          resolve(false);
        };
        document.head.appendChild(s);
      }
      
      loadNext();
      
      // Safety timeout - don't wait forever
      setTimeout(function() {
        if (loaded < libs.length && !failed) {
          console.warn('[FIREBASE] Load timeout after 8s');
          resolve(false);
        }
      }, 15000);
    });
    </script>
    
    <!-- I18N (translations) -->
    <script>
// ============================================================================
// City Explorer - Internationalization (i18n)
// Copyright ¬© 2026 Eitan Fisher. All Rights Reserved.
// ============================================================================

window.BKK = window.BKK || {};

// ============================================================================
// TRANSLATION ENGINE
// ============================================================================

window.BKK.i18n = {
  currentLang: localStorage.getItem('city_explorer_lang') || 'he',
  
  setLang(lang) {
    this.currentLang = lang;
    localStorage.setItem('city_explorer_lang', lang);
    // Update document direction
    document.documentElement.dir = lang === 'he' ? 'rtl' : 'ltr';
    document.documentElement.lang = lang;
  },
  
  isRTL() {
    return this.currentLang === 'he';
  },
  
  // Get supported languages
  languages: {
    he: { name: '◊¢◊ë◊®◊ô◊™', nameEn: 'Hebrew', dir: 'rtl', flag: 'üáÆüá±' },
    en: { name: 'English', nameEn: 'English', dir: 'ltr', flag: 'üá¨üáß' }
  }
};

// Global translate function
// Usage: t('toast.placeAdded') or t('toast.placeAddedWithName', { name: 'Cafe' })
window.t = function(key, params) {
  const lang = window.BKK.i18n.currentLang;
  const dict = window.BKK.i18n.strings?.[lang];
  if (!dict) return key;
  
  // Navigate nested keys: 'toast.placeAdded' -> dict.toast.placeAdded
  const parts = key.split('.');
  let val = dict;
  for (const part of parts) {
    if (val && typeof val === 'object' && part in val) {
      val = val[part];
    } else {
      // Fallback to Hebrew if key missing in current lang
      val = null;
      break;
    }
  }
  
  // Fallback to Hebrew
  if (val === null || val === undefined) {
    const heDict = window.BKK.i18n.strings?.he;
    if (heDict) {
      val = heDict;
      for (const part of parts) {
        if (val && typeof val === 'object' && part in val) {
          val = val[part];
        } else {
          val = key; // Return key as last resort
          break;
        }
      }
    } else {
      val = key;
    }
  }
  
  // Replace parameters: {name} -> params.name
  if (params && typeof val === 'string') {
    for (const [k, v] of Object.entries(params)) {
      val = val.replace(new RegExp(`\\{${k}\\}`, 'g'), v);
    }
  }
  
  return val;
};

// Helper: get label for area/interest based on current language
// Uses labelEn/nameEn fields from config data
window.tLabel = function(obj) {
  if (!obj) return '';
  const lang = window.BKK.i18n.currentLang;
  if (lang === 'he') return obj.label || obj.name || '';
  // For non-Hebrew: prefer labelEn/nameEn, fallback to label/name
  return obj.labelEn || obj.nameEn || obj.label || obj.name || '';
};

// Helper: get description based on current language
window.tDesc = function(obj) {
  if (!obj) return '';
  const lang = window.BKK.i18n.currentLang;
  if (lang === 'he') return obj.desc || obj.description || '';
  return obj.descEn || obj.descriptionEn || obj.desc || obj.description || '';
};

// ============================================================================
// HEBREW STRINGS (Source of truth)
// ============================================================================

window.BKK.i18n.strings = {
he: {

// --- General / Common ---
general: {
  appName: 'City Explorer',
  city: '◊¢◊ô◊®',
  all: '◊õ◊ú',
  allCity: '◊õ◊ú ◊î◊¢◊ô◊®',
  close: '◊°◊í◊ï◊®',
  cancel: '◊ë◊ô◊ò◊ï◊ú',
  save: '◊©◊û◊ï◊®',
  update: 'üíæ ◊¢◊ì◊õ◊ü',
  add: '‚ûï ◊î◊ï◊°◊£',
  delete: '◊û◊ó◊ß',
  deleteAll: '◊û◊ó◊ß ◊î◊õ◊ú',
  edit: '◊¢◊®◊ï◊ö',
  show: '◊î◊¶◊í',
  hide: '◊î◊°◊™◊®',
  search: '◊ó◊ô◊§◊ï◊©',
  clear: '◊†◊ß◊î',
  clearSelection: '◊†◊ß◊î ◊ë◊ó◊ô◊®◊î',
  help: '◊¢◊ñ◊®◊î',
  loading: '‚è≥ ◊ò◊ï◊¢◊ü...',
  searching: '◊û◊ó◊§◊©...',
  refreshing: '◊û◊®◊¢◊†◊ü...',
  password: '◊°◊ô◊°◊û◊î',
  general: '◊õ◊ú◊ú◊ô',
  static: '◊°◊ò◊ò◊ô',
  open: '◊§◊™◊ï◊ó',
  viewOnly: '◊¶◊§◊ô◊ô◊î ◊ë◊ú◊ë◊ì',
  locked: '◊†◊¢◊ï◊ú',
  readOnly: '◊ß◊®◊ô◊ê◊î ◊ë◊ú◊ë◊ì',
  error: '◊©◊í◊ô◊ê◊î',
  unknownError: '◊©◊í◊ô◊ê◊î ◊ú◊ê ◊ô◊ì◊ï◊¢◊î',
  safeArea: '◊ë◊ò◊ï◊ó',
  cautionArea: '◊¶◊®◊ô◊ö ◊ú◊î◊ñ◊î◊®',
  dangerArea: '◊û◊°◊ï◊õ◊ü',
  enabled: '‚úÖ ◊§◊¢◊ô◊ú',
  disabled: '‚è∏Ô∏è ◊û◊ï◊©◊ë◊™',
  enable: '‚úÖ ◊î◊§◊¢◊ú',
  enableAlt: '◊î◊§◊¢◊ú',
  disable: '◊î◊©◊ë◊™',
  enableCity: '◊î◊§◊¢◊ú ◊¢◊ô◊®',
  disableCity: '◊î◊©◊ë◊™ ◊¢◊ô◊®',
  included: '‚úÖ ◊õ◊ú◊ï◊ú',
  custom: '◊û◊ï◊™◊ê◊ù',
  private: 'üë§ ◊ê◊ô◊©◊ô',
  system: 'üèóÔ∏è ◊û◊¢◊®◊õ◊™',
  generalFeedback: 'üí≠ ◊õ◊ú◊ú◊ô',
  personalNote: 'üë§ ◊ê◊ô◊©◊ô',
  idea: 'üí° ◊®◊¢◊ô◊ï◊ü',
  bug: 'üêõ ◊ë◊ê◊í',
  mine: 'üéñÔ∏è ◊©◊ú◊ô',
  inProgress: '◊ë◊¢◊ë◊ï◊ì◊î',
  underReview: 'üõ†Ô∏è ◊ë◊ë◊ì◊ô◊ß◊î',
  noDescription: '◊ê◊ô◊ü ◊™◊ô◊ê◊ï◊®',
  noLocation: '◊ê◊ô◊ü ◊û◊ô◊ß◊ï◊ù',
  noArea: '◊ú◊ú◊ê ◊ê◊ô◊ñ◊ï◊®',
  outsideBoundary: '◊û◊ó◊ï◊• ◊ú◊í◊ë◊ï◊ú◊ï◊™',
  clickForDetails: '◊ú◊ó◊• ◊ú◊§◊®◊ò◊ô◊ù ◊û◊ú◊ê◊ô◊ù',
  clickForImage: '◊ú◊ó◊• ◊ú◊¶◊§◊ô◊ô◊î ◊ë◊™◊û◊ï◊†◊î',
  fromGoogle: '◊û◊í◊ï◊í◊ú',
  fromGoogleApi: '◊û-Google API',
  addedFromSearch: '◊†◊ï◊°◊£ ◊û◊ó◊ô◊§◊ï◊©',
  addedFromGoogle: '◊†◊ï◊°◊£ ◊û-Google',
  addedManually: '◊†◊ï◊°◊§◊ï ◊ô◊ì◊†◊ô◊™',
  addedByUser: '◊û◊ß◊ï◊ù ◊©◊î◊ï◊°◊§◊™◊ô',
  fromMyPlaces: '◊û◊î◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ö',
  addedViaMore: '◊†◊ï◊°◊£ ◊ë+◊¢◊ï◊ì',
  customPlace: '◊û◊ß◊ï◊ù ◊û◊ï◊™◊ê◊ù ◊ê◊ô◊©◊ô◊™',
  meters100: '>100◊û',
  meters2000: '>2000◊û',
  caution: '◊ñ◊î◊ô◊®◊ï◊™',
  openStatus: '◊§◊™◊ï◊ó',
  closedStatus: '◊°◊í◊ï◊®',
  skipPermanently: '◊ì◊ú◊í ◊ú◊¶◊û◊ô◊™◊ï◊™',
  areas: '◊ê◊ñ◊ï◊®◊ô◊ù',
  total: '◊°◊î"◊õ',
  version: '◊í◊®◊°◊î',
  selected: '◊†◊ë◊ó◊®◊ï',
  refresh: '◊®◊¢◊†◊ü',
  share: '◊©◊™◊£',
  search: '◊ó◊§◊©',
  cancel: '◊ë◊ô◊ò◊ï◊ú',
  save: '◊ê◊ô◊©◊ï◊®',
  mine: 'üéñÔ∏è ◊©◊ú◊ô',
  clear: '◊†◊ß◊î',
  show: '◊î◊¶◊í',
  hide: '◊î◊°◊™◊®',
  system: 'üèóÔ∏è ◊û◊¢◊®◊õ◊™',
  private: 'üë§ ◊ê◊ô◊©◊ô',
  bug: 'üêõ ◊ë◊ê◊í',
  idea: 'üí° ◊®◊¢◊ô◊ï◊ü',
  generalFeedback: 'üí≠ ◊õ◊ú◊ú◊ô',
  customPlace: '◊û◊ß◊ï◊ù ◊û◊ï◊™◊ê◊ù ◊ê◊ô◊©◊ô◊™',
  general: '◊õ◊ú◊ú◊ô',
  static: '◊°◊ò◊ò◊ô',
  fromGoogleApi: '◊û-Google API',
  refreshing: '◊û◊®◊¢◊†◊ü...',
  searching: '◊û◊ó◊§◊©...',
  addedViaMore: '◊†◊ï◊°◊£ ◊ë+◊¢◊ï◊ì',
  addedManually: '◊†◊ï◊°◊§◊ï ◊ô◊ì◊†◊ô◊™',
  fromMyPlaces: '◊û◊î◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ö',
  addedFromGoogle: '◊†◊ï◊°◊£ ◊û-Google',
  addedByUser: '◊û◊ß◊ï◊ù ◊©◊î◊ï◊°◊§◊™◊ô',
  error: '◊©◊í◊ô◊ê◊î',
  all: '◊õ◊ú',
  enableCity: '◊î◊§◊¢◊ú ◊¢◊ô◊®',
  disableCity: '◊î◊©◊ë◊™ ◊¢◊ô◊®',
  noPlacesWithCoords: '◊ê◊ô◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊¢◊ù ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ ◊™◊ß◊ô◊†◊ï◊™',

  updateNow: '◊¢◊ì◊õ◊ü ◊¢◊õ◊©◊ô◊ï',
  newVersionAvailableBanner: 'üîÑ ◊í◊®◊°◊î ◊ó◊ì◊©◊î ◊ñ◊û◊ô◊†◊î!',
  howItWorks: '◊ê◊ô◊ö ◊ñ◊î ◊¢◊ï◊ë◊ì?',
  nearMe: '◊ß◊®◊ï◊ë ◊ê◊ú◊ô◊ô',
  next: '◊î◊û◊©◊ö',
  back: '◊ó◊ñ◊®◊î',
  startOver: '◊î◊™◊ó◊ú ◊û◊ó◊ì◊©',
  mayTakeSeconds: '◊ñ◊î ◊ô◊õ◊ï◊ú ◊ú◊ß◊ó◊™ ◊õ◊û◊î ◊©◊†◊ô◊ï◊™',
  myPlace: '◊û◊ß◊ï◊ù ◊©◊ú◊ô',
  more: '◊¢◊ï◊ì',
  start: '◊î◊™◊ó◊ú◊î',
  linear: '◊ú◊ô◊†◊ô◊ê◊®◊ô',
  backToForm: '◊ó◊ñ◊®◊î ◊ú◊ò◊ï◊§◊°',
  savedOn: '◊†◊©◊û◊® ◊ë-',
  customStops: '◊û◊ï◊™◊ê◊û◊ô◊ù ◊ê◊ô◊©◊ô◊™',
  consoleHint: '◊§◊®◊ò◊ô◊ù ◊û◊ú◊ê◊ô◊ù ◊ë-Console (F12) - ◊î◊¢◊™◊ß ◊ï◊©◊ú◊ó ◊ú◊™◊ô◊ß◊ï◊ü',
  clickForDetails: '◊ú◊ó◊• ◊ú◊§◊®◊ò◊ô◊ù ◊û◊ú◊ê◊ô◊ù',
  restoredToList: '◊ó◊ñ◊® ◊ú◊®◊©◊ô◊û◊î ◊î◊®◊í◊ô◊ú◊î',
  resultsFound: '◊™◊ï◊¶◊ê◊ï◊™ ◊†◊û◊¶◊ê◊ï',
  noInterestManual: '◊ú◊ú◊ê ◊™◊ó◊ï◊ù / ◊†◊ï◊°◊§◊ï ◊ô◊ì◊†◊ô◊™',
  showActivityLog: '◊î◊¶◊í ◊ú◊ï◊í ◊ú◊ê◊ô◊™◊ï◊® ◊ë◊¢◊ô◊ï◊™',
  debugMessages: '◊î◊ï◊ì◊¢◊ï◊™ Debug ◊ô◊ï◊§◊ô◊¢◊ï ◊ë◊ß◊ï◊†◊°◊ï◊ú (F12)',
  adminManagement: '◊†◊ô◊î◊ï◊ú Admin',
  currentDevice: '◊û◊õ◊©◊ô◊® ◊†◊ï◊õ◊ó◊ô',
  status: '◊°◊ò◊ò◊ï◊°',
  open: '◊§◊™◊ï◊ó',
  noRegisteredUsers: '◊ê◊ô◊ü ◊û◊©◊™◊û◊©◊ô◊ù ◊®◊©◊ï◊û◊ô◊ù',
  you: '◊ê◊™◊î',
  remove: '◊î◊°◊®',
  removed: '◊î◊ï◊°◊®',
  active: '◊§◊¢◊ô◊ú',
  inactive: '◊ú◊ê ◊§◊¢◊ô◊ú',
  viewAccessLog: '◊¶◊§◊î ◊ë◊ú◊ï◊í ◊õ◊†◊ô◊°◊ï◊™',
  new: '◊ó◊ì◊©!',
  importExport: '◊ô◊ô◊ë◊ï◊ê ◊ï◊ô◊ô◊¶◊ï◊ê',
  saveAndTransfer: '◊©◊û◊ï◊® ◊ï◊î◊¢◊ë◊® ◊†◊™◊ï◊†◊ô◊ù ◊ë◊ô◊ü ◊û◊õ◊©◊ô◊®◊ô◊ù',
  exportAll: '◊ô◊ô◊¶◊ê ◊î◊õ◊ú',
  importFromFile: '◊ô◊ô◊ë◊ê ◊û◊ß◊ï◊ë◊•',
  transferDevices: '◊î◊¢◊ë◊®◊î ◊ë◊ô◊ü Claude ◊ú-GitHub',
  dataBackup: '◊í◊ô◊ë◊ï◊ô ◊†◊™◊ï◊†◊ô◊ù',
  shareWithFriends: '◊©◊ô◊™◊ï◊£ ◊¢◊ù ◊ó◊ë◊®◊ô◊ù',
  areas: '◊ê◊ñ◊ï◊®◊ô◊ù',
  debugMode: '◊û◊¶◊ë Debug',
  searchError: '◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊©',
  noResultsFoundSearch: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™',
  added: '◊†◊ï◊°◊£!',
  canAddMore: '◊†◊ô◊™◊ü ◊ú◊î◊ï◊°◊ô◊£ ◊û◊ß◊ï◊ù ◊†◊ï◊°◊£ ◊ê◊ï ◊ú◊°◊í◊ï◊®',
  ok: '◊ê◊ô◊©◊ï◊®',
  openInGoogle: '◊§◊™◊ó ◊ë◊í◊ï◊í◊ú',
  openInGoogleNoCoords: '◊§◊™◊ó ◊ë◊í◊ï◊í◊ú (◊ê◊ô◊ü ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™)',
  viewOnly: '◊¶◊§◊ô◊ô◊î ◊ë◊ú◊ë◊ì',
  deletePlace: '◊û◊ó◊ß ◊û◊ß◊ï◊ù',
  deleteInterest: '◊û◊ó◊ß ◊™◊ó◊ï◊ù',
  deleteRoute: '◊û◊ó◊ß ◊û◊°◊ú◊ï◊ú',
  clearLog: '◊†◊ß◊î ◊ú◊ï◊í',
  shareRoute: '◊©◊™◊£ ◊û◊°◊ú◊ï◊ú',
  sharePoi: '◊©◊™◊£ ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊†◊ô◊ô◊ü',
  openRoute: '◊§◊™◊ó ◊û◊°◊ú◊ï◊ú',
  restoreActive: '◊î◊ó◊ñ◊® ◊õ◊û◊ß◊ï◊ù ◊§◊¢◊ô◊ú',
  skipPermanent: '◊ì◊ú◊í ◊ú◊¶◊û◊ô◊™◊ï◊™',
  update: '◊¢◊ì◊õ◊ü',
  close: '◊°◊í◊ï◊®',
  uses: '◊©◊ô◊û◊ï◊©◊ô◊ù',
  adminUsers: '◊û◊©◊™◊û◊©◊ô Admin',
  googleInfo: '◊û◊ô◊ì◊¢ ◊û◊í◊ï◊í◊ú',
  notes: '◊î◊¢◊®◊ï◊™...',
  inProgress: '◊ë◊¢◊ë◊ï◊ì◊î',
  locked: '◊†◊¢◊ï◊ú',
  readOnly: '◊ß◊®◊ô◊ê◊î ◊ë◊ú◊ë◊ì',
  interestName: '◊©◊ù ◊î◊™◊ó◊ï◊ù',
  addInterestTitle: '◊î◊ï◊°◊£ ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü',
  autoDetect: '◊ñ◊î◊î ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™',
  searchHintAddress: '◊î◊ß◊ú◊ì ◊õ◊™◊ï◊ë◊™ ◊û◊ú◊ê◊î, ◊©◊ù ◊û◊ú◊ï◊ü, ◊™◊ó◊†◊™ ◊®◊õ◊ë◊™, ◊ê◊ï ◊õ◊ú ◊û◊ß◊ï◊ù',
  findPlaces: '◊û◊¶◊ê ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊†◊ô◊ô◊ü',
  address: '◊õ◊™◊ï◊ë◊™',
  placesHeader: '◊û◊ß◊ï◊û◊ï◊™',
  interestsHeader: '◊™◊ó◊ï◊û◊ô◊ù',
  searchTip: '◊ú◊ó◊• üîç ◊ú◊ó◊ô◊§◊ï◊© ◊õ◊™◊ï◊ë◊™, üìç ◊ú◊û◊ô◊ß◊ï◊ù ◊†◊ï◊õ◊ó◊ô, ◊ê◊ï üìå ◊û◊û◊ß◊ï◊ù ◊ë◊®◊©◊ô◊û◊î',
  stopsCount: '◊™◊ó◊†◊ï◊™',
  searchAndAddHint: 'üí° ◊ó◊§◊© ◊ï◊ú◊ó◊• ◊ú◊î◊ï◊°◊ô◊£ ◊ú◊û◊°◊ú◊ï◊ú. ◊ê◊§◊©◊® ◊ú◊î◊ï◊°◊ô◊£ ◊û◊°◊§◊® ◊û◊ß◊ï◊û◊ï◊™.',
  placesAddedManually: '◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ï ◊ô◊ì◊†◊ô◊™',
  clickToUpload: '◊ú◊ó◊• ◊ú◊î◊¢◊ú◊ê◊î',
  image: '◊™◊û◊ï◊†◊î',
  links: '◊ß◊ô◊©◊ï◊®◊ô◊ù',
  coordinates: '◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™',
  permissions: '◊î◊®◊©◊ê◊ï◊™',
  found: '◊†◊û◊¶◊ê',
  rating: '◊ì◊ô◊®◊ï◊í',
  area: '◊ê◊ô◊ñ◊ï◊®',
  notesLabel: '◊î◊¢◊®◊ï◊™',
  searchMode: '◊°◊ï◊í ◊ó◊ô◊§◊ï◊©',
  name: '◊©◊ù',
  link: '◊ß◊ô◊©◊ï◊®',
  location: '◊û◊ô◊ß◊ï◊ù',
  icon: '◊ê◊ô◊ô◊ß◊ï◊ü',
  routeName: '◊©◊ù ◊î◊û◊°◊ú◊ï◊ú',
  mapsLink: '◊ß◊ô◊©◊ï◊® Maps',
  searchSettings: '◊î◊í◊ì◊®◊ï◊™ ◊ó◊ô◊§◊ï◊©',
  tryDifferentSearch: '◊†◊°◊î ◊ú◊ó◊§◊© ◊û◊©◊î◊ï ◊ê◊ó◊®',
  startTypingToSearch: '◊î◊™◊ó◊ú ◊ú◊î◊ß◊ú◊ô◊ì ◊õ◊ì◊ô ◊ú◊ó◊§◊©',
  multiplier: '◊û◊õ◊§◊ô◊ú',
  noEntries: '◊ê◊ô◊ü ◊õ◊†◊ô◊°◊ï◊™ ◊¢◊ì◊ô◊ô◊ü',
  noFeedback: '◊ê◊ô◊ü ◊û◊©◊ï◊ë◊ô◊ù ◊¢◊ì◊ô◊ô◊ü',
  feedback: '◊û◊©◊ï◊ë◊ô◊ù',
},

// --- Navigation & Views ---
nav: {
  form: '◊™◊õ◊†◊ü',
  route: '◊û◊°◊ú◊ï◊ú',
  search: '◊ó◊ô◊§◊ï◊©',
  saved: '◊©◊û◊ï◊®◊ô◊ù',
  myPlaces: '◊û◊ß◊ï◊û◊ï◊™',
  myInterests: '◊™◊ó◊ï◊û◊ô◊ù',
  settings: '◊î◊í◊ì◊®◊ï◊™',
  quickMode: '◊û◊¶◊ë ◊û◊î◊ô◊®',
  advancedMode: '◊û◊¶◊ë ◊û◊™◊ß◊ì◊ù',
  switchToQuick: '◊¢◊ë◊ï◊® ◊ú◊û◊¶◊ë ◊û◊î◊ô◊®',
  planTrip: '◊™◊õ◊†◊ü ◊ê◊™ ◊î◊ò◊ô◊ï◊ú',
  advancedMode: '◊û◊¶◊ë ◊û◊™◊ß◊ì◊ù',
  quickMode: '◊û◊¶◊ë ◊û◊î◊ô◊®',
},

// --- Wizard / Quick Mode ---
wizard: {
  step1Title: '◊ê◊ô◊§◊î ◊û◊ò◊ô◊ô◊ú◊ô◊ù?',
  step1Subtitle: '◊ë◊ó◊®◊ï ◊ë◊ô◊ü ◊ê◊ô◊ñ◊ï◊® / ◊ß◊®◊ï◊ë ◊ê◊ú◊ô◊ô / ◊õ◊ú ◊î◊¢◊ô◊®',
  step2Title: '◊û◊î ◊û◊¢◊†◊ô◊ô◊ü ◊ê◊ï◊™◊ö?',
  step2Subtitle: '◊ë◊ó◊® ◊™◊ó◊ï◊ù ◊ê◊ó◊ì ◊ê◊ï ◊ô◊ï◊™◊®',
  step3Title: '◊™◊ï◊¶◊ê◊ï◊™',
  myLocation: '◊î◊û◊ô◊ß◊ï◊ù ◊©◊ú◊ô',
  locationFound: 'üìç ◊û◊ô◊ß◊ï◊ù ◊†◊û◊¶◊ê!',
  findPlaces: '◊û◊¶◊ê ◊û◊ß◊ï◊û◊ï◊™',
  findPlacesCount: 'üîç ◊û◊¶◊ê ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊†◊ô◊ô◊ü ({count} ◊û◊ß◊ï◊û◊ï◊™)',
  showMap: '◊î◊¶◊í ◊û◊§◊î',
  allAreasMap: 'üó∫Ô∏è ◊û◊§◊™ ◊õ◊ú ◊î◊ê◊ñ◊ï◊®◊ô◊ù',
},

// --- Form / Search ---
form: {
  whatInterests: '‚≠ê ◊û◊î ◊û◊¢◊†◊ô◊ô◊ü?',
  searchRadius: 'üìç ◊®◊ì◊ô◊ï◊° ◊ó◊ô◊§◊ï◊©',
  radiusLabel: '◊®◊ì◊ô◊ï◊°:',
  gpsSearch: '◊ó◊ô◊§◊ï◊© ◊ú◊§◊ô GPS',
  gps: 'GPS',
  myPlace: '◊û◊ß◊ï◊ù ◊©◊ú◊ô',
  searchMyPlace: 'üîç ◊ó◊§◊© ◊û◊ß◊ï◊ù ◊©◊ú◊ô...',
  allMode: '◊î◊õ◊ú',
  areaMode: '◊ê◊ô◊ñ◊ï◊®',
  radiusMode: '◊®◊ì◊ô◊ï◊°',
  currentLocation: '◊û◊ô◊ß◊ï◊ù ◊†◊ï◊õ◊ó◊ô',
  findCurrentLocation: '◊û◊¶◊ê ◊û◊ô◊ß◊ï◊ù ◊†◊ï◊õ◊ó◊ô',
  locateMe: 'üìç ◊ñ◊î◊î ◊û◊ô◊ß◊ï◊ù',
  locationDetected: 'üìç ◊û◊ô◊ß◊ï◊ù ◊†◊ß◊ú◊ò',
  locationDetectedFull: 'üìç ◊û◊ô◊ß◊ï◊ù ◊†◊ï◊õ◊ó◊ô ◊†◊ß◊ú◊ò!',
  locationDetectedShort: 'üìç ◊û◊ô◊ß◊ï◊ù ◊†◊ß◊ú◊ò!',
  locationDetectedNoAddr: 'üìç ◊û◊ô◊ß◊ï◊ù ◊†◊ß◊ú◊ò (◊ú◊ê ◊†◊û◊¶◊ê◊î ◊õ◊™◊ï◊ë◊™)',
  locating: '‚è≥ ◊û◊ê◊™◊®...',
  searchingLocation: '◊û◊ó◊§◊© ◊û◊ô◊ß◊ï◊ù...',
  searchAddress: '◊ó◊§◊© ◊õ◊™◊ï◊ë◊™',
  searchByAddress: '◊ó◊§◊© ◊ú◊§◊ô ◊õ◊™◊ï◊ë◊™',
  searchByName: '◊ó◊§◊© ◊ú◊§◊ô ◊©◊ù ◊î◊û◊ß◊ï◊ù',
  searchingByName: '◊û◊ó◊§◊© ◊ú◊§◊ô ◊©◊ù...',
  searchPlaceGoogle: '◊ó◊§◊© ◊û◊ß◊ï◊ù ◊ë◊í◊ï◊í◊ú',
  enterAddress: '◊ê◊†◊ê ◊î◊ñ◊ü ◊õ◊™◊ï◊ë◊™',
  enterPlaceName: '◊ê◊†◊ê ◊î◊ñ◊ü ◊©◊ù ◊û◊ß◊ï◊ù',
  enterAddressOrName: '◊î◊ñ◊ü ◊õ◊™◊ï◊ë◊™ ◊ê◊ï ◊©◊ù ◊û◊ß◊ï◊ù',
  typeAddress: '◊î◊ß◊ú◊ì ◊õ◊™◊ï◊ë◊™, ◊©◊ù ◊û◊ú◊ï◊ü, ◊û◊ß◊ï◊ù...',
  typeAddressAlt: '◊î◊ß◊ú◊ì ◊õ◊™◊ï◊ë◊™, ◊©◊ù ◊û◊ß◊ï◊ù, ◊û◊ú◊ï◊ü...',
  extractFromLink: '◊ó◊ú◊• ◊û◊ß◊ô◊©◊ï◊®',
  selectStartPoint: '◊ë◊ó◊® ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î',
  startPointFirst: '◊î◊™◊ó◊ú◊î ◊û◊î◊û◊ß◊ï◊ù ◊î◊®◊ê◊©◊ï◊ü ◊ë◊®◊©◊ô◊û◊î',
  setStartPoint: '◊ß◊ë◊¢ ◊õ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î',
  chooseStartBeforeCalc: '◊ë◊ó◊® ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î ◊ú◊§◊†◊ô ◊ó◊ô◊©◊ï◊ë ◊û◊°◊ú◊ï◊ú',
  findLocationFirst: '◊ê◊†◊ê ◊û◊¶◊ê ◊ê◊™ ◊î◊û◊ô◊ß◊ï◊ù ◊î◊†◊ï◊õ◊ó◊ô ◊©◊ú◊ö ◊™◊ó◊ô◊ú◊î',
  needGpsFirst: '◊¶◊®◊ô◊ö ◊ú◊î◊í◊ì◊ô◊® ◊û◊ô◊ß◊ï◊ù GPS ◊ß◊ï◊ì◊ù',
  selectAreaAndInterest: '◊ê◊†◊ê ◊ë◊ó◊® ◊ê◊ô◊ñ◊ï◊® ◊ï◊ú◊§◊ó◊ï◊™ ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü ◊ê◊ó◊ì',
  selectAtLeastOneInterest: '◊ê◊†◊ê ◊ë◊ó◊® ◊ú◊§◊ó◊ï◊™ ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü ◊ê◊ó◊ì',
  showSearchRadius: '◊î◊¶◊í ◊®◊ì◊ô◊ï◊° ◊ó◊ô◊§◊ï◊©',
  gpsRadiusHint: '◊ó◊ô◊§◊ï◊© ◊ú◊§◊ô GPS (1 ◊ß"◊û)',
  useGpsForRadius: 'üìç ◊ú◊ó◊• GPS ◊ê◊ï ◊î◊í◊ì◊® ◊û◊ô◊ß◊ï◊ù ◊õ◊ì◊ô ◊ú◊î◊©◊™◊û◊© ◊ë◊û◊¶◊ë ◊®◊ì◊ô◊ï◊°',
},

// --- Route ---
route: {
  calcRoute: 'üß≠ ◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú',
  recalcRoute: 'üîÑ ◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú ◊û◊ó◊ì◊©',
  saveRoute: '◊©◊û◊ï◊® ◊û◊°◊ú◊ï◊ú',
  editSavedRoute: 'üó∫Ô∏è ◊¢◊®◊ï◊ö ◊û◊°◊ú◊ï◊ú ◊©◊û◊ï◊®',
  addSavedRoute: 'üó∫Ô∏è ◊î◊ï◊°◊£ ◊û◊°◊ú◊ï◊ú ◊©◊û◊ï◊®',
  linear: '◊ú◊ô◊†◊ô◊ê◊®◊ô',
  linearRoute: '‚û°Ô∏è ◊ú◊ô◊†◊ô◊ê◊®◊ô',
  linearDesc: '‚û°Ô∏è ◊û◊°◊ú◊ï◊ú ◊ú◊ô◊†◊ô◊ê◊®◊ô',
  circular: '◊û◊¢◊í◊ú◊ô',
  circularRoute: 'üîÑ ◊û◊°◊ú◊ï◊ú ◊û◊¢◊í◊ú◊ô',
  circularDesc: 'üîÑ ◊û◊°◊ú◊ï◊ú ◊û◊¢◊í◊ú◊ô ‚Äî ◊ó◊ï◊ñ◊® ◊ú◊†◊ß◊ï◊ì◊™ ◊î◊î◊™◊ó◊ú◊î',
  routeDeleted: '◊î◊û◊°◊ú◊ï◊ú ◊†◊û◊ó◊ß',
  routeUpdated: '◊î◊û◊°◊ú◊ï◊ú ◊¢◊ï◊ì◊õ◊ü',
  routeSaved: '◊î◊û◊°◊ú◊ï◊ú ◊†◊©◊û◊®!',
  routeCopied: '◊û◊°◊ú◊ï◊ú ◊î◊ï◊¢◊™◊ß ◊ú◊ú◊ï◊ó',
  calcRoutePrevious: '◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú ◊ß◊ï◊ì◊ù',
  returnToRoute: '◊î◊ó◊ñ◊® ◊ú◊û◊°◊ú◊ï◊ú',
  removeFromRoute: '◊î◊°◊® ◊û◊î◊û◊°◊ú◊ï◊ú',
  skipPlace: '◊ì◊ú◊í ◊¢◊ú ◊û◊ß◊ï◊ù',
  skipTemporarily: '◊ì◊ú◊í ◊ñ◊û◊†◊ô◊™',
  skipPermanently: '◊ì◊ú◊í ◊™◊û◊ô◊ì',
  cancelPermanentSkip: '◊ë◊ò◊ú ◊ì◊ô◊ú◊ï◊í ◊ß◊ë◊ï◊¢',
  returnPlace: '◊î◊ó◊ñ◊® ◊û◊ß◊ï◊ù',
  addToMyList: '◊î◊ï◊°◊£ ◊ú◊®◊©◊ô◊û◊î ◊©◊ú◊ô',
  openedSuccess: '◊†◊§◊™◊ó ◊ë◊î◊¶◊ú◊ó◊î!',
  linkCopied: '◊î◊ß◊ô◊©◊ï◊® ◊î◊ï◊¢◊™◊ß! üìã',
  pointsCopied: '◊†◊ß◊ï◊ì◊ï◊™ ◊î◊¢◊†◊ô◊ô◊ü ◊î◊ï◊¢◊™◊ß◊ï ◊ú◊ú◊ï◊ó',
  addManualStop: '‚ûï ◊î◊ï◊°◊£ ◊ô◊ì◊†◊ô◊™ ◊†◊ß◊ï◊ì◊î ◊ú◊û◊°◊ú◊ï◊ú',
  moreFromCategory: '+ ◊¢◊ï◊ì',
  reorderStops: '◊°◊ì◊® ◊¢◊¶◊ô◊®◊ï◊™',
  dragToReorder: '◊í◊®◊ï◊® ◊ú◊©◊ô◊†◊ï◊ô ◊°◊ì◊®',
  openRouteInGoogle: '◊§◊™◊ó ◊û◊°◊ú◊ï◊ú ◊ë◊í◊ï◊í◊ú',
  openRoutePartN: '◊û◊°◊ú◊ï◊ú ◊ó◊ú◊ß {n} ◊û◊™◊ï◊ö {total}',
  splitRouteWarning: '‚ö†Ô∏è ◊í◊ï◊í◊ú ◊û◊§◊ï◊™ ◊™◊ï◊û◊ö ◊ë-{max} ◊†◊ß◊ï◊ì◊ï◊™. ◊î◊û◊°◊ú◊ï◊ú ◊§◊ï◊¶◊ú ◊ú-{parts} ◊ó◊ú◊ß◊ô◊ù. ◊ê◊§◊©◊® ◊ú◊î◊©◊ë◊ô◊™ ◊¢◊¶◊ô◊®◊ï◊™ ◊õ◊ì◊ô ◊ú◊¶◊û◊¶◊ù.',
  mapPointsWarning: '‚ÑπÔ∏è ◊ô◊™◊õ◊ü ◊©◊í◊ï◊í◊ú ◊û◊§◊ï◊™ ◊ú◊ê ◊ô◊¶◊ô◊í ◊ê◊™ ◊õ◊ú {count} ◊î◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊ú ◊î◊û◊§◊î.',
  showStopsOnMap: '◊î◊¶◊í ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊ú ◊î◊û◊§◊î',
  backToList: '◊ó◊ñ◊ï◊® ◊ú◊®◊©◊ô◊û◊î',
  stopNumber: '◊¢◊¶◊ô◊®◊î',
  moveUp: '◊î◊¢◊ë◊® ◊ú◊û◊¢◊ú◊î',
  moveDown: '◊î◊¢◊ë◊® ◊ú◊û◊ò◊î',
  routeCalculated: '◊û◊°◊ú◊ï◊ú ◊ó◊ï◊©◊ë!',
  stops: '◊¢◊¶◊ô◊®◊ï◊™',
  places: '◊û◊ß◊ï◊û◊ï◊™',
  savedAs: '◊†◊©◊û◊®:',
  startPoint: '◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î',
  routeType: '◊°◊ï◊í ◊û◊°◊ú◊ï◊ú',
  newRoute: '◊¶◊ï◊® ◊û◊°◊ú◊ï◊ú ◊ó◊ì◊©',
},

// --- Places ---
places: {
  addPlace: '◊î◊ï◊°◊£ ◊û◊ß◊ï◊ù',
  editPlace: '◊¢◊®◊ï◊ö ◊û◊ß◊ï◊ù',
  placeName: '◊©◊ù ◊î◊û◊ß◊ï◊ù',
  enterPlaceName: '◊ê◊†◊ê ◊î◊ñ◊ü ◊©◊ù ◊ú◊û◊ß◊ï◊ù',
  nameExists: '◊©◊ù ◊ñ◊î ◊õ◊ë◊® ◊ß◊ô◊ô◊ù',
  placeExists: '◊û◊ß◊ï◊ù ◊¢◊ù ◊©◊ù ◊ñ◊î ◊õ◊ë◊® ◊ß◊ô◊ô◊ù',
  address: '◊õ◊™◊ï◊ë◊™',
  notes: '◊î◊¢◊®◊ï◊™...',
  description: '◊™◊ô◊ê◊ï◊® ◊ß◊¶◊® ◊©◊ú ◊î◊û◊ß◊ï◊ù',
  findLocation: 'üìç ◊û◊¶◊ê ◊û◊ô◊ß◊ï◊ù',
  updateLocation: '‚úÖ ◊¢◊ì◊õ◊ü ◊û◊ô◊ß◊ï◊ù',
  googleInfo: 'üîé ◊û◊ô◊ì◊¢ ◊û◊í◊ï◊í◊ú',
  searchingAddress: '◊û◊ó◊§◊© ◊õ◊™◊ï◊ë◊™...',
  searchByNameHint: '◊ó◊§◊© ◊ë◊©◊ù, ◊™◊ô◊ê◊ï◊® ◊ê◊ï ◊î◊¢◊®◊ï◊™...',
  placeAdded: '◊î◊û◊ß◊ï◊ù ◊†◊ï◊°◊£!',
  placeUpdated: '◊î◊û◊ß◊ï◊ù ◊¢◊ï◊ì◊õ◊ü!',
  placeDeleted: '◊î◊û◊ß◊ï◊ù ◊†◊û◊ó◊ß!',
  placeAddedShared: '◊î◊û◊ß◊ï◊ù ◊†◊ï◊°◊£ ◊ï◊†◊©◊û◊® ◊ú◊õ◊ï◊ú◊ù!',
  detailsEdit: '◊§◊®◊ò◊ô◊ù / ◊¢◊®◊ï◊ö',
  editAddedToList: '◊¢◊®◊ï◊ö (◊†◊ï◊°◊£ ◊ú◊®◊©◊ô◊û◊î)',
  missingDetails: '◊ó◊°◊®◊ô◊ù ◊§◊®◊ò◊ô◊ù',
  missingDetailsLong: '◊ó◊°◊®◊ô◊ù ◊§◊®◊ò◊ô◊ù (◊õ◊™◊ï◊ë◊™/◊ß◊ï◊®◊ì◊ô◊†◊ò◊ï◊™/◊™◊ó◊ï◊ù)',
  noCoordinates: '◊ê◊ô◊ü ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ - ◊ú◊ê ◊ô◊õ◊ú◊ú ◊ë◊û◊°◊ú◊ï◊ú',
  noCoordinatesWarning: '‚ö†Ô∏è ◊ó◊°◊®◊ï◊™ ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™',
  noCoordinatesWarnLong: '‚ö†Ô∏è ◊ó◊°◊®◊ï◊™ ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ - ◊ú◊ê ◊ô◊õ◊ú◊ú ◊ë◊û◊°◊ú◊ï◊ú',
  noLocationPermission: '◊ê◊ô◊ü ◊î◊®◊©◊ê◊™ ◊û◊ô◊ß◊ï◊ù',
  outsideArea: '◊û◊ß◊ï◊ù ◊û◊ó◊ï◊• ◊ú◊í◊ë◊ï◊ú◊ï◊™ ◊î◊ê◊ñ◊ï◊®',
  placeNotOnGoogle: '◊î◊û◊ß◊ï◊ù ◊ú◊ê ◊†◊û◊¶◊ê ◊ë-Google',
  notEnoughInfo: '◊ê◊ô◊ü ◊û◊°◊§◊ô◊ß ◊û◊ô◊ì◊¢ ◊¢◊ú ◊î◊û◊ß◊ï◊ù',
  noPlacesFound: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™',
  noMorePlaces: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊¢◊ï◊ì ◊û◊ß◊ï◊û◊ï◊™',
  noMatchingPlaces: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊û◊ß◊ï◊û◊ï◊™. ◊†◊°◊î ◊™◊ó◊ï◊û◊ô ◊¢◊†◊ô◊ô◊ü ◊ê◊ï ◊ê◊ñ◊ï◊® ◊ê◊ó◊®.',
  notEnoughInArea: '◊ê◊ô◊ü ◊û◊°◊§◊ô◊ß ◊û◊ß◊ï◊û◊ï◊™ ◊™◊ï◊ê◊û◊ô◊ù ◊ë◊™◊ó◊ï◊ù ◊ñ◊î ◊ë◊ê◊ñ◊ï◊® ◊î◊†◊ë◊ó◊®',
  notEnoughPartial: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊û◊°◊§◊ô◊ß ◊û◊ß◊ï◊û◊ï◊™ ◊™◊ï◊ê◊û◊ô◊ù ◊ë◊ó◊ú◊ß ◊û◊™◊ó◊ï◊û◊ô ◊î◊¢◊†◊ô◊ô◊ü ◊ë◊ê◊ñ◊ï◊® ◊î◊†◊ë◊ó◊®',
  alreadyInRoute: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊û◊°◊ú◊ï◊ú',
  alreadyInList: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊®◊©◊ô◊û◊î',
  alreadyInMyList: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊®◊©◊ô◊û◊î ◊©◊ú◊ö',
  alreadyBlacklisted: '◊õ◊ë◊® ◊ë◊®◊©◊ô◊û◊™ ◊ì◊ô◊ú◊ï◊í',
  addedToSkipList: '◊†◊ï◊°◊£ ◊ú◊ì◊ô◊ú◊ï◊í ◊ß◊ë◊ï◊¢',
  addedToYourList: '◊†◊ï◊°◊£ ◊ú◊®◊©◊ô◊û◊î ◊©◊ú◊ö!',
  returnedToList: '◊ó◊ñ◊® ◊ú◊®◊©◊ô◊û◊î ◊î◊®◊í◊ô◊ú◊î',
  markHandled: '◊°◊û◊ü ◊õ◊ò◊ï◊§◊ú',
  markUnhandled: '◊°◊û◊ü ◊õ◊ú◊ê ◊ò◊ï◊§◊ú',
  selectImageFile: '◊ê◊†◊ê ◊ë◊ó◊® ◊ß◊ï◊ë◊• ◊™◊û◊ï◊†◊î',
  noPlacesWithCoords: '◊ê◊ô◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊¢◊ù ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ ◊™◊ß◊ô◊†◊ï◊™',
  noPlacesInCity: '◊ê◊ô◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊ë{cityName}',
  youHavePlaces: '◊ô◊© ◊ú◊ö {count} ◊û◊ß◊ï◊û◊ï◊™ ◊ë{cityName}',
  noSavedRoutesInCity: '◊ê◊ô◊ü ◊û◊°◊ú◊ï◊ú◊ô◊ù ◊©◊û◊ï◊®◊ô◊ù ◊ë{cityName}',
  googlePlaces: '◊û◊û◊ß◊ï◊û◊ï◊™ Google Places',
  moreInCategory: '‚ûï ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊ë',
  editNoCoordsHint: '◊ú◊û◊ß◊ï◊ù ◊ñ◊î ◊ê◊ô◊ü ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™. ◊ú◊ó◊• ◊¢◊ú ‚úèÔ∏è ◊õ◊ì◊ô ◊ú◊¢◊®◊ï◊ö.',
  editNoCoordsHint2: '◊ú◊û◊ß◊ï◊ù ◊ñ◊î ◊ê◊ô◊ü ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™. ◊¢◊®◊ï◊ö ◊ê◊™ ◊î◊û◊ß◊ï◊ù ◊õ◊ì◊ô ◊ú◊î◊ï◊°◊ô◊£.',
  noResultsFor: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ë◊ï◊®',
  searchError: '◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊©',
  addressNotFound: '◊ú◊ê ◊†◊û◊¶◊ê◊î ◊õ◊™◊ï◊ë◊™ ◊™◊ï◊ê◊û◊™',
  addressNotFoundRetry: '◊ú◊ê ◊†◊û◊¶◊ê◊î ◊õ◊™◊ï◊ë◊™. ◊†◊°◊î ◊õ◊™◊ï◊ë◊™ ◊ê◊ó◊®◊™',
  placeNotFoundRetry: '◊ú◊ê ◊†◊û◊¶◊ê ◊û◊ß◊ï◊ù. ◊†◊°◊î ◊©◊ù ◊ê◊ó◊® ◊ê◊ï ◊õ◊™◊ï◊ë◊™',
  locationNotInAnyArea: '◊î◊û◊ô◊ß◊ï◊ù ◊ú◊ê ◊†◊û◊¶◊ê ◊ë◊™◊ï◊ö ◊ê◊£ ◊ê◊ñ◊ï◊® ◊û◊ï◊í◊ì◊®',
  locationOutsideSelection: '◊î◊û◊ô◊ß◊ï◊ù ◊î◊†◊ï◊õ◊ó◊ô ◊©◊ú◊ö ◊†◊û◊¶◊ê ◊û◊ó◊ï◊• ◊ú◊ê◊ñ◊ï◊®◊ô ◊î◊ë◊ó◊ô◊®◊î',
  noPlacesInRadius: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊û◊ß◊ï◊û◊ï◊™ ◊ë◊ê◊ñ◊ï◊®◊ô◊ù ◊î◊û◊ï◊õ◊®◊ô◊ù ◊ë◊®◊ì◊ô◊ï◊° ◊©◊†◊ë◊ó◊®. ◊†◊°◊î ◊ú◊î◊í◊ì◊ô◊ú ◊®◊ì◊ô◊ï◊°.',
  needCoordsForAreas: '◊¶◊®◊ô◊ö ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ ◊õ◊ì◊ô ◊ú◊ñ◊î◊ï◊™ ◊ê◊ñ◊ï◊®◊ô◊ù',
  badCoords: '◊ú◊ê ◊ñ◊ô◊î◊ô◊™◊ô ◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™. ◊†◊°◊î ◊ß◊ô◊©◊ï◊® Google Maps ◊ê◊ï: 13.7465,100.4927',
  shortLinksHint: '◊ß◊ô◊©◊ï◊®◊ô◊ù ◊û◊ß◊ï◊¶◊®◊ô◊ù: ◊§◊™◊ó ◊ë◊ì◊§◊ì◊§◊ü ◊ï◊î◊¢◊™◊ß ◊ê◊™ ◊î◊ß◊ô◊©◊ï◊® ◊î◊û◊ú◊ê',
  searchResults: '◊ó◊ô◊§◊ï◊©',
  byInterest: '◊ú◊§◊ô ◊™◊ó◊ï◊ù',
  byArea: '◊ú◊§◊ô ◊ê◊ô◊ñ◊ï◊®',
  byName: '◊ú◊§◊ô ◊©◊ù',
  includedPlaces: '◊û◊ß◊ï◊û◊ï◊™ ◊õ◊ú◊ï◊ú◊ô◊ù',
  skippedPlaces: '◊û◊ß◊ï◊û◊ï◊™ ◊û◊ì◊ï◊ú◊í◊ô◊ù',
  alreadyInRoute: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊û◊°◊ú◊ï◊ú',
  alreadyInMyList: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊®◊©◊ô◊û◊î ◊©◊ú◊ö',
  addedToYourList: '◊†◊ï◊°◊£ ◊ú◊®◊©◊ô◊û◊î ◊©◊ú◊ö!',
  alreadyBlacklisted: '◊õ◊ë◊® ◊ë◊®◊©◊ô◊û◊™ ◊ì◊ô◊ú◊ï◊í',
  addedToSkipList: '◊†◊ï◊°◊£ ◊ú◊ì◊ô◊ú◊ï◊í ◊ß◊ë◊ï◊¢',
  alreadyInList: '◊õ◊ë◊® ◊ß◊ô◊ô◊ù ◊ë◊®◊©◊ô◊û◊î',
  editAddedToList: '◊¢◊®◊ï◊ö (◊†◊ï◊°◊£ ◊ú◊®◊©◊ô◊û◊î)',
  noSavedRoutesInCity: '◊ê◊ô◊ü ◊û◊°◊ú◊ï◊ú◊ô◊ù ◊©◊û◊ï◊®◊ô◊ù ◊ë',
  noPlacesInCity: '◊ê◊ô◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊ë',
  noResultsFor: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ë◊ï◊®',
  thisCity: '◊¢◊ô◊® ◊ñ◊ï',
  fromGoogleCache: '◊û◊í◊ï◊í◊ú (cache)',
},

// --- Interests ---
interests: {
  addInterest: '◊î◊ï◊°◊£ ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü',
  interestName: '◊©◊ù ◊î◊™◊ó◊ï◊ù',
  interestAdded: '◊î◊™◊ó◊ï◊ù ◊†◊ï◊°◊£!',
  interestUpdated: '◊î◊™◊ó◊ï◊ù ◊¢◊ï◊ì◊õ◊ü!',
  interestDeleted: '◊™◊ó◊ï◊ù ◊†◊û◊ó◊ß!',
  interestInvalid: '◊™◊ó◊ï◊ù ◊ú◊ê ◊ï◊ï◊ú◊ô◊ì◊ô',
  missingSearchConfig: '◊ó◊°◊® ◊î◊í◊ì◊®◊ï◊™ ◊ó◊ô◊§◊ï◊©',
  builtInRemoved: '◊™◊ó◊ï◊ù ◊û◊¢◊®◊õ◊™ ◊î◊ï◊°◊®',
  resetToDefault: '◊ê◊§◊° ◊ú◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú',
  interestsReset: '◊î◊™◊ó◊ï◊û◊ô◊ù ◊ê◊ï◊§◊°◊ï ◊ú◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú',
  exampleTypes: '◊ú◊ì◊ï◊í◊û◊î: ◊ë◊™◊ô ◊ß◊ï◊ú◊†◊ï◊¢',
  privateOnly: '◊™◊ó◊ï◊ù ◊§◊®◊ò◊ô',
  activeCount: '◊§◊¢◊ô◊ú◊ô◊ù',
  customCount: '◊™◊ó◊ï◊û◊ô◊ù ◊û◊ï◊™◊ê◊û◊ô◊ù',
  activeInterests: '◊™◊ó◊ï◊û◊ô◊ù ◊§◊¢◊ô◊ú◊ô◊ù',
  disabledInterests: '◊™◊ó◊ï◊û◊ô◊ù ◊û◊ï◊©◊ë◊™◊ô◊ù',
  privateInterest: '◊™◊ó◊ï◊ù ◊§◊®◊ò◊ô',
  myPlacesOnly: '◊®◊ß ◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ô, ◊ë◊ú◊ô ◊§◊†◊ô◊ô◊î ◊ú◊í◊ï◊í◊ú',
  interestStatus: '◊°◊ò◊ò◊ï◊° ◊™◊ó◊ï◊û◊ô◊ù',
  categorySearch: '◊ó◊ô◊§◊ï◊© ◊ß◊ò◊í◊ï◊®◊ô◊î (types)',
  textSearch: '◊ó◊ô◊§◊ï◊© ◊ò◊ß◊°◊ò (query)',
  textQuery: '◊ò◊ß◊°◊ò ◊ó◊ô◊§◊ï◊©',
  placeTypes: '◊°◊ï◊í◊ô ◊û◊ß◊ï◊û◊ï◊™ (◊û◊ï◊§◊®◊ì◊ô◊ù ◊ë◊§◊°◊ô◊ß)',
  seeTypesList: '◊®◊ê◊î ◊®◊©◊ô◊û◊™ ◊°◊ï◊í◊ô◊ù',
  blacklistWords: '◊û◊ô◊ú◊ï◊™ ◊°◊ô◊†◊ï◊ü (◊û◊ï◊§◊®◊ì◊ï◊™ ◊ë◊§◊°◊ô◊ß)',
},

// --- Toasts & Messages ---
toast: {
  saveError: '◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊î',
  deleteError: '◊©◊í◊ô◊ê◊î ◊ë◊û◊ó◊ô◊ß◊î',
  updateError: '◊©◊í◊ô◊ê◊î ◊ë◊¢◊ì◊õ◊ï◊ü',
  searchError: '◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊©',
  exportError: '◊©◊í◊ô◊ê◊î ◊ë◊ô◊ô◊¶◊ï◊ê',
  importError: '◊©◊í◊ô◊ê◊î ◊ë◊ô◊ô◊ë◊ï◊ê',
  sendError: '◊©◊í◊ô◊ê◊î ◊ë◊©◊ú◊ô◊ó◊î',
  locationError: '◊©◊í◊ô◊ê◊î ◊ë◊ê◊ô◊™◊ï◊® ◊û◊ô◊ß◊ï◊ù',
  addressSearchError: '◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊© ◊õ◊™◊ï◊ë◊™',
  routeSaveError: '◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊™ ◊û◊°◊ú◊ï◊ú',
  imageUploadError: '◊©◊í◊ô◊ê◊î ◊ë◊î◊¢◊ú◊ê◊™ ◊î◊™◊û◊ï◊†◊î',
  addPlacesError: '◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊°◊§◊™ ◊û◊ß◊ï◊û◊ï◊™',
  googleInfoError: '◊©◊í◊ô◊ê◊î ◊ë◊©◊ú◊ô◊§◊™ ◊û◊ô◊ì◊¢ ◊û-Google',
  resetError: '◊©◊í◊ô◊ê◊î ◊ë◊ê◊ô◊§◊ï◊°',
  logClearError: '◊©◊í◊ô◊ê◊î ◊ë◊†◊ô◊ß◊ï◊ô ◊î◊ú◊ï◊í',
  fileReadError: '◊©◊í◊ô◊ê◊î ◊ë◊ß◊®◊ô◊ê◊™ ◊î◊ß◊ï◊ë◊•',
  refreshError: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊®◊¢◊†◊ï◊ü ◊î◊†◊™◊ï◊†◊ô◊ù',
  addressSearchErrorHint: '◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊© ◊î◊õ◊™◊ï◊ë◊™. ◊†◊°◊î ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊ß◊ô◊©◊ï◊® Google Maps',
  storageFull: '◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊î - ◊ê◊ó◊°◊ï◊ü ◊û◊ú◊ê. ◊†◊°◊î ◊ú◊û◊ó◊ï◊ß ◊û◊°◊ú◊ï◊ú◊ô◊ù ◊ô◊©◊†◊ô◊ù',
  locationNotAvailable: '◊î◊û◊ô◊ß◊ï◊ù ◊ú◊ê ◊ñ◊û◊ô◊ü ◊õ◊®◊í◊¢. ◊†◊°◊î ◊©◊ï◊ë.',
  locationTimeout: '◊™◊ù ◊î◊ñ◊û◊ü ◊ú◊ß◊ë◊ú◊™ ◊î◊û◊ô◊ß◊ï◊ù. ◊†◊°◊î ◊©◊ï◊ë.',
  locationFailed: '◊ú◊ê ◊î◊¶◊ú◊ó◊™◊ô ◊ú◊ß◊ë◊ú ◊ê◊™ ◊î◊û◊ô◊ß◊ï◊ù.',
  locationNoPermission: '◊ê◊ô◊ü ◊î◊®◊©◊ê◊™ ◊û◊ô◊ß◊ï◊ù - ◊ê◊†◊ê ◊ê◊©◊® ◊í◊ô◊©◊î ◊ú◊û◊ô◊ß◊ï◊ù',
  locationNoPermissionBrowser: '◊†◊ì◊®◊©◊™ ◊î◊®◊©◊ê◊î ◊ú◊û◊ô◊ß◊ï◊ù. ◊ê◊†◊ê ◊ê◊§◊©◊® ◊í◊ô◊©◊î ◊ë◊û◊ô◊ß◊ï◊ù ◊ë◊î◊í◊ì◊®◊ï◊™ ◊î◊ì◊§◊ì◊§◊ü.',
  locationUnavailable: '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ê◊™◊® ◊û◊ô◊ß◊ï◊ù',
  locationInaccessible: '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊í◊©◊™ ◊ú◊û◊ô◊ß◊ï◊ù',
  browserNoLocation: '◊î◊ì◊§◊ì◊§◊ü ◊ú◊ê ◊™◊ï◊û◊ö ◊ë◊û◊ô◊ß◊ï◊ù',
  browserNoGps: '◊î◊ì◊§◊ì◊§◊ü ◊©◊ú◊ö ◊ú◊ê ◊™◊ï◊û◊ö ◊ë◊û◊ô◊ß◊ï◊ù GPS',
  noImportItems: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊§◊®◊ô◊ò◊ô◊ù ◊ú◊ô◊ô◊ë◊ï◊ê',
  invalidFile: '◊ß◊ï◊ë◊• ◊ú◊ê ◊™◊ß◊ô◊ü - ◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊†◊™◊ï◊†◊ô◊ù',
  feedbackDeleted: '◊û◊©◊ï◊ë ◊†◊û◊ó◊ß',
  feedbackThanks: '◊™◊ï◊ì◊î ◊¢◊ú ◊î◊û◊©◊ï◊ë! üôè',
  userRemoved: '◊û◊©◊™◊û◊© ◊î◊ï◊°◊®',
  passwordSaved: '◊°◊ô◊°◊û◊î ◊†◊©◊û◊®◊î!',
  passwordRemoved: '◊°◊ô◊°◊û◊î ◊î◊ï◊°◊®◊î - ◊í◊ô◊©◊î ◊§◊™◊ï◊ó◊î',
  logCleared: '◊î◊ú◊ï◊í ◊†◊ï◊ß◊î',
  allFeedbackDeleted: '◊õ◊ú ◊î◊û◊©◊ï◊ë◊ô◊ù ◊†◊û◊ó◊ß◊ï',
  appUpToDate: '◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊û◊¢◊ï◊ì◊õ◊†◊™ ‚úÖ',
  cannotCheckUpdates: '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ë◊ì◊ï◊ß ◊¢◊ì◊õ◊ï◊†◊ô◊ù',
  dataRefreshed: 'üîÑ ◊õ◊ú ◊î◊†◊™◊ï◊†◊ô◊ù ◊®◊ï◊¢◊†◊†◊ï ◊ë◊î◊¶◊ú◊ó◊î!',
  dataRefreshedLocal: 'üîÑ ◊†◊™◊ï◊†◊ô◊ù ◊®◊ï◊¢◊†◊†◊ï (localStorage ◊ë◊ú◊ë◊ì - Firebase ◊ú◊ê ◊ñ◊û◊ô◊ü)',
  debugOn: '‚úÖ Debug ◊û◊ï◊§◊¢◊ú',
  debugOff: '‚ùå Debug ◊õ◊ë◊ï◊ô',
  addedNoteSuccess: '‚úÖ ◊†◊ï◊°◊£! ◊†◊ô◊™◊ü ◊ú◊î◊ï◊°◊ô◊£ ◊û◊ß◊ï◊ù ◊†◊ï◊°◊£ ◊ê◊ï ◊ú◊°◊í◊ï◊®',
  firebaseUnavailable: 'Firebase ◊ú◊ê ◊ñ◊û◊ô◊ü',
  urlTooLong: '‚ö†Ô∏è ◊õ◊™◊ï◊ë◊™ ◊ê◊®◊ï◊õ◊î. ◊ô◊ô◊™◊õ◊ü ◊©◊ó◊ú◊ß ◊û◊î◊†◊ß◊ï◊ì◊ï◊™ ◊ú◊ê ◊ô◊ï◊¶◊í◊ï',
  addressVerified: '‚úÖ ◊õ◊™◊ï◊ë◊™ ◊ê◊ï◊û◊™◊î:',
  foundInArea: 'üìç ◊†◊û◊¶◊ê◊™ ◊ë◊ê◊ñ◊ï◊®:',
  detectedAreas: '◊ñ◊ï◊î◊ï ◊ê◊ñ◊ï◊®◊ô◊ù',
  selectedPlace: '◊†◊ë◊ó◊®',
  coordsDetected: '◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™ ◊†◊ß◊ú◊ò◊ï:',
  locationDetectedCoords: '◊û◊ô◊ß◊ï◊ù ◊†◊ß◊ú◊ò:',
  found: '◊†◊û◊¶◊ê!',
  foundPlace: '◊†◊û◊¶◊ê:',
  newVersionAvailable: '◊í◊®◊°◊î ◊ó◊ì◊©◊î ◊ñ◊û◊ô◊†◊î:',
  removedFromRoute: '◊î◊ï◊°◊® ◊û◊î◊û◊°◊ú◊ï◊ú',
  addedMorePlaces: '◊†◊ï◊°◊§◊ï ◊û◊ß◊ï◊û◊ï◊™ ◊ú',
  noMoreInInterest: '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊¢◊ï◊ì ◊û◊ß◊ï◊û◊ï◊™ ◊ë',
  errorsGettingPlaces: '◊©◊í◊ô◊ê◊ï◊™ ◊ë◊ß◊ë◊ú◊™ ◊û◊ß◊ï◊û◊ï◊™:',
  interestDeletedWithPlaces: '◊™◊ó◊ï◊ù ◊†◊û◊ó◊ß (◊û◊ß◊ï◊û◊ï◊™ ◊¢◊ì◊ô◊ô◊ü ◊û◊©◊™◊û◊©◊ô◊ù ◊ë◊ï)',
  outsideAreaWarning: '◊ê◊ñ◊î◊®◊î: ◊î◊û◊ô◊ß◊ï◊ù ◊û◊ó◊ï◊• ◊ú◊ê◊ñ◊ï◊®◊ô◊ù ◊©◊†◊ë◊ó◊®◊ï. ◊†◊©◊û◊® ◊ë◊õ◊ú ◊ñ◊ê◊™.',
  fileDownloaded: '◊î◊ß◊ï◊ë◊• ◊î◊ï◊®◊ì!',
  invalidFileNoData: '◊ß◊ï◊ë◊• ◊ú◊ê ◊™◊ß◊ô◊ü - ◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊†◊™◊ï◊†◊ô◊ù',
  addedFromSearch: '◊†◊ï◊°◊£ ◊û◊ó◊ô◊§◊ï◊©',
},

// --- Settings ---
settings: {
  title: '◊î◊í◊ì◊®◊ï◊™',
  sendFeedback: '◊©◊ú◊ó ◊û◊©◊ï◊ë',
  writeFeedback: '◊ê◊†◊ê ◊õ◊™◊ï◊ë ◊û◊©◊ï◊ë',
  feedbackPlaceholder: '◊°◊§◊® ◊ú◊†◊ï ◊û◊î ◊ó◊©◊ë◊™...',
  setPassword: '◊î◊í◊ì◊® ◊°◊ô◊°◊û◊î',
  changePassword: '◊©◊†◊î ◊°◊ô◊°◊û◊™ ◊û◊¢◊®◊õ◊™:',
  setNewPassword: '◊î◊í◊ì◊® ◊°◊ô◊°◊û◊™ ◊û◊¢◊®◊õ◊™:',
  wrongPassword: '◊°◊ô◊°◊û◊î ◊©◊í◊ï◊ô◊î',
  newPasswordPlaceholder: '◊°◊ô◊°◊û◊î ◊ó◊ì◊©◊î...',
  noPassword: 'üîì ◊ú◊ú◊ê ◊°◊ô◊°◊û◊î - ◊í◊ô◊©◊î ◊§◊™◊ï◊ó◊î ◊ú◊õ◊ï◊ú◊ù',
  systemProtected: 'üîí ◊û◊¢◊®◊õ◊™ ◊û◊ï◊í◊†◊™ ◊ë◊°◊ô◊°◊û◊î',
  refreshData: '◊®◊¢◊†◊ü ◊ê◊™ ◊õ◊ú ◊î◊†◊™◊ï◊†◊ô◊ù',
  deleteAllConfirm: '◊ú◊û◊ó◊ï◊ß ◊ê◊™ ◊õ◊ú ◊ú◊ï◊í ◊î◊õ◊†◊ô◊°◊ï◊™? ◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊ë◊ú◊™◊ô ◊î◊§◊ô◊õ◊î.',
  deleteAllFeedback: '◊ú◊û◊ó◊ï◊ß ◊ê◊™ ◊õ◊ú ◊î◊û◊©◊ï◊ë◊ô◊ù?',
  appDescription: '◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊ú◊™◊õ◊†◊ï◊ü ◊ò◊ô◊ï◊ú◊ô◊ù',
  language: '◊©◊§◊î',
  password: '◊°◊ô◊°◊û◊î',
  systemPassword: '◊°◊ô◊°◊û◊™ ◊û◊¢◊®◊õ◊™',
  error: '◊©◊í◊ô◊ê◊î',
  maxStops: '◊û◊°◊§◊® ◊û◊ß◊ï◊û◊ï◊™ ◊ë◊û◊°◊ú◊ï◊ú',
  googleMaxWaypoints: '◊û◊ß◊°◊ô◊û◊ï◊ù ◊†◊ß◊ï◊ì◊ï◊™ ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™',
  googleMaxWaypointsDesc: '◊û◊í◊ë◊ú◊™ ◊í◊ï◊í◊ú ◊û◊§◊ï◊™. ◊ê◊ù ◊î◊û◊°◊ú◊ï◊ú ◊ó◊ï◊®◊í ‚Äî ◊ô◊§◊ï◊¶◊ú ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™.',
  googleMaxMapPoints: '◊û◊ß◊°◊ô◊û◊ï◊ù ◊†◊ß◊ï◊ì◊ï◊™ ◊ú◊î◊¶◊í◊î ◊¢◊ú ◊û◊§◊î',
  googleMaxMapPointsDesc: '◊û◊¢◊ú ◊û◊°◊§◊® ◊ñ◊î ◊™◊ï◊¶◊í ◊î◊™◊®◊ê◊î ◊©◊ô◊™◊õ◊ü ◊ï◊í◊ï◊í◊ú ◊ú◊ê ◊ô◊¶◊ô◊í ◊ê◊™ ◊õ◊ï◊ú◊ü.',
  defaultRadius: '◊®◊ì◊ô◊ï◊° ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú',
  radiusDescription: '◊®◊ì◊ô◊ï◊° ◊ó◊ô◊§◊ï◊© ◊û◊°◊ë◊ô◊ë ◊ú◊û◊ô◊ß◊ï◊ù ◊†◊ï◊õ◊ó◊ô (◊û◊ò◊®◊ô◊ù)',
  refreshData: '◊®◊¢◊†◊ï◊ü ◊†◊™◊ï◊†◊ô◊ù',
  refreshDescription: '◊ò◊¢◊ü ◊û◊ó◊ì◊© ◊ê◊™ ◊õ◊ú ◊î◊†◊™◊ï◊†◊ô◊ù ◊û-Firebase: ◊™◊ó◊ï◊û◊ô◊ù, ◊û◊ß◊ï◊û◊ï◊™, ◊û◊°◊ú◊ï◊ú◊ô◊ù ◊ï◊î◊í◊ì◊®◊ï◊™',
  changePassword: '◊©◊†◊î ◊°◊ô◊°◊û◊™ ◊û◊¢◊®◊õ◊™:',
  setNewPassword: '◊î◊í◊ì◊® ◊°◊ô◊°◊û◊™ ◊û◊¢◊®◊õ◊™:',
  systemProtected: 'üîí ◊û◊¢◊®◊õ◊™ ◊û◊ï◊í◊†◊™ ◊ë◊°◊ô◊°◊û◊î',
  noPassword: 'üîì ◊ú◊ú◊ê ◊°◊ô◊°◊û◊î - ◊í◊ô◊©◊î ◊§◊™◊ï◊ó◊î ◊ú◊õ◊ï◊ú◊ù',
  newPasswordPlaceholder: '◊°◊ô◊°◊û◊î ◊ó◊ì◊©◊î...',
  lockedSettings: '◊î◊í◊ì◊®◊ï◊™ ◊†◊¢◊ï◊ú◊ï◊™',
  citiesAndAreas: '◊¢◊®◊ô◊ù ◊ï◊ê◊ñ◊ï◊®◊ô◊ù',
  generalSettings: '◊î◊í◊ì◊®◊ï◊™ ◊õ◊ú◊ú◊ô◊ï◊™',
  editArea: '◊¢◊®◊ô◊õ◊™ ◊ê◊ñ◊ï◊®',
  editOnMap: '◊¢◊®◊ï◊ö ◊¢◊ú ◊î◊û◊§◊î',
  addCity: '◊î◊ï◊°◊£ ◊¢◊ô◊®',
  enterCityName: '◊î◊ß◊ú◊ì ◊©◊ù ◊¢◊ô◊® ◊ë◊ê◊†◊í◊ú◊ô◊™',
  cityNotFound: '◊¢◊ô◊® ◊ú◊ê ◊†◊û◊¶◊ê◊î, ◊†◊°◊î ◊©◊ù ◊ê◊ó◊®',
  cityAlreadyExists: '◊¢◊ô◊® ◊õ◊ë◊® ◊ß◊ô◊ô◊û◊™ ◊ë◊û◊¢◊®◊õ◊™',
  generateCity: '◊¶◊ï◊® ◊¢◊ô◊®',
  generatingCity: '◊û◊ô◊ô◊¶◊® ◊†◊™◊ï◊†◊ô ◊¢◊ô◊®...',
  cityAdded: '◊†◊ï◊°◊§◊î ◊ú◊û◊¢◊®◊õ◊™',
  cityStartsInactive: '◊î◊¢◊ô◊® ◊™◊ô◊ï◊ï◊¶◊® ◊ë◊û◊¶◊ë ◊ú◊ê ◊§◊¢◊ô◊ú ‚Äî ◊î◊™◊ê◊ù ◊ê◊ñ◊ï◊®◊ô◊ù ◊ï◊î◊§◊¢◊ú',
  addCityConfirm: '◊î◊ï◊°◊£ ◊¢◊ô◊® ◊ú◊û◊¢◊®◊õ◊™',
  exportCity: '◊ô◊ô◊¶◊ê ◊ß◊ï◊ë◊• ◊¢◊ô◊®',
  unsavedChanges: '◊ô◊© ◊©◊ô◊†◊ï◊ô◊ô◊ù ◊©◊ú◊ê ◊ô◊ï◊¶◊ê◊ï ‚Äî ◊ô◊ô◊¶◊ê ◊ß◊ï◊ë◊• ◊¢◊ô◊®',
  addArea: '◊î◊ï◊°◊£ ◊ê◊ñ◊ï◊®',
  newAreaName: '◊©◊ù ◊î◊ê◊ñ◊ï◊® ◊î◊ó◊ì◊©',
  areaExists: '◊ê◊ñ◊ï◊® ◊¢◊ù ◊©◊ù ◊ñ◊î ◊õ◊ë◊® ◊ß◊ô◊ô◊ù',
  renameArea: '◊©◊†◊î ◊©◊ù ◊ê◊ñ◊ï◊®',
  enterPasswordToRemove: '◊î◊ß◊ú◊ì ◊°◊ô◊°◊û◊™ ◊ê◊ì◊û◊ô◊ü ◊ú◊î◊°◊®◊™ ◊¢◊ô◊®',
  wrongPassword: '◊°◊ô◊°◊û◊î ◊©◊í◊ï◊ô◊î',
  radius: '◊®◊ì◊ô◊ï◊°',
  enterPassword: '◊î◊ñ◊ü ◊°◊ô◊°◊û◊î ◊ú◊§◊™◊ô◊ó◊™ ◊î◊î◊í◊ì◊®◊ï◊™',
},

// --- Help ---
help: {
  main: {
    title: '◊ê◊ô◊ö ◊ú◊î◊©◊™◊û◊©?',
    content: "**City Explorer** ◊¢◊ï◊ñ◊® ◊ú◊ö ◊ú◊í◊ú◊ï◊™ ◊û◊ß◊ï◊û◊ï◊™ ◊û◊¢◊†◊ô◊ô◊†◊ô◊ù ◊ï◊ú◊™◊õ◊†◊ü ◊û◊°◊ú◊ï◊ú ◊ò◊ô◊ï◊ú.\n\n**◊©◊†◊ô ◊û◊¶◊ë◊ô ◊©◊ô◊û◊ï◊©:**\n‚Ä¢ **◊û◊¶◊ë ◊û◊î◊ô◊®** (◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú) ‚Äî ◊ë◊ó◊® ◊ê◊ñ◊ï◊® ‚Üê ◊ë◊ó◊® ◊™◊ó◊ï◊û◊ô◊ù ‚Üê ◊ß◊ë◊ú ◊™◊ï◊¶◊ê◊ï◊™\n‚Ä¢ **◊û◊¶◊ë ◊û◊™◊ß◊ì◊ù** ‚Äî ◊©◊ú◊ô◊ò◊î ◊û◊ú◊ê◊î: ◊î◊ï◊°◊£ ◊û◊ß◊ï◊û◊ï◊™, ◊¢◊®◊ï◊ö, ◊©◊û◊ï◊® ◊û◊°◊ú◊ï◊ú◊ô◊ù\n\n**◊ê◊ô◊ö ◊û◊™◊ó◊ô◊ú◊ô◊ù:**\n1. ◊ë◊ó◊® ◊¢◊ô◊® ◊ï◊ê◊ñ◊ï◊® (◊ê◊ï \"◊î◊õ◊ú\", ◊ê◊ï GPS ◊ú◊ß◊®◊ï◊ë ◊ê◊ú◊ô◊ö) ◊ï◊™◊ó◊ï◊û◊ô ◊¢◊†◊ô◊ô◊ü, ◊ï◊ú◊ó◊• \"◊û◊¶◊ê ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊†◊ô◊ô◊ü\"\n2. ◊ë◊®◊©◊ô◊û◊™ ◊î◊™◊ï◊¶◊ê◊ï◊™: ◊ì◊ú◊í ◊¢◊ú ◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ê ◊û◊™◊ê◊ô◊û◊ô◊ù (‚è∏Ô∏è) ◊ï◊ë◊ó◊® üìå ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î\n3. ◊ë◊ó◊® ◊°◊ï◊í ◊û◊°◊ú◊ï◊ú (◊û◊¢◊í◊ú◊ô / ◊ú◊ô◊†◊ê◊®◊ô) ◊ï◊ú◊ó◊• \"◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú\"\n4. ◊ú◊ó◊• \"◊§◊™◊ó ◊û◊°◊ú◊ï◊ú ◊ë◊í◊ï◊í◊ú\" ◊ú◊†◊ô◊ï◊ï◊ò!\n\n**◊®◊ï◊¶◊î ◊¢◊ï◊ì ◊û◊ß◊ï◊û◊ï◊™?**\n‚Ä¢ **\"+ ◊¢◊ï◊ì\"** ◊ú◊ô◊ì ◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î ‚Äî ◊û◊ë◊ô◊ê ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊û◊í◊ï◊í◊ú ◊û◊ê◊ï◊™◊ï ◊™◊ó◊ï◊ù\n‚Ä¢ **\"‚ûï ◊î◊ï◊°◊£ ◊ô◊ì◊†◊ô◊™ ◊†◊ß◊ï◊ì◊î ◊ú◊û◊°◊ú◊ï◊ú\"** ‚Äî ◊ó◊§◊© ◊û◊ß◊ï◊ù ◊ú◊§◊ô ◊©◊ù ◊õ◊§◊ô ◊©◊î◊ï◊ê ◊û◊ï◊§◊ô◊¢ ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™ ◊ï◊î◊ï◊°◊£ ◊ê◊ï◊™◊ï ◊ô◊©◊ô◊®◊ï◊™\n\n**◊ò◊ô◊§:** ◊ú◊ó◊• ◊¢◊ú ◊©◊ù ◊û◊ß◊ï◊ù ◊õ◊ì◊ô ◊ú◊§◊™◊ï◊ó ◊ê◊ï◊™◊ï ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™"
  },
  placesListing: {
    title: '◊®◊©◊ô◊û◊™ ◊î◊û◊ß◊ï◊û◊ï◊™',
    content: "**◊ê◊ô◊ö ◊î◊û◊ß◊ï◊û◊ï◊™ ◊†◊ë◊ó◊®◊ô◊ù?**\n◊ß◊ï◊ì◊ù ◊û◊ï◊§◊ô◊¢◊ô◊ù ◊û◊ß◊ï◊û◊ï◊™ ◊©◊î◊ï◊°◊§◊ï ◊¢\"◊ô ◊î◊û◊©◊™◊û◊©◊ô◊ù (◊ì◊®◊ö \"◊û◊¶◊ë ◊û◊™◊ß◊ì◊ù\"), ◊ï◊ê◊ó◊® ◊õ◊ö ◊û◊ß◊ï◊û◊ï◊™ ◊û◊í◊ï◊í◊ú ◊ú◊§◊ô ◊ì◊ô◊®◊ï◊í.\n\n**◊õ◊§◊™◊ï◊®◊ô◊ù ◊ú◊ô◊ì ◊õ◊ú ◊û◊ß◊ï◊ù:**\n‚Ä¢ ‚è∏Ô∏è ‚Äî ◊ì◊ú◊í ◊¢◊ú ◊û◊ß◊ï◊ù (◊ú◊ê ◊ô◊ô◊õ◊ú◊ú ◊ë◊û◊°◊ú◊ï◊ú). ◊ú◊ó◊• ‚ñ∂Ô∏è ◊õ◊ì◊ô ◊ú◊î◊ó◊ñ◊ô◊®\n‚Ä¢ üìå ‚Äî ◊ß◊ë◊¢ ◊û◊ß◊ï◊ù ◊õ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î\n\n**◊ë◊û◊¶◊ë ◊û◊™◊ß◊ì◊ù ◊í◊ù:**\n‚Ä¢ + ‚Äî ◊î◊ï◊°◊£ ◊ú◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ô\n‚Ä¢ ‚úèÔ∏è ‚Äî ◊¢◊®◊ï◊ö ◊§◊®◊ò◊ô◊ù\n‚Ä¢ üóëÔ∏è ‚Äî ◊î◊°◊® (◊®◊ß ◊û◊ß◊ï◊û◊ï◊™ ◊©◊†◊ï◊°◊§◊ï ◊ô◊ì◊†◊ô◊™)\n\n**◊®◊ï◊¶◊î ◊¢◊ï◊ì ◊û◊ß◊ï◊û◊ï◊™?**\n‚Ä¢ **\"+ ◊¢◊ï◊ì\"** ◊ú◊ô◊ì ◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î ‚Äî ◊û◊ë◊ô◊ê ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊û◊í◊ï◊í◊ú ◊û◊ê◊ï◊™◊ï ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü\n‚Ä¢ **\"‚ûï ◊î◊ï◊°◊£ ◊ô◊ì◊†◊ô◊™ ◊†◊ß◊ï◊ì◊î ◊ú◊û◊°◊ú◊ï◊ú\"** ‚Äî ◊ó◊§◊© ◊û◊ß◊ï◊ù ◊ú◊§◊ô ◊©◊ù ◊õ◊§◊ô ◊©◊î◊ï◊ê ◊û◊ï◊§◊ô◊¢ ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™ ◊ï◊î◊ï◊°◊£ ◊ê◊ï◊™◊ï ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊û◊°◊ú◊ï◊ú\n\n**◊ú◊ó◊ô◊¶◊î ◊¢◊ú ◊©◊ù ◊î◊û◊ß◊ï◊ù** ◊§◊ï◊™◊ó◊™ ◊ê◊ï◊™◊ï ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™.\n\n**◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î:**\n◊ë◊ó◊® üìå ◊û◊û◊ß◊ï◊ù ◊ë◊®◊©◊ô◊û◊î, ◊ê◊ï ◊î◊©◊™◊û◊© ◊ë-üîç (◊ó◊ô◊§◊ï◊© ◊õ◊™◊ï◊ë◊™) / üìç (◊û◊ô◊ß◊ï◊ù GPS) ◊ë◊™◊ó◊™◊ô◊™ ◊î◊¢◊û◊ï◊ì.\n◊ú◊©◊ô◊†◊ï◊ô ‚Äî ◊ë◊ó◊® ◊û◊ß◊ï◊ù ◊ê◊ó◊® ◊ê◊ï ◊ú◊ó◊• ‚úï ◊ú◊ô◊ì ◊©◊ï◊®◊™ \"◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î\" ◊ú◊û◊ò◊î.\n\n**◊ó◊ô◊©◊ï◊ë ◊û◊°◊ú◊ï◊ú:**\n◊ë◊ó◊® ◊ú◊ô◊†◊ê◊®◊ô (◊û◊†◊ß◊ï◊ì◊î ◊ú◊†◊ß◊ï◊ì◊î) ◊ê◊ï ◊û◊¢◊í◊ú◊ô (◊ó◊ï◊ñ◊® ◊ú◊î◊™◊ó◊ú◊î), ◊ï◊ú◊ó◊• \"◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú\".\n◊ê◊ó◊®◊ô ◊ó◊ô◊©◊ï◊ë ◊ú◊ó◊• \"◊§◊™◊ó ◊û◊°◊ú◊ï◊ú ◊ë◊í◊ï◊í◊ú\" ◊ú◊†◊ô◊ï◊ï◊ò."
  },
  route: {
    title: '◊™◊ï◊¶◊ê◊ï◊™ ◊î◊û◊°◊ú◊ï◊ú',
    content: "**◊ê◊ó◊®◊ô \"◊û◊¶◊ê ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊†◊ô◊ô◊ü\"** ◊û◊ï◊§◊ô◊¢◊î ◊®◊©◊ô◊û◊™ ◊û◊ß◊ï◊û◊ï◊™ ◊û◊ó◊ï◊ú◊ß◊™ ◊ú◊§◊ô ◊™◊ó◊ï◊ù.\n\n**◊õ◊ì◊ô ◊ú◊ë◊†◊ï◊™ ◊û◊°◊ú◊ï◊ú:**\n1. ◊ë◊ó◊® üìå ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î (◊û◊î◊®◊©◊ô◊û◊î, ◊ó◊ô◊§◊ï◊© ◊õ◊™◊ï◊ë◊™, ◊ê◊ï ◊û◊ô◊ß◊ï◊ù GPS)\n2. ◊ú◊ó◊• \"◊ó◊©◊ë ◊û◊°◊ú◊ï◊ú\" ‚Äî ◊î◊û◊¢◊®◊õ◊™ ◊™◊°◊ì◊® ◊ê◊™ ◊î◊†◊ß◊ï◊ì◊ï◊™ ◊ë◊°◊ì◊® ◊î◊õ◊ô ◊î◊í◊ô◊ï◊†◊ô\n\n**◊®◊ï◊¶◊î ◊ú◊î◊ï◊°◊ô◊£ ◊û◊ß◊ï◊û◊ï◊™?**\n‚Ä¢ **\"+ ◊¢◊ï◊ì\"** ◊ú◊ô◊ì ◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î ‚Äî ◊û◊ë◊ô◊ê ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊û◊í◊ï◊í◊ú ◊û◊ê◊ï◊™◊ï ◊™◊ó◊ï◊ù\n‚Ä¢ **\"‚ûï ◊î◊ï◊°◊£ ◊ô◊ì◊†◊ô◊™\"** ‚Äî ◊ó◊§◊© ◊û◊ß◊ï◊ù ◊ú◊§◊ô ◊©◊ù ◊ë◊í◊ï◊í◊ú ◊ï◊î◊ï◊°◊£ ◊ê◊ï◊™◊ï ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊û◊°◊ú◊ï◊ú\n\n**◊§◊¢◊ï◊ú◊ï◊™ ◊†◊ï◊°◊§◊ï◊™:**\n‚Ä¢ üíæ **◊©◊û◊ï◊®** ‚Äî ◊©◊ï◊û◊® ◊ê◊™ ◊î◊û◊°◊ú◊ï◊ú ◊ú◊©◊ô◊û◊ï◊© ◊¢◊™◊ô◊ì◊ô\n‚Ä¢ üó∫Ô∏è **◊§◊™◊ó ◊ë◊í◊ï◊í◊ú** ‚Äî ◊û◊¶◊ô◊í ◊ê◊™ ◊î◊û◊°◊ú◊ï◊ú ◊î◊û◊ó◊ï◊©◊ë ◊ë◊í◊ï◊í◊ú ◊û◊§◊ï◊™\n‚Ä¢ ‚è∏Ô∏è **◊î◊©◊î◊î** ◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ê ◊û◊™◊ê◊ô◊û◊ô◊ù ◊ú◊ö ◊õ◊®◊í◊¢"
  },
  myContent: { title: '◊î◊™◊ï◊õ◊ü ◊©◊ú◊ô', content: "◊õ◊ê◊ü ◊ê◊§◊©◊® ◊ú◊†◊î◊ú ◊ê◊™ ◊î◊û◊ß◊ï◊û◊ï◊™ ◊ï◊î◊™◊ó◊ï◊û◊ô◊ù ◊©◊ú◊ö.\n\n**üìç ◊î◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ô** ‚Äî ◊û◊ß◊ï◊û◊ï◊™ ◊©◊î◊ï◊°◊§◊™ ◊ë◊¢◊¶◊û◊ö. ◊î◊ù ◊û◊ß◊ë◊ú◊ô◊ù ◊¢◊ì◊ô◊§◊ï◊™ ◊¢◊ú ◊û◊ß◊ï◊û◊ï◊™ ◊û◊í◊ï◊í◊ú!\n\n**üè∑Ô∏è ◊î◊™◊ó◊ï◊û◊ô◊ù ◊©◊ú◊ô** ‚Äî ◊ë◊ó◊® ◊ê◊ô◊ú◊ï ◊™◊ó◊ï◊û◊ô ◊¢◊†◊ô◊ô◊ü ◊ô◊ï◊§◊ô◊¢◊ï ◊ë◊ó◊ô◊§◊ï◊©. ◊ê◊§◊©◊® ◊í◊ù ◊ú◊ô◊¶◊ï◊® ◊™◊ó◊ï◊û◊ô◊ù ◊ó◊ì◊©◊ô◊ù." },
  myPlaces: { title: '◊î◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ô', content: "**◊û◊ß◊ï◊û◊ï◊™ ◊©◊î◊ï◊°◊§◊™** ◊û◊ï◊§◊ô◊¢◊ô◊ù ◊®◊ê◊©◊ï◊†◊ô◊ù ◊ë◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊©!\n\n**◊ú◊î◊ï◊°◊§◊™ ◊û◊ß◊ï◊ù:** ◊ú◊ó◊• \"‚ûï ◊î◊ï◊°◊£ ◊û◊ß◊ï◊ù\", ◊î◊ñ◊ü ◊©◊ù ◊ï◊ë◊ó◊® ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü.\n\n**◊§◊¢◊ï◊ú◊ï◊™:**\n‚Ä¢ ‚úèÔ∏è ◊¢◊®◊ï◊ö ◊§◊®◊ò◊ô◊ù\n‚Ä¢ üóëÔ∏è ◊û◊ó◊ß ◊û◊ß◊ï◊ù\n‚Ä¢ üö´ ◊®◊©◊ô◊û◊î ◊©◊ó◊ï◊®◊î ‚Äî ◊û◊ß◊ï◊ù ◊©◊ú◊ê ◊™◊®◊¶◊î ◊ú◊®◊ê◊ï◊™ ◊ô◊ï◊™◊®\n\n**◊ò◊ô◊§:** ◊ê◊§◊©◊® ◊í◊ù ◊ú◊î◊ï◊°◊ô◊£ ◊û◊ß◊ï◊û◊ï◊™ ◊ô◊©◊ô◊®◊ï◊™ ◊û◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊ë◊ú◊ó◊ô◊¶◊î ◊¢◊ú ◊õ◊§◊™◊ï◊® +" },
  myInterests: { title: '◊î◊™◊ó◊ï◊û◊ô◊ù ◊©◊ú◊ô', content: "**◊™◊ó◊ï◊û◊ô ◊î◊¢◊†◊ô◊ô◊ü** ◊ß◊ï◊ë◊¢◊ô◊ù ◊ê◊ô◊ú◊ï ◊°◊ï◊í◊ô ◊û◊ß◊ï◊û◊ï◊™ ◊ô◊ï◊§◊ô◊¢◊ï ◊ë◊ó◊ô◊§◊ï◊©.\n\n**◊ú◊î◊ï◊°◊ô◊£ ◊™◊ó◊ï◊ù ◊ó◊ì◊©:** ◊ú◊ó◊• \"‚ûï ◊î◊ï◊°◊£ ◊™◊ó◊ï◊ù\", ◊ë◊ó◊® ◊©◊ù ◊ï◊ê◊ô◊ô◊ß◊ï◊ü, ◊ï◊î◊í◊ì◊® ◊û◊î ◊ú◊ó◊§◊©.\n\n**◊ú◊©◊†◊ï◊™ ◊°◊ò◊ò◊ï◊°:** ◊ú◊ó◊• \"◊î◊©◊ë◊™\" ◊õ◊ì◊ô ◊ú◊î◊°◊™◊ô◊® ◊™◊ó◊ï◊ù ◊û◊î◊ó◊ô◊§◊ï◊©, ◊ê◊ï \"◊î◊§◊¢◊ú\" ◊ú◊î◊ó◊ñ◊ô◊®.\n\n**◊ú◊¢◊®◊ï◊ö ◊î◊í◊ì◊®◊ï◊™:** ◊ú◊ó◊• ‚úèÔ∏è ◊ú◊ô◊ì ◊™◊ó◊ï◊ù ◊õ◊ì◊ô ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊©◊ù, ◊ê◊ô◊ô◊ß◊ï◊ü, ◊ê◊ï ◊î◊í◊ì◊®◊ï◊™ ◊ó◊ô◊§◊ï◊©.\n\n**◊™◊ó◊ï◊ù ◊¢◊ù ◊û◊°◊í◊®◊™ ◊ê◊ì◊ï◊û◊î** ‚Äî ◊ó◊°◊® ◊î◊í◊ì◊®◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ï◊ú◊ê ◊ô◊¢◊ë◊ï◊ì ◊¢◊ì ◊©◊™◊í◊ì◊ô◊®." },
  interestConfig: { title: '◊î◊í◊ì◊®◊ï◊™ ◊™◊ó◊ï◊ù', content: "**◊î◊í◊ì◊®◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊©◊ú ◊î◊™◊ó◊ï◊ù**\n\n**◊©◊ù ◊î◊™◊ó◊ï◊ù:**\n◊î◊©◊ù ◊©◊ô◊ï◊§◊ô◊¢ ◊ë◊®◊©◊ô◊û◊™ ◊î◊™◊ó◊ï◊û◊ô◊ù.\n\n**◊°◊ï◊í ◊ó◊ô◊§◊ï◊© (Place Types):**\n◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ ◊©◊ú Google ◊ú◊û◊©◊ú: temple, restaurant, museum.\n◊î◊û◊¢◊®◊õ◊™ ◊û◊ë◊ô◊ê◊î ◊û◊ß◊ï◊û◊ï◊™ ◊©◊î◊°◊ï◊í ◊©◊ú◊î◊ù ◊û◊™◊ê◊ô◊ù ◊ú◊ê◊ó◊™ ◊î◊ß◊ò◊í◊ï◊®◊ô◊ï◊™.\n\n**◊ó◊ô◊§◊ï◊© ◊ò◊ß◊°◊ò (Text Search):**\n◊ó◊ô◊§◊ï◊© ◊ó◊ï◊§◊©◊ô, ◊ú◊û◊©◊ú: \"street art\", \"rooftop bar\".\n◊î◊û◊¢◊®◊õ◊™ ◊û◊ë◊ô◊ê◊î ◊û◊ß◊ï◊û◊ï◊™ ◊©◊í◊ï◊í◊ú ◊û◊¶◊ê ◊ú◊§◊ô ◊î◊ò◊ß◊°◊ò, ◊ï◊û◊°◊†◊†◊™ ◊õ◊ê◊ú◊î ◊©◊î◊©◊ù ◊©◊ú◊î◊ù ◊ú◊ê ◊û◊õ◊ô◊ú ◊ê◊™ ◊î◊ë◊ô◊ò◊ï◊ô.\n\n**◊û◊ô◊ú◊ï◊™ ◊°◊ô◊†◊ï◊ü (Blacklist):**\n◊û◊ô◊ú◊ô◊ù ◊©◊ê◊ù ◊û◊ï◊§◊ô◊¢◊ï◊™ ◊ë◊©◊ù ◊î◊û◊ß◊ï◊ù, ◊î◊ï◊ê ◊ú◊ê ◊ô◊ô◊õ◊ú◊ú. ◊ú◊û◊©◊ú: \"cannabis\", \"massage\" - ◊õ◊ì◊ô ◊ú◊°◊†◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊ú◊ê ◊®◊ú◊ï◊ï◊†◊ò◊ô◊ù.\n\n**‚ö†Ô∏è ◊ó◊©◊ï◊ë:** ◊™◊ó◊ï◊ù ◊ë◊ú◊ô ◊î◊í◊ì◊®◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ú◊ê ◊ô◊¢◊ë◊ï◊ì!" },
  searchLogic: { title: '◊ê◊ô◊ö ◊î◊û◊¢◊®◊õ◊™ ◊û◊ï◊¶◊ê◊™ ◊û◊ß◊ï◊û◊ï◊™?', content: "**◊°◊ì◊® ◊î◊û◊¶◊ô◊ê◊î:**\n1. **◊ß◊ï◊ì◊ù** - ◊î◊û◊ß◊ï◊û◊ï◊™ ◊©◊ú◊ö (◊û◊ï◊™◊ê◊û◊ô◊ù ◊ê◊ô◊©◊ô◊™) ◊©◊™◊ï◊ê◊û◊ô◊ù ◊ú◊ê◊ñ◊ï◊® ◊ï◊ú◊™◊ó◊ï◊ù\n2. **◊ê◊ó◊® ◊õ◊ö** - ◊û◊ß◊ï◊û◊ï◊™ ◊û-Google Places API\n\n**◊°◊ô◊†◊ï◊ü ◊û◊ß◊ï◊û◊ï◊™ ◊û◊í◊ï◊í◊ú:**\n‚Ä¢ ◊û◊ß◊ï◊ù ◊¢◊ù ◊©◊ù ◊©◊û◊õ◊ô◊ú ◊û◊ô◊ú◊™ ◊°◊ô◊†◊ï◊ü (blacklist) = ◊û◊°◊ï◊†◊ü\n‚Ä¢ ◊û◊ß◊ï◊ù ◊©◊©◊û◊ï ◊ñ◊î◊î ◊ú◊û◊ß◊ï◊ù ◊©◊ú◊ö = ◊û◊°◊ï◊†◊ü (◊û◊†◊ô◊¢◊™ ◊õ◊§◊ô◊ú◊ï◊ô◊ï◊™)\n‚Ä¢ ◊û◊ß◊ï◊ù \"◊ì◊ú◊í ◊ú◊¶◊û◊ô◊™◊ï◊™\" = ◊û◊°◊ï◊†◊ü\n‚Ä¢ ◊ó◊ô◊§◊ï◊© ◊ò◊ß◊°◊ò: ◊®◊ß ◊û◊ß◊ï◊û◊ï◊™ ◊©◊î◊©◊ù ◊©◊ú◊î◊ù ◊û◊õ◊ô◊ú ◊ê◊™ ◊ë◊ô◊ò◊ï◊ô ◊î◊ó◊ô◊§◊ï◊© ◊î◊û◊ú◊ê\n\n**◊™◊ô◊¢◊ì◊ï◊£:**\n‚Ä¢ ◊û◊ß◊ï◊û◊ï◊™ ◊û◊û◊ï◊ô◊†◊ô◊ù ◊ú◊§◊ô ◊ì◊ô◊®◊ï◊í (◊û◊î◊í◊ë◊ï◊î ◊ú◊†◊û◊ï◊ö)\n‚Ä¢ ◊î◊ì◊ô◊®◊ï◊í ◊û◊©◊û◊© ◊®◊ß ◊ú◊°◊ì◊®, ◊ú◊ê ◊ú◊°◊ô◊†◊ï◊ü\n\n**◊õ◊û◊ï◊™:**\n‚Ä¢ ◊û◊°◊§◊® ◊î◊û◊ß◊ï◊û◊ï◊™ ◊û◊ó◊ï◊ú◊ß ◊©◊ï◊ï◊î ◊ë◊ô◊ü ◊î◊™◊ó◊ï◊û◊ô◊ù ◊©◊ë◊ó◊®◊™\n‚Ä¢ ◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™ ◊ë◊î◊í◊ì◊®◊ï◊™\n\n**\"+ ◊¢◊ï◊ì\":**\n‚Ä¢ ◊û◊ï◊°◊ô◊£ ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊û◊ê◊ï◊™◊ï ◊™◊ó◊ï◊ù (◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú: 3)\n‚Ä¢ ◊î◊û◊ß◊ï◊û◊ï◊™ ◊î◊ó◊ì◊©◊ô◊ù ◊û◊°◊ï◊û◊†◊ô◊ù ◊ë◊í◊ë◊ï◊ú ◊õ◊ó◊ï◊ú ◊û◊ß◊ï◊ï◊ß◊ï" },
  saved: { title: '◊û◊°◊ú◊ï◊ú◊ô◊ù ◊©◊û◊ï◊®◊ô◊ù', content: "**◊û◊î ◊ô◊© ◊õ◊ê◊ü:**\n◊õ◊ú ◊î◊û◊°◊ú◊ï◊ú◊ô◊ù ◊©◊©◊û◊®◊™ ◊ú◊©◊ô◊û◊ï◊© ◊¢◊™◊ô◊ì◊ô.\n\n**◊©◊û◊ô◊®◊™ ◊û◊°◊ú◊ï◊ú:**\n‚Ä¢ ◊ú◊ó◊• \"üíæ ◊©◊û◊ï◊® ◊û◊°◊ú◊ï◊ú\" ◊ë◊û◊°◊ö ◊î◊û◊°◊ú◊ï◊ú\n‚Ä¢ ◊™◊ü ◊©◊ù ◊ô◊ô◊ó◊ï◊ì◊ô (◊ó◊ï◊ë◊î)\n‚Ä¢ ◊î◊ï◊°◊£ ◊î◊¢◊®◊ï◊™ ◊ê◊ù ◊®◊ï◊¶◊î\n\n**◊§◊¢◊ï◊ú◊ï◊™:**\n‚Ä¢ ◊ú◊ó◊• ◊¢◊ú ◊û◊°◊ú◊ï◊ú ◊ú◊ò◊¢◊ô◊†◊î ◊û◊ó◊ì◊©\n‚Ä¢ üóëÔ∏è ◊ú◊û◊ó◊ô◊ß◊™ ◊û◊°◊ú◊ï◊ú\n\n**◊ò◊ô◊§:**\n◊û◊°◊ú◊ï◊ú◊ô◊ù ◊†◊õ◊ú◊ú◊ô◊ù ◊ë◊ô◊ô◊¶◊ï◊ê/◊ô◊ô◊ë◊ï◊ê ◊ë◊î◊í◊ì◊®◊ï◊™!" },
  settings: { title: '◊î◊í◊ì◊®◊ï◊™', content: "**◊î◊í◊ì◊®◊ï◊™ ◊î◊û◊¢◊®◊õ◊™:**\n\n**◊û◊°◊§◊® ◊û◊ß◊ï◊û◊ï◊™:**\n‚Ä¢ ◊õ◊û◊ï◊™ ◊î◊û◊ß◊ï◊û◊ï◊™ ◊î◊û◊ß◊°◊ô◊û◊ú◊ô◊™ ◊ë◊û◊°◊ú◊ï◊ú\n‚Ä¢ ◊õ◊û◊ï◊™ ◊û◊ß◊ï◊û◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù ◊ë\"◊û◊¶◊ê ◊¢◊ï◊ì\"\n\n**◊ô◊ô◊ë◊ï◊ê/◊ô◊ô◊¶◊ï◊ê:**\n‚Ä¢ **◊ô◊ô◊¶◊ï◊ê** - ◊©◊ï◊û◊® ◊î◊õ◊ú ◊ú◊ß◊ï◊ë◊• JSON\n‚Ä¢ **◊ô◊ô◊ë◊ï◊ê** - ◊û◊ï◊°◊ô◊£ ◊û◊ß◊ï◊ë◊• (◊õ◊§◊ô◊ú◊ï◊ô◊ï◊™ ◊ô◊ì◊ï◊ú◊í◊ï)\n\n**Admin (◊ú◊û◊†◊î◊ú◊ô◊ù):**\n‚Ä¢ ◊¶◊§◊ô◊ô◊î ◊ë◊ú◊ï◊í ◊õ◊†◊ô◊°◊ï◊™\n‚Ä¢ ◊†◊ô◊î◊ï◊ú ◊û◊õ◊©◊ô◊®◊ô◊ù ◊û◊ï◊®◊©◊ô◊ù\n‚Ä¢ ◊°◊ô◊°◊û◊™ Admin" },
  addLocation: { title: '◊î◊ï◊°◊§◊™/◊¢◊®◊ô◊õ◊™ ◊û◊ß◊ï◊ù', content: "**◊ó◊ï◊ë◊î:** ◊©◊ù ◊î◊û◊ß◊ï◊ù + ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü ◊ê◊ó◊ì ◊ú◊§◊ó◊ï◊™.\n\n**◊©◊ì◊ï◊™ ◊†◊ï◊°◊§◊ô◊ù (◊ú◊ê ◊ó◊ï◊ë◊î):**\n‚Ä¢ ◊ê◊ô◊ñ◊ï◊®, ◊õ◊™◊ï◊ë◊™, ◊î◊¢◊®◊ï◊™, ◊™◊û◊ï◊†◊î\n‚Ä¢ ◊ß◊ô◊©◊ï◊® ◊û◊í◊ï◊í◊ú ◊û◊§◊ï◊™\n\n**◊ß◊ï◊ê◊ï◊®◊ì◊ô◊†◊ò◊ï◊™** ‚Äî ◊†◊ì◊®◊©◊ï◊™ ◊õ◊ì◊ô ◊©◊î◊û◊ß◊ï◊ù ◊ô◊ï◊§◊ô◊¢ ◊ë◊û◊°◊ú◊ï◊ú.\n◊î◊ì◊®◊ö ◊î◊ß◊ú◊î: ◊ú◊ó◊• üî§ (◊ó◊ô◊§◊ï◊© ◊ú◊§◊ô ◊©◊ù) ◊ê◊ï ◊î◊ì◊ë◊ß ◊ß◊ô◊©◊ï◊® ◊û◊í◊ï◊í◊ú ◊û◊§◊ï◊™ ◊ï◊ú◊ó◊• üîó.\n\n**◊õ◊§◊™◊ï◊®◊ô◊ù ◊ú◊û◊ò◊î:**\n‚Ä¢ **◊î◊ï◊°◊£/◊¢◊ì◊õ◊ü** ‚Äî ◊©◊ï◊û◊® ◊ï◊†◊©◊ê◊® ◊ë◊ó◊ú◊ï◊ü\n‚Ä¢ **X** ◊ú◊û◊¢◊ú◊î ‚Äî ◊°◊ï◊í◊® ◊ë◊ú◊ô ◊ú◊©◊û◊ï◊®" },
  addInterest: { title: '◊î◊ï◊°◊§◊™/◊¢◊®◊ô◊õ◊™ ◊™◊ó◊ï◊ù ◊¢◊†◊ô◊ô◊ü', content: "**◊ê◊ô◊ö ◊û◊ï◊°◊ô◊§◊ô◊ù ◊™◊ó◊ï◊ù ◊ó◊ì◊©:**\n1. ◊ë◊ó◊® **◊©◊ù** ◊ï**◊ê◊ô◊ô◊ß◊ï◊ü** (◊ê◊ô◊û◊ï◊í'◊ô)\n2. ◊ë◊ó◊® **◊°◊ï◊í ◊ó◊ô◊§◊ï◊©:**\n   ‚Ä¢ **Category** ‚Äî ◊ú◊§◊ô ◊°◊ï◊í ◊û◊ß◊ï◊ù ◊ë◊í◊ï◊í◊ú (◊ú◊û◊©◊ú: museum, restaurant)\n   ‚Ä¢ **Text** ‚Äî ◊ó◊ô◊§◊ï◊© ◊ó◊ï◊§◊©◊ô (◊ú◊û◊©◊ú: \"rooftop bar\")\n3. ◊ú◊ó◊• **◊î◊ï◊°◊£** ‚Äî ◊î◊™◊ó◊ï◊ù ◊ô◊ï◊§◊ô◊¢ ◊ë◊®◊©◊ô◊û◊™ ◊î◊™◊ó◊ï◊û◊ô◊ù\n\n**◊û◊ô◊ú◊ï◊™ ◊°◊ô◊†◊ï◊ü** ‚Äî ◊û◊ß◊ï◊û◊ï◊™ ◊¢◊ù ◊û◊ô◊ú◊ô◊ù ◊ê◊ú◊ï ◊ë◊©◊ù ◊ú◊ê ◊ô◊ô◊õ◊ú◊ú◊ï (◊ú◊û◊©◊ú: cannabis)." },
},

  import: {
    interests: '◊™◊ó◊ï◊û◊ô◊ù:',
    configs: '◊î◊í◊ì◊®◊ï◊™:',
    locations: '◊û◊ß◊ï◊û◊ï◊™:',
    routes: '◊û◊°◊ú◊ï◊ú◊ô◊ù:',
  },
}, // end Hebrew


// ============================================================================
// ENGLISH STRINGS
// ============================================================================

en: {

general: {
  appName: 'City Explorer',
  city: 'City',
  all: 'All',
  allCity: 'Entire city',
  close: 'Close',
  cancel: 'Cancel',
  save: 'Save',
  update: 'üíæ Update',
  add: '‚ûï Add',
  delete: 'Delete',
  deleteAll: 'Delete all',
  edit: 'Edit',
  show: 'Show',
  hide: 'Hide',
  search: 'Search',
  clear: 'Clear',
  clearSelection: 'Clear selection',
  help: 'Help',
  loading: '‚è≥ Loading...',
  searching: 'Searching...',
  refreshing: 'Refreshing...',
  password: 'Password',
  general: 'General',
  static: 'Static',
  open: 'Open',
  viewOnly: 'View only',
  locked: 'Locked',
  readOnly: 'Read only',
  error: 'Error',
  unknownError: 'Unknown error',
  safeArea: 'Safe',
  cautionArea: 'Use caution',
  dangerArea: 'Dangerous',
  enabled: '‚úÖ Active',
  disabled: '‚è∏Ô∏è Disabled',
  enableAlt: 'Enable',
  enableCity: 'Enable city',
  disableCity: 'Disable city',
  included: '‚úÖ Included',
  custom: 'Custom',
  private: 'üë§ Private',
  system: 'üèóÔ∏è System',
  generalFeedback: 'üí≠ General',
  personalNote: 'üë§ Personal',
  idea: 'üí° Idea',
  bug: 'üêõ Bug',
  mine: 'üéñÔ∏è Mine',
  inProgress: 'In progress',
  underReview: 'üõ†Ô∏è Under review',
  noDescription: 'No description',
  noLocation: 'No location',
  noArea: 'No area',
  outsideBoundary: 'Outside boundary',
  clickForDetails: 'Click for full details',
  clickForImage: 'Click to view image',
  fromGoogle: 'From Google',
  fromGoogleApi: 'From Google API',
  addedFromSearch: 'Added from search',
  addedFromGoogle: 'Added from Google',
  addedManually: 'Added manually',
  addedByUser: 'My place',
  fromMyPlaces: 'From your places',
  addedViaMore: 'Added via +more',
  customPlace: 'Custom place',
  meters100: '>100m',
  meters2000: '>2000m',
  caution: 'Caution',
  openStatus: 'Open',
  closedStatus: 'Closed',
  skipPermanently: 'Skip permanently',
  areas: 'areas',
  total: 'Total',
  version: 'Version',
  selected: 'selected',
  refresh: 'Refresh',
  share: 'Share',
  search: 'Search',
  cancel: 'Cancel',
  save: 'OK',
  mine: 'üéñÔ∏è Mine',
  clear: 'Clear',
  show: 'Show',
  hide: 'Hide',
  system: 'üèóÔ∏è System',
  private: 'üë§ Personal',
  bug: 'üêõ Bug',
  idea: 'üí° Idea',
  generalFeedback: 'üí≠ General',
  customPlace: 'Custom place',
  general: 'General',
  static: 'Static',
  fromGoogleApi: 'from Google API',
  refreshing: 'Refreshing...',
  searching: 'Searching...',
  addedViaMore: 'Added via +more',
  addedManually: 'Added manually',
  fromMyPlaces: 'from my places',
  addedFromGoogle: 'Added from Google',
  addedByUser: 'Added by user',
  error: 'Error',
  all: 'All',
  enableCity: 'Enable city',
  disableCity: 'Disable city',
  noPlacesWithCoords: 'No places with valid coordinates',

  updateNow: 'Update now',
  newVersionAvailableBanner: 'üîÑ New version available!',
  howItWorks: 'How it works',
  nearMe: 'Near me',
  next: 'Next',
  back: 'Back',
  startOver: 'Start over',
  mayTakeSeconds: 'This may take a few seconds',
  myPlace: 'My place',
  more: 'more',
  start: 'Start',
  linear: 'Linear',
  backToForm: 'Back to form',
  savedOn: 'Saved on',
  customStops: 'custom',
  consoleHint: 'Full details in Console (F12) - copy and send for fix',
  clickForDetails: 'Click for full details',
  restoredToList: 'restored to regular list',
  resultsFound: 'results found',
  noInterestManual: 'No interest / manually added',
  showActivityLog: 'Show activity log for debugging',
  debugMessages: 'Debug messages will appear in console (F12)',
  adminManagement: 'Admin management',
  currentDevice: 'Current device',
  status: 'Status',
  open: 'Open',
  noRegisteredUsers: 'No registered users',
  you: 'you',
  remove: 'Remove',
  removed: 'removed',
  active: 'Active',
  inactive: 'Inactive',
  viewAccessLog: 'View access log',
  new: 'New!',
  importExport: 'Import & Export',
  saveAndTransfer: 'Save and transfer data between devices',
  exportAll: 'Export all',
  importFromFile: 'Import from file',
  transferDevices: 'Transfer between Claude and GitHub',
  dataBackup: 'Data backup',
  shareWithFriends: 'Share with friends',
  areas: 'areas',
  debugMode: 'Debug mode',
  searchError: 'Search error',
  noResultsFoundSearch: 'No results found',
  added: 'Added!',
  canAddMore: 'You can add more or close',
  ok: 'OK',
  openInGoogle: 'Open in Google',
  openInGoogleNoCoords: 'Open in Google (no coords)',
  viewOnly: 'View only',
  deletePlace: 'Delete place',
  deleteInterest: 'Delete interest',
  deleteRoute: 'Delete route',
  clearLog: 'Clear log',
  shareRoute: 'Share route',
  sharePoi: 'Share POI',
  openRoute: 'Open route',
  restoreActive: 'Restore as active',
  skipPermanent: 'Skip permanently',
  update: 'Update',
  close: 'Close',
  uses: 'Uses',
  adminUsers: 'Admin users',
  googleInfo: 'Google info',
  notes: 'Notes...',
  inProgress: 'In progress',
  locked: 'Locked',
  readOnly: 'Read only',
  interestName: 'Interest name',
  addInterestTitle: 'Add interest',
  autoDetect: 'Auto-detect',
  searchHintAddress: 'Enter address, hotel, train station, or any place',
  findPlaces: 'Find places',
  address: 'Address',
  placesHeader: 'Places',
  interestsHeader: 'Interests',
  searchTip: 'Click üîç to search address, üìç for location, or üìå from your places',
  stopsCount: 'stops',
  searchAndAddHint: 'üí° Search and click to add to route. You can add multiple places.',
  placesAddedManually: 'places added manually',
  clickToUpload: 'Click to upload',
  image: 'Image',
  links: 'Links',
  coordinates: 'Coordinates',
  permissions: 'Permissions',
  found: 'Found',
  rating: 'Rating',
  area: 'Area',
  notesLabel: 'Notes',
  searchMode: 'Search Mode',
  name: 'Name',
  link: 'Link',
  location: 'Location',
  icon: 'Icon',
  routeName: 'Route name',
  mapsLink: 'Maps link',
  searchSettings: 'Search settings',
  tryDifferentSearch: 'Try a different search',
  startTypingToSearch: 'Start typing to search',
  multiplier: 'Multiplier',
  noEntries: 'No entries yet',
  noFeedback: 'No feedback yet',
  feedback: 'Feedback',
},

nav: {
  form: 'Plan',
  route: 'Route',
  search: 'Search',
  saved: 'Saved',
  myPlaces: 'Places',
  myInterests: 'Interests',
  settings: 'Settings',
  quickMode: 'Quick mode',
  advancedMode: 'Advanced mode',
  switchToQuick: 'Switch to quick mode',
  planTrip: 'Plan your trip',
  advancedMode: 'Advanced mode',
  quickMode: 'Quick mode',
},

wizard: {
  step1Title: 'Plan your trip',
  step1Subtitle: 'Choose between area / near me / whole city',
  step2Title: 'What interests you?',
  step2Subtitle: 'Choose one or more topics',
  step3Title: 'Results',
  myLocation: 'My location',
  locationFound: 'üìç Location found!',
  findPlaces: 'Find places',
  findPlacesCount: 'üîç Find points of interest ({count} places)',
  showMap: 'Show map',
  allAreasMap: 'üó∫Ô∏è All areas map',
},

form: {
  whatInterests: '‚≠ê What interests you?',
  searchRadius: 'üìç Search radius',
  radiusLabel: 'Radius:',
  gpsSearch: 'Search by GPS',
  gps: 'GPS',
  myPlace: 'My place',
  searchMyPlace: 'üîç Search my place...',
  allMode: 'All',
  areaMode: 'Area',
  radiusMode: 'Radius',
  currentLocation: 'Current location',
  findCurrentLocation: 'Find current location',
  locateMe: 'üìç Locate me',
  locationDetected: 'üìç Location detected',
  locationDetectedFull: 'üìç Current location detected!',
  locationDetectedShort: 'üìç Location detected!',
  locationDetectedNoAddr: 'üìç Location detected (no address found)',
  locating: '‚è≥ Locating...',
  searchingLocation: 'Searching for location...',
  searchAddress: 'Search address',
  searchByAddress: 'Search by address',
  searchByName: 'Search by place name',
  searchingByName: 'Searching by name...',
  searchPlaceGoogle: 'Search place on Google',
  enterAddress: 'Please enter an address',
  enterPlaceName: 'Please enter a place name',
  enterAddressOrName: 'Enter address or place name',
  typeAddress: 'Type address, hotel name, place...',
  typeAddressAlt: 'Type address, place name, hotel...',
  extractFromLink: 'Extract from link',
  selectStartPoint: 'Choose a starting point',
  startPointFirst: 'Start from the first place in the list',
  setStartPoint: 'Set as starting point',
  chooseStartBeforeCalc: 'Choose a starting point before calculating route',
  findLocationFirst: 'Please find your current location first',
  needGpsFirst: 'Need to set GPS location first',
  selectAreaAndInterest: 'Please select an area and at least one interest',
  selectAtLeastOneInterest: 'Please select at least one interest',
  showSearchRadius: 'Show search radius',
  gpsRadiusHint: 'Search by GPS (1 km)',
  useGpsForRadius: 'üìç Press GPS or set location to use radius mode',
},

route: {
  calcRoute: 'üß≠ Calculate route',
  recalcRoute: 'üîÑ Recalculate route',
  saveRoute: 'Save route',
  editSavedRoute: 'üó∫Ô∏è Edit saved route',
  addSavedRoute: 'üó∫Ô∏è Add saved route',
  linear: 'Linear',
  linearRoute: '‚û°Ô∏è Linear',
  linearDesc: '‚û°Ô∏è Linear route',
  circular: 'Circular',
  circularRoute: 'üîÑ Circular route',
  circularDesc: 'üîÑ Circular route ‚Äî returns to starting point',
  routeDeleted: 'Route deleted',
  routeUpdated: 'Route updated',
  routeSaved: 'Route saved!',
  routeCopied: 'Route copied to clipboard',
  calcRoutePrevious: 'Calculate previous route',
  returnToRoute: 'Return to route',
  removeFromRoute: 'Remove from route',
  skipPlace: 'Skip place',
  skipTemporarily: 'Skip temporarily',
  skipPermanently: 'Skip permanently',
  cancelPermanentSkip: 'Cancel permanent skip',
  returnPlace: 'Return place',
  addToMyList: 'Add to my list',
  openedSuccess: 'Opened successfully!',
  linkCopied: 'Link copied! üìã',
  pointsCopied: 'Points of interest copied to clipboard',
  addManualStop: '‚ûï Manually add a stop to route',
  moreFromCategory: '+ more',
  reorderStops: '◊°◊ì◊® ◊¢◊¶◊ô◊®◊ï◊™',
  dragToReorder: '◊í◊®◊ï◊® ◊ú◊©◊ô◊†◊ï◊ô ◊°◊ì◊®',
  openRouteInGoogle: '◊§◊™◊ó ◊û◊°◊ú◊ï◊ú ◊ë◊í◊ï◊í◊ú',
  showStopsOnMap: '◊î◊¶◊í ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊ú ◊î◊û◊§◊î',
  backToList: '◊ó◊ñ◊ï◊® ◊ú◊®◊©◊ô◊û◊î',
  stopNumber: '◊¢◊¶◊ô◊®◊î',
  moveUp: '◊î◊¢◊ë◊® ◊ú◊û◊¢◊ú◊î',
  moveDown: '◊î◊¢◊ë◊® ◊ú◊û◊ò◊î',
  reorderStops: 'Reorder stops',
  dragToReorder: 'Drag to reorder',
  openRouteInGoogle: 'Open route in Google',
  openRoutePartN: 'Route part {n} of {total}',
  splitRouteWarning: '‚ö†Ô∏è Google Maps supports up to {max} points. Route split into {parts} parts. You can disable stops to reduce.',
  mapPointsWarning: '‚ÑπÔ∏è Google Maps may not display all {count} points on the map.',
  showStopsOnMap: 'Show stops on map',
  backToList: 'Back to list',
  stopNumber: 'Stop',
  moveUp: 'Move up',
  moveDown: 'Move down',
  routeCalculated: 'Route calculated!',
  stops: 'stops',
  places: 'places',
  savedAs: 'Saved:',
  startPoint: 'Starting point',
  routeType: 'Route type',
  newRoute: 'New route',
},

places: {
  addPlace: 'Add place',
  editPlace: 'Edit place',
  placeName: 'Place name',
  enterPlaceName: 'Please enter a place name',
  nameExists: 'This name already exists',
  placeExists: 'A place with this name already exists',
  address: 'Address',
  notes: 'Notes...',
  description: 'Short description of the place',
  findLocation: 'üìç Find location',
  updateLocation: '‚úÖ Update location',
  googleInfo: 'üîé Google info',
  searchingAddress: 'Searching address...',
  searchByNameHint: 'Search by name, description or notes...',
  placeAdded: 'Place added!',
  placeUpdated: 'Place updated!',
  placeDeleted: 'Place deleted!',
  placeAddedShared: 'Place added and saved for everyone!',
  detailsEdit: 'Details / Edit',
  editAddedToList: 'Edit (added to list)',
  missingDetails: 'Missing details',
  missingDetailsLong: 'Missing details (address/coordinates/topic)',
  noCoordinates: 'No coordinates - will not be included in route',
  noCoordinatesWarning: '‚ö†Ô∏è Missing coordinates',
  noCoordinatesWarnLong: '‚ö†Ô∏è Missing coordinates - will not be included in route',
  noLocationPermission: 'No location permission',
  outsideArea: 'Place outside area boundaries',
  placeNotOnGoogle: 'Place not found on Google',
  notEnoughInfo: 'Not enough info about the place',
  noPlacesFound: 'No results found',
  noMorePlaces: 'No more places found',
  noMatchingPlaces: 'No places found. Try different interests or area.',
  notEnoughInArea: 'Not enough matching places for this interest in selected area',
  notEnoughPartial: 'Not enough matching places for some interests in selected area',
  alreadyInRoute: 'Already in route',
  alreadyInList: 'Already in list',
  alreadyInMyList: 'Already in your list',
  alreadyBlacklisted: 'Already in skip list',
  addedToSkipList: 'Added to permanent skip',
  addedToYourList: 'Added to your list!',
  returnedToList: 'Returned to regular list',
  markHandled: 'Mark as handled',
  markUnhandled: 'Mark as not handled',
  selectImageFile: 'Please select an image file',
  noPlacesWithCoords: 'No places with valid coordinates',
  noPlacesInCity: 'No places in {cityName}',
  youHavePlaces: 'You have {count} places in {cityName}',
  noSavedRoutesInCity: 'No saved routes in {cityName}',
  googlePlaces: 'From Google Places',
  moreInCategory: '‚ûï More places in',
  editNoCoordsHint: 'This place has no coordinates. Click ‚úèÔ∏è to edit.',
  editNoCoordsHint2: 'This place has no coordinates. Edit the place to add them.',
  noResultsFor: 'No results found for',
  searchError: 'Search error',
  addressNotFound: 'No matching address found',
  addressNotFoundRetry: 'No address found. Try a different address',
  placeNotFoundRetry: 'Place not found. Try another name or address',
  locationNotInAnyArea: 'Location is not within any defined area',
  locationOutsideSelection: 'Your current location is outside the selected areas',
  noPlacesInRadius: 'No places found in recognized areas within selected radius. Try increasing radius.',
  needCoordsForAreas: 'Coordinates needed to identify areas',
  badCoords: 'Could not detect coordinates. Try a Google Maps link or: 13.7465,100.4927',
  shortLinksHint: 'Shortened links: open in browser and copy the full link',
  searchResults: 'Search',
  byInterest: 'By interest',
  byArea: 'By area',
  byName: 'By name',
  includedPlaces: 'Included places',
  skippedPlaces: 'Skipped places',
  alreadyInRoute: 'already in route',
  alreadyInMyList: 'already in your list',
  addedToYourList: 'added to your list!',
  alreadyBlacklisted: 'already in skip list',
  addedToSkipList: 'added to permanent skip',
  alreadyInList: 'already in list',
  editAddedToList: 'Edit (added to list)',
  noSavedRoutesInCity: 'No saved routes in',
  noPlacesInCity: 'No places in',
  noResultsFor: 'No results for',
  thisCity: 'this city',
  fromGoogleCache: 'from Google (cache)',
},

interests: {
  addInterest: 'Add interest',
  interestName: 'Interest name',
  interestAdded: 'Interest added!',
  interestUpdated: 'Interest updated!',
  interestDeleted: 'Interest deleted!',
  interestInvalid: 'Invalid interest',
  missingSearchConfig: 'Missing search settings',
  builtInRemoved: 'System interest removed',
  resetToDefault: 'Reset to default',
  interestsReset: 'Interests reset to default',
  exampleTypes: 'For example: movie theaters',
  privateOnly: 'Private interest',
  activeCount: 'active',
  customCount: 'Custom interests',
  activeInterests: 'Active interests',
  disabledInterests: 'Disabled interests',
  privateInterest: 'Private interest',
  myPlacesOnly: 'My places only, no Google',
  interestStatus: 'Interest status',
  categorySearch: 'Category Search (types)',
  textSearch: 'Text Search (query)',
  textQuery: 'Text Query',
  placeTypes: 'Place Types (comma separated)',
  seeTypesList: 'See types list',
  blacklistWords: 'Blacklist Words (comma separated)',
},

toast: {
  saveError: 'Save error',
  deleteError: 'Delete error',
  updateError: 'Update error',
  searchError: 'Search error',
  exportError: 'Export error',
  importError: 'Import error',
  sendError: 'Send error',
  locationError: 'Location detection error',
  addressSearchError: 'Address search error',
  routeSaveError: 'Route save error',
  imageUploadError: 'Image upload error',
  uploadingImage: 'Uploading image...',
  imageUploaded: 'Image uploaded successfully',
  addPlacesError: 'Error adding places',
  googleInfoError: 'Error fetching Google info',
  resetError: 'Reset error',
  logClearError: 'Error clearing log',
  fileReadError: 'Error reading file',
  refreshError: '‚ùå Error refreshing data',
  addressSearchErrorHint: 'Address search error. Try using a Google Maps link',
  storageFull: 'Save error - storage full. Try deleting old routes',
  locationNotAvailable: 'Location not available right now. Try again.',
  locationTimeout: 'Location request timed out. Try again.',
  locationFailed: 'Could not get location.',
  locationNoPermission: 'No location permission - please allow location access',
  locationNoPermissionBrowser: 'Location permission required. Please enable location access in browser settings.',
  locationUnavailable: 'Unable to detect location',
  locationInaccessible: 'Cannot access location',
  browserNoLocation: 'Browser does not support location',
  browserNoGps: 'Your browser does not support GPS location',
  noImportItems: 'No items found to import',
  invalidFile: 'Invalid file - no data found',
  feedbackDeleted: 'Feedback deleted',
  feedbackThanks: 'Thanks for the feedback! üôè',
  userRemoved: 'User removed',
  passwordSaved: 'Password saved!',
  passwordRemoved: 'Password removed - open access',
  logCleared: 'Log cleared',
  allFeedbackDeleted: 'All feedback deleted',
  appUpToDate: 'App is up to date ‚úÖ',
  cannotCheckUpdates: 'Cannot check for updates',
  dataRefreshed: 'üîÑ All data refreshed successfully!',
  dataRefreshedLocal: 'üîÑ Data refreshed (localStorage only - Firebase unavailable)',
  debugOn: '‚úÖ Debug enabled',
  debugOff: '‚ùå Debug disabled',
  addedNoteSuccess: '‚úÖ Added! You can add another place or close',
  firebaseUnavailable: 'Firebase unavailable',
  urlTooLong: '‚ö†Ô∏è URL too long. Some points may not display',
  addressVerified: '‚úÖ Address verified:',
  foundInArea: 'üìç Found in area:',
  detectedAreas: 'areas detected',
  selectedPlace: 'selected',
  coordsDetected: 'Coordinates detected:',
  locationDetectedCoords: 'Location detected:',
  found: 'Found!',
  foundPlace: 'Found:',
  newVersionAvailable: 'New version available:',
  removedFromRoute: 'Removed from route',
  addedMorePlaces: 'places added to',
  noMoreInInterest: 'No more places in',
  errorsGettingPlaces: 'Errors getting places:',
  interestDeletedWithPlaces: 'Interest deleted (places still using it)',
  outsideAreaWarning: 'Warning: Location outside selected areas. Saved anyway.',
  fileDownloaded: 'File downloaded!',
  invalidFileNoData: 'Invalid file - no data found',
  addedFromSearch: 'Added from search',
},

settings: {
  title: 'Settings',
  sendFeedback: 'Send feedback',
  writeFeedback: 'Please write feedback',
  feedbackPlaceholder: 'Tell us what you think...',
  setPassword: 'Set password',
  changePassword: 'Change system password:',
  setNewPassword: 'Set system password:',
  wrongPassword: 'Wrong password',
  newPasswordPlaceholder: 'New password...',
  noPassword: 'üîì No password - open access for everyone',
  systemProtected: 'üîí System protected by password',
  refreshData: 'Refresh all data',
  deleteAllConfirm: 'Delete all access logs? This action cannot be undone.',
  deleteAllFeedback: 'Delete all feedback?',
  appDescription: 'Trip planning app',
  language: 'Language',
  password: 'Password',
  systemPassword: 'System password',
  error: 'Error',
  maxStops: 'Places per route',
  googleMaxWaypoints: 'Max points in Google Maps',
  googleMaxWaypointsDesc: 'Google Maps limit. Routes exceeding this will be automatically split.',
  googleMaxMapPoints: 'Max points to show on map',
  googleMaxMapPointsDesc: 'Above this number a warning will be shown that Google may not display all points.',
  defaultRadius: 'Default radius',
  radiusDescription: 'Search radius around current location (meters)',
  refreshData: 'Refresh data',
  refreshDescription: 'Reload all data from Firebase: interests, places, routes and settings',
  changePassword: 'Change system password:',
  setNewPassword: 'Set system password:',
  systemProtected: 'üîí System password protected',
  noPassword: 'üîì No password - open access',
  newPasswordPlaceholder: 'New password...',
  lockedSettings: 'Locked settings',
  citiesAndAreas: 'Cities & Areas',
  generalSettings: 'General Settings',
  editArea: 'Edit area',
  editOnMap: 'Edit on map',
  addCity: 'Add city',
  enterCityName: 'Enter city name in English',
  cityNotFound: 'City not found, try another name',
  cityAlreadyExists: 'City already exists',
  generateCity: 'Generate city',
  generatingCity: 'Generating city data...',
  cityAdded: 'added to system',
  cityStartsInactive: 'City starts inactive ‚Äî adjust areas and activate',
  addCityConfirm: 'Add city to system',
  exportCity: 'Export city file',
  unsavedChanges: 'Unsaved changes ‚Äî export city file',
  addArea: 'Add area',
  newAreaName: 'New area name',
  areaExists: 'Area with this name already exists',
  renameArea: 'Rename area',
  enterPasswordToRemove: 'Enter admin password to remove city',
  wrongPassword: 'Wrong password',
  radius: 'Radius',
  enterPassword: 'Enter password to unlock',
},

help: {
  main: {
    title: 'How to use?',
    content: "**City Explorer** helps you discover interesting places and plan a trip route.\n\n**Two usage modes:**\n‚Ä¢ **Quick mode** (default) ‚Äî Choose area ‚Üí Choose interests ‚Üí Get results\n‚Ä¢ **Advanced mode** ‚Äî Full control: add places, edit, save routes\n\n**Getting started:**\n1. Choose a city and area (or \"All\", or GPS for nearby) and interests, then click \"Find points of interest\"\n2. In the results list: skip places that don't fit (‚è∏Ô∏è) and choose üìå starting point\n3. Choose route type (circular / linear) and click \"Calculate route\"\n4. Click \"Open route in Google\" to navigate!\n\n**Want more places?**\n‚Ä¢ **\"+ more\"** next to each category ‚Äî fetches more places from Google in that interest\n‚Ä¢ **\"‚ûï Manually add stop\"** ‚Äî search for a place by name as it appears on Google Maps and add it directly\n\n**Tip:** Click on a place name to open it in Google Maps"
  },
  placesListing: {
    title: 'Places list',
    content: "**How are places chosen?**\nUser-added places (from \"Advanced mode\") appear first, then Google places by rating.\n\n**Buttons next to each place:**\n‚Ä¢ ‚è∏Ô∏è ‚Äî Skip place (won't be included in route). Press ‚ñ∂Ô∏è to restore\n‚Ä¢ üìå ‚Äî Set as starting point\n\n**In advanced mode also:**\n‚Ä¢ + ‚Äî Add to my places\n‚Ä¢ ‚úèÔ∏è ‚Äî Edit details\n‚Ä¢ üóëÔ∏è ‚Äî Remove (only manually added places)\n\n**Want more places?**\n‚Ä¢ **\"+ more\"** next to each category ‚Äî fetches more Google places in that interest\n‚Ä¢ **\"‚ûï Manually add stop\"** ‚Äî search by name as it appears on Google Maps and add directly to route\n\n**Clicking the place name** opens it in Google Maps.\n\n**Starting point:**\nChoose üìå from a place in the list, or use üîç (address search) / üìç (GPS location) at the bottom.\nTo change ‚Äî choose another place or click ‚úï next to the \"Starting point\" row below.\n\n**Route calculation:**\nChoose linear (point to point) or circular (returns to start), and click \"Calculate route\".\nAfter calculation click \"Open route in Google\" to navigate."
  },
  route: {
    title: 'Route results',
    content: "**After \"Find points of interest\"** a list of places appears divided by interest.\n\n**To build a route:**\n1. Choose üìå starting point (from the list, address search, or GPS location)\n2. Click \"Calculate route\" ‚Äî the system will arrange points in the most logical order\n\n**Want to add places?**\n‚Ä¢ **\"+ more\"** next to each category ‚Äî fetches more Google places in that interest\n‚Ä¢ **\"‚ûï Add manually\"** ‚Äî search by name on Google and add directly to route\n\n**Additional actions:**\n‚Ä¢ üíæ **Save** ‚Äî saves the route for future use\n‚Ä¢ üó∫Ô∏è **Open in Google** ‚Äî shows the calculated route in Google Maps\n‚Ä¢ ‚è∏Ô∏è **Pause** places that don't fit right now"
  },
  myContent: { title: 'My content', content: "Here you can manage your places and interests.\n\n**üìç My places** ‚Äî places you added yourself. They get priority over Google places!\n\n**üè∑Ô∏è My interests** ‚Äî choose which interests appear in search. You can also create new ones." },
  myPlaces: { title: 'My places', content: "**Your added places** appear first in search results!\n\n**To add a place:** Click \"‚ûï Add place\", enter name and choose an interest.\n\n**Actions:**\n‚Ä¢ ‚úèÔ∏è Edit details\n‚Ä¢ üóëÔ∏è Delete place\n‚Ä¢ üö´ Blacklist ‚Äî a place you never want to see again\n\n**Tip:** You can also add places directly from search results by clicking the + button" },
  myInterests: { title: 'My interests', content: "**Interests** determine which types of places appear in search.\n\n**To add a new interest:** Click \"‚ûï Add interest\", choose a name and icon, and set what to search for.\n\n**To change status:** Click \"Disable\" to hide an interest from search, or \"Enable\" to restore.\n\n**To edit settings:** Click ‚úèÔ∏è next to an interest to change name, icon, or search settings.\n\n**Interest with red border** ‚Äî missing search settings and won't work until configured." },
  interestConfig: { title: 'Interest settings', content: "**Search settings for the interest**\n\n**Interest name:**\nThe name that will appear in the interests list.\n\n**Category search (Place Types):**\nGoogle categories like: temple, restaurant, museum.\nThe system finds places whose type matches one of the categories.\n\n**Text search:**\nFree text search, e.g.: \"street art\", \"rooftop bar\".\nThe system finds places Google matched to the text, filtering those whose name doesn't contain the search term.\n\n**Filter words (Blacklist):**\nWords that if they appear in a place name, it won't be included. E.g.: \"cannabis\", \"massage\" ‚Äî to filter irrelevant places.\n\n**‚ö†Ô∏è Important:** An interest without search settings won't work!" },
  searchLogic: { title: 'How does the system find places?', content: "**Finding order:**\n1. **First** ‚Äî your custom places matching the area and interest\n2. **Then** ‚Äî places from Google Places API\n\n**Google places filtering:**\n‚Ä¢ Place with name containing a filter word (blacklist) = filtered\n‚Ä¢ Place with name identical to your place = filtered (duplicate prevention)\n‚Ä¢ \"Skip permanently\" place = filtered\n‚Ä¢ Text search: only places whose name contains the full search term\n\n**Priority:**\n‚Ä¢ Places sorted by rating (highest to lowest)\n‚Ä¢ Rating is used for ordering only, not filtering\n\n**Amount:**\n‚Ä¢ Number of places split equally between your chosen interests\n‚Ä¢ Can be changed in settings\n\n**\"+ more\":**\n‚Ä¢ Adds more places from the same interest (default: 3)\n‚Ä¢ New places are marked with a dashed blue border" },
  saved: { title: 'Saved routes', content: "**What's here:**\nAll routes you saved for future use.\n\n**Saving a route:**\n‚Ä¢ Click \"üíæ Save route\" on the route screen\n‚Ä¢ Give a unique name (required)\n‚Ä¢ Add notes if you want\n\n**Actions:**\n‚Ä¢ Click a route to reload it\n‚Ä¢ üóëÔ∏è to delete a route\n\n**Tip:**\nRoutes are included in export/import in settings!" },
  settings: { title: 'Settings', content: "**System settings:**\n\n**Number of places:**\n‚Ä¢ Maximum places in a route\n‚Ä¢ Number of additional places in \"Find more\"\n\n**Import/Export:**\n‚Ä¢ **Export** ‚Äî saves everything to a JSON file\n‚Ä¢ **Import** ‚Äî adds from file (duplicates will be skipped)\n\n**Admin (for managers):**\n‚Ä¢ View access log\n‚Ä¢ Manage authorized devices\n‚Ä¢ Admin password" },
  addLocation: { title: 'Add/Edit place', content: "**Required:** Place name + at least one interest.\n\n**Additional fields (optional):**\n‚Ä¢ Area, address, notes, image\n‚Ä¢ Google Maps link\n\n**Coordinates** ‚Äî required for the place to appear in the route.\nEasiest way: click üî§ (search by name) or paste a Google Maps link and click üîó.\n\n**Buttons at bottom:**\n‚Ä¢ **Add/Update** ‚Äî saves and stays in window\n‚Ä¢ **X** at top ‚Äî closes without saving" },
  addInterest: { title: 'Add/Edit interest', content: "**How to add a new interest:**\n1. Choose a **name** and **icon** (emoji)\n2. Choose **search type:**\n   ‚Ä¢ **Category** ‚Äî by Google place type (e.g.: museum, restaurant)\n   ‚Ä¢ **Text** ‚Äî free search (e.g.: \"rooftop bar\")\n3. Click **Add** ‚Äî the interest will appear in the interests list\n\n**Filter words** ‚Äî places with these words in their name won't be included (e.g.: cannabis)." },
},

  import: {
    interests: 'Interests:',
    configs: 'Settings:',
    locations: 'Places:',
    routes: 'Routes:',
  },
} // end English

}; // end strings

console.log('[I18N] Loaded translations: he, en');

    </script>
    <!-- City Data Files -->
    <script>
// City data: Bangkok
window.BKK.cityData = window.BKK.cityData || {};
window.BKK.cityData.bangkok = {

    id: 'bangkok',
    name: '◊ë◊†◊í◊ß◊ï◊ß',
    nameEn: 'Bangkok',
    country: 'Thailand',
    icon: 'üõ∫',
    secondaryIcon: 'üçú',
    theme: { color: '#e74c3c', iconLeft: 'üèØ', iconRight: 'üêò' },
    active: true,
    distanceMultiplier: 1.2,
    center: { lat: 13.7563, lng: 100.5018 },
    allCityRadius: 15000,

    areas: [
      { id: 'sukhumvit', label: '◊°◊ï◊ß◊ï◊û◊ï◊ï◊ô◊™', labelEn: 'Sukhumvit', desc: '◊ó◊ô◊ô ◊ú◊ô◊ú◊î, ◊û◊°◊¢◊ì◊ï◊™, ◊ß◊†◊ô◊ï◊†◊ô◊ù', descEn: 'Nightlife, restaurants, malls', lat: 13.7370, lng: 100.5610, radius: 2500, size: 'large', safety: 'safe' },
      { id: 'old-town', label: '◊î◊¢◊ô◊® ◊î◊¢◊™◊ô◊ß◊î', labelEn: 'Old Town', desc: '◊û◊ß◊ì◊©◊ô◊ù, ◊ê◊®◊û◊ï◊ü ◊î◊û◊ú◊ö, ◊î◊ô◊°◊ò◊ï◊®◊ô◊î', descEn: 'Temples, Grand Palace, history', lat: 13.7500, lng: 100.4914, radius: 2000, size: 'medium', safety: 'safe' },
      { id: 'chinatown', label: '◊¶\'◊ô◊ô◊†◊î ◊ò◊ê◊ï◊ü', labelEn: 'Chinatown', desc: '◊ê◊ï◊õ◊ú ◊®◊ó◊ï◊ë, ◊©◊ï◊ï◊ß◊ô◊ù, ◊û◊ß◊ì◊©◊ô◊ù ◊°◊ô◊†◊ô◊ô◊ù', descEn: 'Street food, markets, Chinese temples', lat: 13.7408, lng: 100.5050, radius: 1500, size: 'medium', safety: 'caution' },
      { id: 'thonglor', label: '◊™◊ï◊†◊í◊ú◊ï◊®', labelEn: 'Thonglor', desc: '◊ß◊§◊î, ◊í◊ú◊®◊ô◊ï◊™, ◊ë◊ï◊ò◊ô◊ß◊ô◊ù', descEn: 'Coffee, galleries, boutiques', lat: 13.7320, lng: 100.5830, radius: 2000, size: 'medium', safety: 'safe' },
      { id: 'ari', label: '◊ê◊®◊ô', labelEn: 'Ari', desc: '◊©◊õ◊ï◊†◊™◊ô, ◊ß◊§◊î, ◊ê◊û◊†◊ï◊™ ◊®◊ó◊ï◊ë', descEn: 'Local, coffee, street art', lat: 13.7790, lng: 100.5410, radius: 2000, size: 'medium', safety: 'safe' },
      { id: 'riverside', label: '◊®◊ô◊ë◊®◊°◊ô◊ô◊ì', labelEn: 'Riverside', desc: '◊†◊î◊®, ◊û◊ß◊ì◊©◊ô◊ù, ◊©◊ï◊ï◊ß◊ô ◊ú◊ô◊ú◊î', descEn: 'River, temples, night markets', lat: 13.7270, lng: 100.4965, radius: 2000, size: 'medium', safety: 'safe' },
      { id: 'siam', label: '◊°◊ô◊ê◊ù', labelEn: 'Siam / Pratunam', desc: '◊ß◊†◊ô◊ï◊™, ◊ß◊†◊ô◊ï◊†◊ô◊ù, ◊û◊®◊õ◊ñ ◊î◊¢◊ô◊®', descEn: 'Shopping, malls, city center', lat: 13.7460, lng: 100.5340, radius: 1500, size: 'medium', safety: 'safe' },
      { id: 'chatuchak', label: '◊¶\'◊ê◊ò◊ï◊¶\'◊ê◊ß', labelEn: 'Chatuchak', desc: '◊©◊ï◊ß ◊¢◊†◊ß, ◊§◊ê◊®◊ß◊ô◊ù, ◊ê◊û◊†◊ï◊™', descEn: 'Huge market, parks, art', lat: 13.7999, lng: 100.5500, radius: 1500, size: 'medium', safety: 'safe' },
      { id: 'silom', label: '◊°◊ô◊ú◊ï◊ù', labelEn: 'Silom / Sathorn', desc: '◊¢◊°◊ß◊ô◊ù, ◊û◊ß◊ì◊©◊ô◊ù, ◊ó◊ô◊ô ◊ú◊ô◊ú◊î', descEn: 'Business, temples, nightlife', lat: 13.7262, lng: 100.5235, radius: 1800, size: 'medium', safety: 'safe' },
      { id: 'ratchada', label: '◊®◊ê◊¶\'◊ê◊ì◊î', labelEn: 'Ratchada', desc: '◊©◊ï◊ï◊ß◊ô ◊ú◊ô◊ú◊î, ◊ê◊ï◊õ◊ú, ◊ë◊ô◊ì◊ï◊®', descEn: 'Night markets, food, entertainment', lat: 13.7650, lng: 100.5730, radius: 1500, size: 'medium', safety: 'safe' },
      { id: 'onnut', label: '◊ê◊ï◊ü ◊†◊ê◊ò', labelEn: 'On Nut', desc: '◊û◊ß◊ï◊û◊ô, ◊ê◊ï◊õ◊ú ◊ñ◊ï◊ú, ◊©◊ï◊ï◊ß◊ô◊ù', descEn: 'Local, cheap food, markets', lat: 13.7060, lng: 100.6010, radius: 1800, size: 'medium', safety: 'safe' },
      { id: 'bangrak', label: '◊ë◊ê◊†◊í ◊®◊ê◊ß', labelEn: 'Bang Rak', desc: '◊ê◊û◊†◊ï◊™, ◊í◊ú◊®◊ô◊ï◊™, ◊ê◊ï◊õ◊ú', descEn: 'Art, galleries, food', lat: 13.7280, lng: 100.5130, radius: 1000, size: 'small', safety: 'safe' }
    ],

    interests: [
      { id: 'temples', label: '◊û◊ß◊ì◊©◊ô◊ù', labelEn: 'Temples', icon: 'üõï' },
      { id: 'food', label: '◊ê◊ï◊õ◊ú', labelEn: 'Food', icon: 'üçú' },
      { id: 'graffiti', label: '◊í◊®◊§◊ô◊ò◊ô', labelEn: 'Street Art', icon: 'üé®' },
      { id: 'artisans', label: '◊û◊ú◊ê◊õ◊î', labelEn: 'Crafts', icon: 'üî®' },
      { id: 'galleries', label: '◊í◊ú◊®◊ô◊ï◊™', labelEn: 'Galleries', icon: 'üñºÔ∏è' },
      { id: 'architecture', label: '◊ê◊®◊õ◊ô◊ò◊ß◊ò◊ï◊®◊î', labelEn: 'Architecture', icon: 'üèõÔ∏è' },
      { id: 'canals', label: '◊™◊¢◊ú◊ï◊™', labelEn: 'Canals', icon: 'üö§' },
      { id: 'cafes', label: '◊ß◊§◊î', labelEn: 'Coffee', icon: '‚òï' },
      { id: 'markets', label: '◊©◊ï◊ï◊ß◊ô◊ù', labelEn: 'Markets', icon: 'üè™' },
      { id: 'nightlife', label: '◊ú◊ô◊ú◊î', labelEn: 'Nightlife', icon: 'üåÉ' },
      { id: 'parks', label: '◊§◊ê◊®◊ß◊ô◊ù', labelEn: 'Parks', icon: 'üå≥' },
      { id: 'rooftop', label: '◊í◊í◊ï◊™', labelEn: 'Rooftops', icon: 'üåÜ' },
      { id: 'entertainment', label: '◊ë◊ô◊ì◊ï◊®', labelEn: 'Entertainment', icon: 'üé≠' }
    ],

    interestToGooglePlaces: {
      temples: ['hindu_temple', 'church', 'mosque', 'synagogue'],
      food: ['restaurant', 'meal_takeaway'],
      graffiti: ['art_gallery'],
      artisans: ['store', 'art_gallery'],
      galleries: ['art_gallery', 'museum'],
      architecture: ['historical_landmark'],
      canals: ['boat_tour_agency', 'marina'],
      cafes: ['cafe', 'coffee_shop'],
      markets: ['market', 'shopping_mall'],
      nightlife: ['bar', 'night_club'],
      parks: ['park', 'national_park'],
      rooftop: ['bar', 'restaurant'],
      entertainment: ['movie_theater', 'amusement_park', 'performing_arts_theater']
    },

    textSearchInterests: { graffiti: 'street art' },

    uncoveredInterests: [
      { id: 'massage_spa', icon: 'üíÜ', label: '◊¢◊ô◊°◊ï◊ô ◊ï◊°◊§◊ê', labelEn: 'Massage & Spa', name: '◊¢◊ô◊°◊ï◊ô ◊ï◊°◊§◊ê', examples: 'Thai massage, wellness centers, spa' },
      { id: 'fitness', icon: 'üèãÔ∏è', label: '◊õ◊ï◊©◊® ◊ï◊°◊§◊ï◊®◊ò', labelEn: 'Fitness & Sports', name: '◊õ◊ï◊©◊® ◊ï◊°◊§◊ï◊®◊ò', examples: 'Gyms, yoga studios, Muay Thai, fitness' },
      { id: 'shopping_special', icon: 'üõçÔ∏è', label: '◊ß◊†◊ô◊ï◊™ ◊û◊ô◊ï◊ó◊ì◊ï◊™', labelEn: 'Special Shopping', name: '◊ß◊†◊ô◊ï◊™ ◊û◊ô◊ï◊ó◊ì◊ï◊™', examples: 'Boutiques, jewelry, fashion stores' },
      { id: 'learning', icon: 'üéì', label: '◊ú◊ô◊û◊ï◊ì ◊ï◊ó◊ï◊ï◊ô◊ï◊™', labelEn: 'Learning & Experiences', name: '◊ú◊ô◊û◊ï◊ì ◊ï◊ó◊ï◊ï◊ô◊ï◊™', examples: 'Cooking classes, meditation, workshops' },
      { id: 'health', icon: 'üè•', label: '◊ë◊®◊ô◊ê◊ï◊™ ◊ï◊®◊§◊ï◊ê◊î', labelEn: 'Health & Medical', name: '◊ë◊®◊ô◊ê◊ï◊™ ◊ï◊®◊§◊ï◊ê◊î', examples: 'Clinics, pharmacies, health services' },
      { id: 'accommodation', icon: 'üè®', label: '◊ê◊ô◊®◊ï◊ó', labelEn: 'Accommodation', name: '◊ê◊ô◊®◊ï◊ó', examples: 'Hotels, hostels, guesthouses' },
      { id: 'transport', icon: 'üöó', label: '◊™◊ó◊ë◊ï◊®◊î', labelEn: 'Transport', name: '◊™◊ó◊ë◊ï◊®◊î', examples: 'Car rental, bike rental, transportation' },
      { id: 'business', icon: 'üíº', label: '◊¢◊°◊ß◊ô◊ù', labelEn: 'Business', name: '◊¢◊°◊ß◊ô◊ù', examples: 'Coworking, offices, business centers' }
    ],

    interestTooltips: {
      temples: '◊û◊ß◊ì◊©◊ô◊ù ◊ë◊ï◊ì◊î◊ô◊°◊ò◊ô◊ô◊ù ◊ï◊î◊ô◊†◊ì◊ô◊ô◊ù', food: '◊û◊°◊¢◊ì◊ï◊™ ◊ï◊ê◊ï◊õ◊ú ◊®◊ó◊ï◊ë', graffiti: '◊ê◊ï◊û◊†◊ï◊™ ◊®◊ó◊ï◊ë ◊ï◊í◊®◊§◊ô◊ò◊ô',
      artisans: '◊ë◊™◊ô ◊û◊ú◊ê◊õ◊î ◊ï◊ê◊ï◊û◊†◊ô◊ù', galleries: '◊í◊ú◊®◊ô◊ï◊™ ◊ï◊û◊ï◊ñ◊ô◊ê◊ï◊†◊ô◊ù', architecture: '◊ë◊†◊ô◊ô◊†◊ô◊ù ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊ù',
      canals: '◊©◊ô◊ô◊ò◊ô◊ù ◊ë◊™◊¢◊ú◊ï◊™ ◊ï◊ë◊†◊î◊®', cafes: '◊ë◊™◊ô ◊ß◊§◊î', markets: '◊©◊ï◊ï◊ß◊ô◊ù ◊ï◊ë◊ñ◊ê◊®◊ô◊ù',
      nightlife: '◊ë◊®◊ô◊ù ◊ï◊û◊ï◊¢◊ì◊ï◊†◊ô ◊ú◊ô◊ú◊î', parks: '◊í◊†◊ô◊ù ◊ï◊§◊ê◊®◊ß◊ô◊ù', rooftop: '◊ë◊®◊ô◊ù ◊ï◊û◊°◊¢◊ì◊ï◊™ ◊¢◊ú ◊í◊í◊ï◊™',
      entertainment: '◊ß◊ï◊ú◊†◊ï◊¢, ◊™◊ô◊ê◊ò◊®◊ï◊ü, ◊û◊ï◊§◊¢◊ô◊ù'
    }
};

// City data: Gush Dan
window.BKK.cityData = window.BKK.cityData || {};
window.BKK.cityData.gushdan = {
  "id": "gushdan",
  "name": "◊í◊ï◊© ◊ì◊ü",
  "nameEn": "Gush Dan",
  "country": "Israel",
  "icon": "üèñÔ∏è",
  "secondaryIcon": "‚òÄÔ∏è",
  "theme": { "color": "#2980b9", "iconLeft": "üèñÔ∏è", "iconRight": "üåÜ" },
  "active": true,
  "distanceMultiplier": 1.2,
  "center": {
    "lat": 32.0802,
    "lng": 34.8871
  },
  "allCityRadius": 15000,
  "areas": [
    {
      "id": "tlv-north",
      "label": "◊¶◊§◊ï◊ü ◊™◊ú ◊ê◊ë◊ô◊ë",
      "labelEn": "North Tel Aviv",
      "desc": "◊î◊†◊û◊ú, ◊§◊ê◊®◊ß ◊î◊ô◊®◊ß◊ï◊ü, ◊ë◊ñ◊ú",
      "descEn": "Port, Yarkon Park, Basel",
      "lat": 32.1117,
      "lng": 34.7971,
      "radius": 3000,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "tlv-center",
      "label": "◊û◊®◊õ◊ñ ◊™◊ú ◊ê◊ë◊ô◊ë",
      "labelEn": "Central Tel Aviv",
      "desc": "◊®◊ï◊ò◊©◊ô◊ú◊ì, ◊ì◊ô◊ñ◊†◊í◊ï◊£, ◊î◊ë◊ô◊û◊î",
      "descEn": "Rothschild, Dizengoff, Habima",
      "lat": 32.0677,
      "lng": 34.7762,
      "radius": 2000,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "tlv-south",
      "label": "◊ì◊®◊ï◊ù ◊™\"◊ê ◊ï◊ô◊§◊ï",
      "labelEn": "South TLV & Jaffa",
      "desc": "◊©◊ï◊ß ◊î◊§◊©◊§◊©◊ô◊ù, ◊†◊û◊ú ◊ô◊§◊ï, ◊§◊ú◊ï◊®◊†◊ò◊ô◊ü",
      "descEn": "Flea market, Jaffa port, Florentin",
      "lat": 32.0523,
      "lng": 34.7621,
      "radius": 2200,
      "size": "large",
      "safety": "caution"
    },
    {
      "id": "holon",
      "label": "◊ó◊ï◊ú◊ï◊ü",
      "labelEn": "Holon",
      "desc": "◊û◊ï◊ñ◊ô◊ê◊ï◊ü ◊î◊ô◊ú◊ì◊ô◊ù, ◊¢◊ô◊¶◊ï◊ë, ◊§◊ê◊®◊ß◊ô◊ù",
      "descEn": "Children museum, design, parks",
      "lat": 32.0148,
      "lng": 34.7872,
      "radius": 2500,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "bat-yam",
      "label": "◊ë◊™ ◊ô◊ù",
      "labelEn": "Bat Yam",
      "desc": "◊ó◊ï◊£, ◊ò◊ô◊ô◊ú◊™, ◊ê◊ï◊õ◊ú",
      "descEn": "Beach, boardwalk, food",
      "lat": 32.0162,
      "lng": 34.741,
      "radius": 2200,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "petah-tikva",
      "label": "◊§◊™◊ó ◊™◊ß◊ï◊ï◊î",
      "labelEn": "Petah Tikva",
      "desc": "◊û◊°◊¢◊ì◊ï◊™, ◊§◊ê◊®◊ß◊ô◊ù, ◊ß◊†◊ô◊ï◊†◊ô◊ù",
      "descEn": "Restaurants, parks, malls",
      "lat": 32.0994,
      "lng": 34.8885,
      "radius": 4100,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "herzliya",
      "label": "◊î◊®◊¶◊ú◊ô◊î",
      "labelEn": "Herzliya",
      "desc": "◊û◊®◊ô◊†◊î, ◊ó◊ï◊§◊ô◊ù, ◊î◊ô◊ô◊ò◊ß",
      "descEn": "Marina, beaches, hi-tech",
      "lat": 32.1646,
      "lng": 34.8325,
      "radius": 3700,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "ramat-gan",
      "label": "◊®◊û◊™ ◊í◊ü ◊ï◊í◊ë◊¢◊™◊ô◊ô◊ù",
      "labelEn": "Ramat Gan & Givatayim",
      "desc": "◊î◊ë◊ï◊®◊°◊î, ◊°◊§◊ê◊®◊ô, ◊§◊ê◊®◊ß◊ô◊ù",
      "lat": 32.0558,
      "lng": 34.8129,
      "radius": 2500,
      "size": "large",
      "safety": "safe"
    },
    {
      "id": "bnei-brak",
      "label": "◊ë◊†◊ô ◊ë◊®◊ß",
      "labelEn": "Bnei Brak",
      "desc": "◊©◊ï◊ï◊ß◊ô◊ù, ◊ê◊ï◊õ◊ú, ◊™◊®◊ë◊ï◊™ ◊ó◊®◊ì◊ô◊™",
      "descEn": "Markets, food, ultra-orthodox culture",
      "lat": 32.0837,
      "lng": 34.8332,
      "radius": 1100,
      "size": "medium",
      "safety": "safe"
    }
  ],
  "interests": [
    {
      "id": "food",
      "label": "◊ê◊ï◊õ◊ú",
      "labelEn": "Food",
      "icon": "üçΩÔ∏è"
    },
    {
      "id": "cafes",
      "label": "◊ß◊§◊î",
      "labelEn": "Coffee",
      "icon": "‚òï"
    },
    {
      "id": "beaches",
      "label": "◊ó◊ï◊§◊ô◊ù",
      "labelEn": "Beaches",
      "icon": "üèñÔ∏è"
    },
    {
      "id": "graffiti",
      "label": "◊í◊®◊§◊ô◊ò◊ô",
      "labelEn": "Street Art",
      "icon": "üé®"
    },
    {
      "id": "galleries",
      "label": "◊í◊ú◊®◊ô◊ï◊™",
      "labelEn": "Galleries",
      "icon": "üñºÔ∏è"
    },
    {
      "id": "architecture",
      "label": "◊ë◊ê◊ï◊î◊ê◊ï◊°",
      "labelEn": "Bauhaus",
      "icon": "üèõÔ∏è"
    },
    {
      "id": "markets",
      "label": "◊©◊ï◊ï◊ß◊ô◊ù",
      "labelEn": "Markets",
      "icon": "üè™"
    },
    {
      "id": "nightlife",
      "label": "◊ú◊ô◊ú◊î",
      "labelEn": "Nightlife",
      "icon": "üåÉ"
    },
    {
      "id": "parks",
      "label": "◊§◊ê◊®◊ß◊ô◊ù",
      "labelEn": "Parks",
      "icon": "üå≥"
    },
    {
      "id": "shopping",
      "label": "◊ß◊†◊ô◊ï◊™",
      "labelEn": "Shopping",
      "icon": "üõçÔ∏è"
    },
    {
      "id": "culture",
      "label": "◊™◊®◊ë◊ï◊™",
      "labelEn": "Culture",
      "icon": "üé≠"
    },
    {
      "id": "history",
      "label": "◊î◊ô◊°◊ò◊ï◊®◊ô◊î",
      "labelEn": "History",
      "icon": "üèöÔ∏è"
    }
  ],
  "interestToGooglePlaces": {
    "food": [
      "restaurant",
      "meal_takeaway"
    ],
    "cafes": [
      "cafe",
      "coffee_shop"
    ],
    "beaches": [
      "beach"
    ],
    "graffiti": [
      "art_gallery"
    ],
    "galleries": [
      "art_gallery",
      "museum"
    ],
    "architecture": [
      "historical_landmark"
    ],
    "markets": [
      "market",
      "shopping_mall"
    ],
    "nightlife": [
      "bar",
      "night_club"
    ],
    "parks": [
      "park"
    ],
    "shopping": [
      "shopping_mall",
      "store"
    ],
    "culture": [
      "performing_arts_theater",
      "cultural_center",
      "museum"
    ],
    "history": [
      "historical_landmark",
      "museum"
    ]
  },
  "textSearchInterests": {
    "graffiti": "street art",
    "architecture": "bauhaus building",
    "beaches": "beach"
  },
  "uncoveredInterests": [
    {
      "id": "fitness",
      "icon": "üèãÔ∏è",
      "label": "◊õ◊ï◊©◊® ◊ï◊°◊§◊ï◊®◊ò",
      "labelEn": "Fitness & Sports",
      "name": "◊õ◊ï◊©◊® ◊ï◊°◊§◊ï◊®◊ò",
      "examples": "Gyms, yoga, pilates, cycling"
    },
    {
      "id": "wellness",
      "icon": "üíÜ",
      "label": "◊°◊§◊ê ◊ï◊®◊ï◊ï◊ó◊î",
      "labelEn": "Spa & Wellness",
      "name": "◊°◊§◊ê ◊ï◊®◊ï◊ï◊ó◊î",
      "examples": "Spa, massage, wellness"
    },
    {
      "id": "coworking",
      "icon": "üíª",
      "label": "◊¢◊ë◊ï◊ì◊î",
      "labelEn": "Coworking",
      "name": "◊ó◊ú◊ú◊ô ◊¢◊ë◊ï◊ì◊î",
      "examples": "Coworking, cafes with wifi"
    }
  ],
  "interestTooltips": {
    "food": "◊û◊°◊¢◊ì◊ï◊™ ◊ï◊ê◊ï◊õ◊ú ◊®◊ó◊ï◊ë",
    "cafes": "◊ë◊™◊ô ◊ß◊§◊î",
    "beaches": "◊ó◊ï◊§◊ô◊ù ◊ï◊ò◊ô◊ô◊ú◊ï◊™",
    "graffiti": "◊ê◊ï◊û◊†◊ï◊™ ◊®◊ó◊ï◊ë ◊ï◊í◊®◊§◊ô◊ò◊ô",
    "galleries": "◊í◊ú◊®◊ô◊ï◊™ ◊ï◊û◊ï◊ñ◊ô◊ê◊ï◊†◊ô◊ù",
    "architecture": "◊û◊ë◊†◊ô ◊ë◊ê◊ï◊î◊ê◊ï◊° ◊ï◊ê◊ì◊®◊ô◊õ◊ú◊ï◊™",
    "markets": "◊©◊ï◊ï◊ß◊ô◊ù ◊ï◊ë◊ñ◊ê◊®◊ô◊ù",
    "nightlife": "◊ë◊®◊ô◊ù ◊ï◊û◊ï◊¢◊ì◊ï◊†◊ô◊ù",
    "parks": "◊§◊ê◊®◊ß◊ô◊ù ◊ï◊í◊†◊ô◊ù",
    "shopping": "◊ß◊†◊ô◊ï◊†◊ô◊ù ◊ï◊ó◊†◊ï◊ô◊ï◊™",
    "culture": "◊™◊ô◊ê◊ò◊®◊ï◊ü, ◊û◊ï◊ñ◊ô◊ß◊î, ◊û◊ï◊§◊¢◊ô◊ù",
    "history": "◊ê◊™◊®◊ô◊ù ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊ù ◊ï◊û◊ï◊ñ◊ô◊ê◊ï◊†◊ô◊ù"
  }
};

// City data: Malaga
window.BKK.cityData = window.BKK.cityData || {};
window.BKK.cityData.malaga = {
  "id": "malaga",
  "name": "◊û◊ú◊í◊î",
  "nameEn": "Malaga",
  "country": "Spain",
  "icon": "‚òÄÔ∏è",
  "secondaryIcon": "‚òÄÔ∏è",
  "active": false,
  "distanceMultiplier": 1.2,
  "center": {
    "lat": 36.7178196,
    "lng": -4.4255569999999995
  },
  "allCityRadius": 12185,
  "areas": [
    {
      "id": "centro",
      "label": "Centro",
      "labelEn": "Centro",
      "desc": "Centro, Malaga, Spain",
      "descEn": "Centro, Malaga, Spain",
      "lat": 36.7213,
      "lng": -4.423,
      "radius": 2500,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "este",
      "label": "Este",
      "labelEn": "Este",
      "desc": "",
      "descEn": "",
      "lat": 36.7845,
      "lng": -4.365,
      "radius": 7000,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "ciudad_jard_n",
      "label": "Ciudad Jardin",
      "labelEn": "Ciudad Jardin",
      "desc": "",
      "descEn": "",
      "lat": 36.7653,
      "lng": -4.4165,
      "radius": 3800,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "bail_n_miraflores",
      "label": "Bailen-Miraflores",
      "labelEn": "Bailen-Miraflores",
      "desc": "",
      "descEn": "",
      "lat": 36.7226,
      "lng": -4.4402,
      "radius": 1000,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "palma_palmilla",
      "label": "Palma-Palmilla",
      "labelEn": "Palma-Palmilla",
      "desc": "",
      "descEn": "",
      "lat": 36.7554,
      "lng": -4.4618,
      "radius": 2600,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "cruz_de_humilladero",
      "label": "Cruz de Humilladero",
      "labelEn": "Cruz de Humilladero",
      "desc": "",
      "descEn": "",
      "lat": 36.7144,
      "lng": -4.4584,
      "radius": 2000,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "carretera_de_c_diz",
      "label": "Carretera de Cadiz",
      "labelEn": "Carretera de Cadiz",
      "desc": "",
      "descEn": "",
      "lat": 36.6866,
      "lng": -4.4673,
      "radius": 2500,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "churriana",
      "label": "Churriana",
      "labelEn": "Churriana",
      "desc": "",
      "descEn": "",
      "lat": 36.6359,
      "lng": -4.5525,
      "radius": 6700,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "campanillas",
      "label": "Campanillas",
      "labelEn": "Campanillas",
      "desc": "",
      "descEn": "",
      "lat": 36.7207,
      "lng": -4.5003,
      "radius": 3600,
      "size": "medium",
      "safety": "safe"
    },
    {
      "id": "puerto_de_la_torre",
      "label": "Puerto de la Torre",
      "labelEn": "Puerto de la Torre",
      "desc": "",
      "descEn": "",
      "lat": 36.7433,
      "lng": -4.5285,
      "radius": 4800,
      "size": "medium",
      "safety": "safe"
    }
  ],
  "interests": [
    {
      "id": "food",
      "label": "◊ê◊ï◊õ◊ú",
      "labelEn": "Food",
      "icon": "üçú"
    },
    {
      "id": "cafes",
      "label": "◊ß◊§◊î",
      "labelEn": "Coffee",
      "icon": "‚òï"
    },
    {
      "id": "culture",
      "label": "◊™◊®◊ë◊ï◊™",
      "labelEn": "Culture",
      "icon": "üé≠"
    },
    {
      "id": "history",
      "label": "◊î◊ô◊°◊ò◊ï◊®◊ô◊î",
      "labelEn": "History",
      "icon": "üèõÔ∏è"
    },
    {
      "id": "parks",
      "label": "◊§◊ê◊®◊ß◊ô◊ù",
      "labelEn": "Parks",
      "icon": "üå≥"
    },
    {
      "id": "shopping",
      "label": "◊ß◊†◊ô◊ï◊™",
      "labelEn": "Shopping",
      "icon": "üõçÔ∏è"
    },
    {
      "id": "nightlife",
      "label": "◊ú◊ô◊ú◊î",
      "labelEn": "Nightlife",
      "icon": "üåÉ"
    },
    {
      "id": "galleries",
      "label": "◊í◊ú◊®◊ô◊ï◊™",
      "labelEn": "Galleries",
      "icon": "üñºÔ∏è"
    },
    {
      "id": "markets",
      "label": "◊©◊ï◊ï◊ß◊ô◊ù",
      "labelEn": "Markets",
      "icon": "üè™"
    },
    {
      "id": "graffiti",
      "label": "◊í◊®◊§◊ô◊ò◊ô",
      "labelEn": "Street Art",
      "icon": "üé®"
    },
    {
      "id": "beaches",
      "label": "◊ó◊ï◊§◊ô◊ù",
      "labelEn": "Beaches",
      "icon": "üèñÔ∏è"
    },
    {
      "id": "architecture",
      "label": "◊ê◊®◊õ◊ô◊ò◊ß◊ò◊ï◊®◊î",
      "labelEn": "Architecture",
      "icon": "üèóÔ∏è"
    }
  ],
  "interestToGooglePlaces": {
    "food": [
      "restaurant",
      "meal_takeaway"
    ],
    "cafes": [
      "cafe",
      "coffee_shop"
    ],
    "culture": [
      "performing_arts_theater",
      "cultural_center",
      "museum"
    ],
    "history": [
      "historical_landmark",
      "museum"
    ],
    "parks": [
      "park",
      "national_park"
    ],
    "shopping": [
      "shopping_mall",
      "store"
    ],
    "nightlife": [
      "bar",
      "night_club"
    ],
    "galleries": [
      "art_gallery",
      "museum"
    ],
    "markets": [
      "market"
    ],
    "graffiti": [
      "art_gallery"
    ],
    "beaches": [
      "beach"
    ],
    "architecture": [
      "historical_landmark"
    ]
  },
  "textSearchInterests": {
    "graffiti": "street art"
  },
  "uncoveredInterests": [],
  "interestTooltips": {},
  "theme": {
    "color": "#c60b1e",
    "iconLeft": "üèñÔ∏è",
    "iconRight": "üåû"
  }
};

// City data: Singapore
window.BKK.cityData = window.BKK.cityData || {};
window.BKK.cityData.singapore = {

    id: 'singapore',
    name: '◊°◊ô◊†◊í◊§◊ï◊®',
    nameEn: 'Singapore',
    country: 'Singapore',
    icon: 'ü¶Å',
    secondaryIcon: 'üå¥',
    theme: { color: '#c0392b', iconLeft: 'ü¶Å', iconRight: 'üå∫' },
    active: true,
    distanceMultiplier: 1.2,
    center: { lat: 1.3521, lng: 103.8198 },
    allCityRadius: 15000,

    areas: [
      { id: 'marina-bay', label: '◊û◊®◊ô◊†◊î ◊ë◊ô◊ô', labelEn: 'Marina Bay', desc: '◊û◊í◊ì◊ú◊ô◊ù, ◊í◊†◊ô◊ù, ◊ê◊ò◊®◊ß◊¶◊ô◊ï◊™', lat: 1.2816, lng: 103.8636, radius: 1500, size: 'medium', safety: 'safe' },
      { id: 'chinatown-sg', label: '◊¶\'◊ô◊ô◊†◊î ◊ò◊ê◊ï◊ü', labelEn: 'Chinatown', desc: '◊û◊ß◊ì◊©◊ô◊ù, ◊ê◊ï◊õ◊ú ◊®◊ó◊ï◊ë, ◊©◊ï◊ï◊ß◊ô◊ù', lat: 1.2833, lng: 103.8440, radius: 1200, size: 'small', safety: 'safe' },
      { id: 'little-india', label: '◊ú◊ô◊ò◊ú ◊ê◊ô◊†◊ì◊ô◊î', labelEn: 'Little India', desc: '◊¶◊ë◊¢◊ï◊†◊ô, ◊™◊ë◊ú◊ô◊†◊ô◊ù, ◊û◊ß◊ì◊©◊ô◊ù ◊î◊ô◊†◊ì◊ô◊ô◊ù', lat: 1.3066, lng: 103.8518, radius: 1200, size: 'small', safety: 'safe' },
      { id: 'kampong-glam', label: '◊ß◊ê◊û◊§◊ï◊†◊í ◊í◊ú◊ê◊ù', labelEn: 'Kampong Glam', desc: '◊¢◊®◊ë◊ô, ◊í◊®◊§◊ô◊ò◊ô, ◊î◊ô◊§◊°◊ò◊®◊ô◊ù', lat: 1.3015, lng: 103.8596, radius: 1000, size: 'small', safety: 'safe' },
      { id: 'orchard', label: '◊ê◊ï◊®◊¶\'◊®◊ì', labelEn: 'Orchard Road', desc: '◊ß◊†◊ô◊ï◊™, ◊ß◊†◊ô◊ï◊†◊ô◊ù, ◊ô◊ï◊ß◊®◊î', descEn: 'Shopping, malls, luxury', lat: 1.3048, lng: 103.8318, radius: 1500, size: 'medium', safety: 'safe' },
      { id: 'sentosa', label: '◊°◊†◊ò◊ï◊°◊î', labelEn: 'Sentosa', desc: '◊ó◊ï◊§◊ô◊ù, ◊ô◊ï◊†◊ô◊ë◊®◊°◊ú, ◊ë◊ô◊ì◊ï◊®', descEn: 'Beaches, Universal, entertainment', lat: 1.2494, lng: 103.8303, radius: 2000, size: 'large', safety: 'safe' },
      { id: 'tiong-bahru', label: '◊ò◊ô◊ï◊†◊í ◊ë◊ê◊®◊ï', labelEn: 'Tiong Bahru', desc: '◊ß◊§◊î, ◊í◊®◊§◊ô◊ò◊ô, ◊ê◊®◊ò ◊ì◊ß◊ï', descEn: 'Coffee, graffiti, art deco', lat: 1.2847, lng: 103.8310, radius: 1000, size: 'small', safety: 'safe' },
      { id: 'holland-v', label: '◊î◊ï◊ú◊†◊ì ◊ï◊ô◊ú◊ê◊í\'', labelEn: 'Holland Village', desc: '◊©◊õ◊ï◊†◊™◊ô, ◊ë◊®◊ô◊ù, ◊ß◊§◊î', lat: 1.3112, lng: 103.7958, radius: 1200, size: 'small', safety: 'safe' },
      { id: 'clarke-quay', label: '◊ß◊ú◊ê◊®◊ß ◊ß◊ô', labelEn: 'Clarke Quay', desc: '◊†◊î◊®, ◊ë◊®◊ô◊ù, ◊ó◊ô◊ô ◊ú◊ô◊ú◊î', lat: 1.2906, lng: 103.8465, radius: 1000, size: 'small', safety: 'safe' },
      { id: 'bugis', label: '◊ë◊ï◊í◊ô◊°', labelEn: 'Bugis / Bras Basah', desc: '◊™◊®◊ë◊ï◊™, ◊û◊ï◊ñ◊ô◊ê◊ï◊†◊ô◊ù, ◊©◊ï◊ï◊ß◊ô◊ù', lat: 1.2993, lng: 103.8558, radius: 1200, size: 'medium', safety: 'safe' }
    ],

    interests: [
      { id: 'food', label: '◊ê◊ï◊õ◊ú', labelEn: 'Food', icon: 'üçú' },
      { id: 'cafes', label: '◊ß◊§◊î', labelEn: 'Coffee', icon: '‚òï' },
      { id: 'hawkers', label: '◊î◊ï◊ß◊®◊°', labelEn: 'Hawkers', icon: 'ü•ò' },
      { id: 'temples', label: '◊û◊ß◊ì◊©◊ô◊ù', labelEn: 'Temples', icon: 'üõï' },
      { id: 'gardens', label: '◊í◊†◊ô◊ù', labelEn: 'Gardens', icon: 'üå∫' },
      { id: 'architecture', label: '◊ê◊®◊õ◊ô◊ò◊ß◊ò◊ï◊®◊î', labelEn: 'Architecture', icon: 'üèõÔ∏è' },
      { id: 'graffiti', label: '◊í◊®◊§◊ô◊ò◊ô', labelEn: 'Street Art', icon: 'üé®' },
      { id: 'galleries', label: '◊í◊ú◊®◊ô◊ï◊™', labelEn: 'Galleries', icon: 'üñºÔ∏è' },
      { id: 'markets', label: '◊©◊ï◊ï◊ß◊ô◊ù', labelEn: 'Markets', icon: 'üè™' },
      { id: 'nightlife', label: '◊ú◊ô◊ú◊î', labelEn: 'Nightlife', icon: 'üåÉ' },
      { id: 'shopping', label: '◊ß◊†◊ô◊ï◊™', labelEn: 'Shopping', icon: 'üõçÔ∏è' },
      { id: 'rooftop', label: '◊í◊í◊ï◊™', labelEn: 'Rooftops', icon: 'üåÜ' }
    ],

    interestToGooglePlaces: {
      food: ['restaurant', 'meal_takeaway'], cafes: ['cafe', 'coffee_shop'],
      hawkers: ['restaurant'], temples: ['hindu_temple', 'church', 'mosque', 'synagogue'],
      gardens: ['park', 'botanical_garden'], architecture: ['historical_landmark'],
      graffiti: ['art_gallery'], galleries: ['art_gallery', 'museum'],
      markets: ['market', 'shopping_mall'], nightlife: ['bar', 'night_club'],
      shopping: ['shopping_mall', 'store'], rooftop: ['bar', 'restaurant']
    },

    textSearchInterests: { graffiti: 'street art', hawkers: 'hawker centre', gardens: 'garden' },

    uncoveredInterests: [
      { id: 'wellness', icon: 'üíÜ', label: '◊°◊§◊ê ◊ï◊®◊ï◊ï◊ó◊î', labelEn: 'Spa & Wellness', name: '◊°◊§◊ê ◊ï◊®◊ï◊ï◊ó◊î', examples: 'Spa, massage, wellness' },
      { id: 'adventure', icon: 'üé¢', label: '◊ê◊ò◊®◊ß◊¶◊ô◊ï◊™', labelEn: 'Attractions', name: '◊ê◊ò◊®◊ß◊¶◊ô◊ï◊™', examples: 'Theme parks, zoo, aquarium' }
    ],

    interestTooltips: {
      food: '◊û◊°◊¢◊ì◊ï◊™ ◊û◊õ◊ú ◊î◊¢◊ï◊ú◊ù', cafes: '◊ë◊™◊ô ◊ß◊§◊î', hawkers: '◊û◊®◊õ◊ñ◊ô ◊î◊ï◊ß◊®◊° ‚Äî ◊ê◊ï◊õ◊ú ◊®◊ó◊ï◊ë ◊°◊ô◊†◊í◊§◊ï◊®◊ô',
      temples: '◊û◊ß◊ì◊©◊ô◊ù ◊ë◊ï◊ì◊î◊ô◊°◊ò◊ô◊ô◊ù, ◊î◊ô◊†◊ì◊ô◊ô◊ù, ◊û◊°◊í◊ì◊ô◊ù', gardens: '◊í◊†◊ô◊ù ◊ë◊ï◊ò◊†◊ô◊ô◊ù ◊ï◊§◊ê◊®◊ß◊ô◊ù',
      architecture: '◊ß◊ï◊ú◊ï◊†◊ô◊ê◊ú◊ô, ◊©◊ï◊§◊î◊ê◊ï◊°◊ô◊ù, ◊û◊ï◊ì◊®◊†◊ô', graffiti: '◊ê◊ï◊û◊†◊ï◊™ ◊®◊ó◊ï◊ë',
      galleries: '◊í◊ú◊®◊ô◊ï◊™ ◊ï◊û◊ï◊ñ◊ô◊ê◊ï◊†◊ô◊ù', markets: '◊©◊ï◊ï◊ß◊ô◊ù ◊ï◊ë◊ñ◊ê◊®◊ô◊ù',
      nightlife: '◊ë◊®◊ô◊ù ◊ï◊û◊ï◊¢◊ì◊ï◊†◊ô◊ù', shopping: '◊ß◊†◊ô◊ï◊†◊ô◊ù ◊ï◊ó◊†◊ï◊ô◊ï◊™', rooftop: '◊ë◊®◊ô◊ù ◊ï◊û◊°◊¢◊ì◊ï◊™ ◊¢◊ú ◊í◊í◊ï◊™'
    }
};

    </script>
    <!-- Config -->
    <script>
// ============================================================================
// City Explorer - Configuration & Constants
// Copyright ¬© 2026 Eitan Fisher. All Rights Reserved.
// ============================================================================

window.BKK = window.BKK || {};

// App Version
window.BKK.VERSION = '3.0.0';

// Tile URL - English labels for all cities
window.BKK.getTileUrl = function() {
  return 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
};

// App Name
window.BKK.APP_NAME = 'City Explorer';

// Firebase Configuration
window.BKK.firebaseConfig = {
  apiKey: "AIzaSyCAH_2fk_plk6Dg5dlCCfaRWKL3Nmc6V6g",
  authDomain: "bangkok-explorer.firebaseapp.com",
  databaseURL: "https://bangkok-explorer-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "bangkok-explorer",
  storageBucket: "bangkok-explorer.firebasestorage.app",
  messagingSenderId: "139083217994",
  appId: "1:139083217994:web:48fc6a45028c91d177bab3",
  measurementId: "G-QVGD0RKEHP"
};

// Google Places API Configuration
window.BKK.GOOGLE_PLACES_API_KEY = 'AIzaSyD0F0TYKuWXVqibhj-sH-DaElDtLL8hMwM';
window.BKK.GOOGLE_PLACES_API_URL = 'https://places.googleapis.com/v1/places:searchNearby';
window.BKK.GOOGLE_PLACES_TEXT_SEARCH_URL = 'https://places.googleapis.com/v1/places:searchText';

// ============================================================================
// CITIES REGISTRY (lightweight metadata only - full data loaded dynamically)
// ============================================================================

window.BKK.cityRegistry = {
  bangkok: { id: 'bangkok', name: '◊ë◊†◊í◊ß◊ï◊ß', nameEn: 'Bangkok', country: 'Thailand', icon: 'üõ∫', secondaryIcon: 'üçú', file: 'city-bangkok.js' },
  gushdan: { id: 'gushdan', name: '◊í◊ï◊© ◊ì◊ü', nameEn: 'Gush Dan', country: 'Israel', icon: 'üèñÔ∏è', secondaryIcon: '‚òÄÔ∏è', file: 'city-gushdan.js' },
  singapore: { id: 'singapore', name: '◊°◊ô◊†◊í◊§◊ï◊®', nameEn: 'Singapore', country: 'Singapore', icon: 'ü¶Å', secondaryIcon: 'üåø', file: 'city-singapore.js' },
  malaga: { id: 'malaga', name: '◊û◊ú◊í◊î', nameEn: 'Malaga', country: 'Spain', icon: '‚òÄÔ∏è', secondaryIcon: '‚òÄÔ∏è', file: 'city-malaga.js' }
};

// Active cities (loaded from localStorage or defaults)
window.BKK.cities = {};
window.BKK.cityData = window.BKK.cityData || {};

// ============================================================================
// CITY LOADING & SELECTION
// ============================================================================

/**
 * Load a city's data file dynamically, then register it.
 * Returns a Promise that resolves when the city is ready.
 */
window.BKK.loadCity = function(cityId) {
  return new Promise(function(resolve, reject) {
    var reg = window.BKK.cityRegistry[cityId];
    if (!reg) { reject('Unknown city: ' + cityId); return; }
    
    // Already loaded?
    if (window.BKK.cityData[cityId]) {
      window.BKK.cities[cityId] = window.BKK.cityData[cityId];
      resolve(window.BKK.cities[cityId]);
      return;
    }
    
    // Load the script
    var script = document.createElement('script');
    script.src = reg.file + '?v=' + window.BKK.VERSION;
    script.onload = function() {
      if (window.BKK.cityData[cityId]) {
        window.BKK.cities[cityId] = window.BKK.cityData[cityId];
        console.log('[CONFIG] Loaded city file: ' + reg.nameEn);
        resolve(window.BKK.cities[cityId]);
      } else {
        reject('City data not found after loading: ' + cityId);
      }
    };
    script.onerror = function() { reject('Failed to load city file: ' + reg.file); };
    document.head.appendChild(script);
  });
};

/**
 * Unload a city to free memory (keeps registry entry).
 */
window.BKK.unloadCity = function(cityId) {
  delete window.BKK.cities[cityId];
  delete window.BKK.cityData[cityId];
  delete window.BKK.cityRegistry[cityId];
  // Remove from custom cities localStorage
  try {
    var customCities = JSON.parse(localStorage.getItem('custom_cities') || '{}');
    delete customCities[cityId];
    localStorage.setItem('custom_cities', JSON.stringify(customCities));
  } catch(e) {}
  console.log('[CONFIG] Unloaded city: ' + cityId);
};

/**
 * Export a city as a downloadable JS file (for GitHub upload).
 */
window.BKK.exportCityFile = function(city) {
  var cityId = city.id;
  var lines = [];
  lines.push('// City data: ' + city.nameEn);
  lines.push('window.BKK.cityData = window.BKK.cityData || {};');
  lines.push('window.BKK.cityData.' + cityId + ' = ' + JSON.stringify(city, null, 2) + ';');
  
  var content = lines.join('\n') + '\n';
  var blob = new Blob([content], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'city-' + cityId + '.js';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  console.log('[CONFIG] Exported city file: city-' + cityId + '.js');
};

/**
 * Export config registry snippet for a city (to add to config.js cityRegistry).
 */
window.BKK.getCityRegistryEntry = function(city) {
  return '  ' + city.id + ": { id: '" + city.id + "', name: '" + city.name + "', nameEn: '" + city.nameEn + "', country: '" + (city.country || '') + "', icon: '" + city.icon + "', file: 'city-" + city.id + ".js' }";
};

/**
 * One-time migration: move old flat customLocations to per-city structure.
 * Old: customLocations/{id} ‚Üí New: cities/{cityId}/locations/{id}
 */
window.BKK.migrateLocationsToPerCity = function(database) {
  if (!database) return Promise.resolve();
  var migrated = localStorage.getItem('locations_migrated_v2');
  if (migrated === 'true') return Promise.resolve();
  
  var updates = {};
  var locCount = 0;
  var routeCount = 0;
  
  return database.ref('customLocations').once('value').then(function(snap) {
    var data = snap.val();
    if (data) {
      Object.keys(data).forEach(function(key) {
        var loc = data[key];
        var cityId = loc.cityId || 'bangkok';
        updates['cities/' + cityId + '/locations/' + key] = loc;
        locCount++;
      });
    }
    return database.ref('savedRoutes').once('value');
  }).then(function(snap) {
    var data = snap.val();
    if (data) {
      Object.keys(data).forEach(function(key) {
        var route = data[key];
        var cityId = route.cityId || 'bangkok';
        updates['cities/' + cityId + '/routes/' + key] = route;
        routeCount++;
      });
    }
    
    if (locCount === 0 && routeCount === 0) {
      localStorage.setItem('locations_migrated_v2', 'true');
      console.log('[MIGRATION] No old data to migrate');
      return;
    }
    
    // Write all to new paths then remove old
    return database.ref().update(updates).then(function() {
      var removals = [];
      if (locCount > 0) removals.push(database.ref('customLocations').remove());
      if (routeCount > 0) removals.push(database.ref('savedRoutes').remove());
      return Promise.all(removals);
    }).then(function() {
      localStorage.setItem('locations_migrated_v2', 'true');
      console.log('[MIGRATION] Migrated ' + locCount + ' locations + ' + routeCount + ' routes to per-city structure');
    });
  }).catch(function(err) {
    console.error('[MIGRATION] Error:', err);
  });
};

/**
 * Select a city and populate all legacy window.BKK.* variables.
 */
window.BKK.selectCity = function(cityId) {
  var city = window.BKK.cities[cityId];
  if (!city) {
    console.error('[CONFIG] City not loaded:', cityId);
    return false;
  }

  window.BKK.selectedCity = city;
  window.BKK.selectedCityId = cityId;

  // Populate legacy area variables
  window.BKK.areaOptions = city.areas.map(function(a) {
    return { id: a.id, label: a.label, labelEn: a.labelEn, desc: a.desc, descEn: a.descEn };
  });

  window.BKK.areaCoordinates = {};
  city.areas.forEach(function(a) {
    var multiplier = a.distanceMultiplier || city.distanceMultiplier || 1.2;
    window.BKK.areaCoordinates[a.id] = {
      lat: a.lat, lng: a.lng, radius: a.radius,
      distanceMultiplier: multiplier,
      size: a.size || 'medium',
      safety: a.safety || 'safe'
    };
  });

  // Populate legacy interest variables
  window.BKK.interestOptions = city.interests;
  window.BKK.interestToGooglePlaces = city.interestToGooglePlaces;
  window.BKK.textSearchInterests = city.textSearchInterests || {};
  window.BKK.uncoveredInterests = city.uncoveredInterests || [];
  window.BKK.interestTooltips = city.interestTooltips || {};

  // City name for search queries
  window.BKK.cityNameForSearch = city.nameEn;

  console.log('[CONFIG] City selected: ' + city.nameEn + ' (' + city.areas.length + ' areas, ' + city.interests.length + ' interests)');
  return true;
};

// Default: load saved city (synchronous for initial page load - city files are in HTML)
(function() {

  // On initial load, city data files are embedded in HTML (via build.py)
  Object.keys(window.BKK.cityData).forEach(function(cityId) {
    window.BKK.cities[cityId] = window.BKK.cityData[cityId];
  });
  
  // Load custom cities from localStorage
  try {
    var customCities = JSON.parse(localStorage.getItem('custom_cities') || '{}');
    Object.keys(customCities).forEach(function(cityId) {
      window.BKK.cities[cityId] = customCities[cityId];
      window.BKK.cityData[cityId] = customCities[cityId];
      if (!window.BKK.cityRegistry[cityId]) {
        window.BKK.cityRegistry[cityId] = {
          id: cityId, name: customCities[cityId].name, nameEn: customCities[cityId].nameEn,
          country: customCities[cityId].country, icon: customCities[cityId].icon, file: null
        };
      }
      console.log('[CONFIG] Loaded custom city: ' + cityId);
    });
  } catch(e) { console.error('[CONFIG] Error loading custom cities:', e); }
  
  // Apply saved active/inactive states from localStorage
  try {
    var states = JSON.parse(localStorage.getItem('city_active_states') || '{}');
    Object.keys(states).forEach(function(cityId) {
      if (window.BKK.cities[cityId]) {
        window.BKK.cities[cityId].active = states[cityId];
      }
    });
  } catch(e) {}
  
  var savedCity = 'bangkok';
  try { savedCity = localStorage.getItem('city_explorer_city') || 'bangkok'; } catch(e) {}
  // If saved city doesn't exist or is not active, pick first active city
  if (!window.BKK.cities[savedCity] || window.BKK.cities[savedCity].active === false) {
    var activeCities = Object.keys(window.BKK.cities).filter(function(id) { return window.BKK.cities[id].active !== false; });
    savedCity = activeCities[0] || Object.keys(window.BKK.cities)[0] || 'bangkok';
  }
  window.BKK.selectCity(savedCity);
})();

// ============================================================================
// HELP CONTENT (shared across cities)
// ============================================================================

// Help content now served from i18n.js translations
// This getter dynamically returns help in the current language
Object.defineProperty(window.BKK, 'helpContent', {
  get() {
    return window.BKK.i18n.strings?.[window.BKK.i18n.currentLang]?.help || window.BKK.i18n.strings?.he?.help || {};
  }
});

console.log('[CONFIG] Loaded successfully');

    </script>
    <!-- Utils -->
    <script>
// ============================================================================
// Bangkok Explorer - Utility Functions
// Copyright ¬© 2026 Eitan Fisher. All Rights Reserved.
// Pure functions - no React state dependency
// ============================================================================

window.BKK = window.BKK || {};

// ============================================================================
// GEOLOCATION & COORDINATES
// ============================================================================

/**
 * Check if a location is within an area's boundaries using Haversine formula
 * @returns {{ valid: boolean, distance: number, distanceKm: string }}
 */
window.BKK.checkLocationInArea = (lat, lng, areaId) => {
  const area = window.BKK.areaCoordinates[areaId];
  if (!area || !lat || !lng) return { valid: true, distance: 0 };
  
  const R = 6371e3; // Earth radius in meters
  const lat1Rad = lat * Math.PI / 180;
  const lat2Rad = area.lat * Math.PI / 180;
  const deltaLat = (area.lat - lat) * Math.PI / 180;
  const deltaLng = (area.lng - lng) * Math.PI / 180;
  
  const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1Rad) * Math.cos(lat2Rad) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;
  
  return { 
    valid: distance <= area.radius, 
    distance: Math.round(distance),
    distanceKm: (distance / 1000).toFixed(1)
  };
};

/**
 * Get all areas that contain this coordinate (within radius)
 * @returns {string[]} Array of area IDs
 */
window.BKK.getAreasForCoordinates = (lat, lng) => {
  if (!lat || !lng) return [];
  const coords = window.BKK.areaCoordinates || {};
  const results = [];
  for (const [areaId, area] of Object.entries(coords)) {
    const check = window.BKK.checkLocationInArea(lat, lng, areaId);
    if (check.valid) results.push(areaId);
  }
  return results.length > 0 ? results : [];
};

/**
 * Normalize location areas: convert old 'area' string to 'areas' array
 * Backward-compatible migration
 */
window.BKK.normalizeLocationAreas = (loc) => {
  if (loc.areas && Array.isArray(loc.areas) && loc.areas.length > 0) {
    return loc.areas;
  }
  if (loc.area && typeof loc.area === 'string') {
    return [loc.area];
  }
  return ['sukhumvit'];
};

/**
 * Extract coordinates from Google Maps URL (various formats)
 * @returns {{ lat: number, lng: number } | null}
 */
window.BKK.extractCoordsFromUrl = (url) => {
  if (!url || !url.trim()) return null;

  let lat = null, lng = null;
  let match;
  
  // Format 1: ?q=13.7465,100.4927
  match = url.match(/[?&]q=([-\d.]+),([-\d.]+)/);
  if (match) { lat = parseFloat(match[1]); lng = parseFloat(match[2]); }
  
  // Format 2: @13.7465,100.4927,17z
  if (!lat) {
    match = url.match(/@([-\d.]+),([-\d.]+)/);
    if (match) { lat = parseFloat(match[1]); lng = parseFloat(match[2]); }
  }
  
  // Format 3: &ll=13.7465,100.4927
  if (!lat) {
    match = url.match(/[?&]ll=([-\d.]+),([-\d.]+)/);
    if (match) { lat = parseFloat(match[1]); lng = parseFloat(match[2]); }
  }
  
  // Format 4: Shortened URLs (goo.gl)
  if (!lat && (url.includes('goo.gl') || url.includes('maps.app'))) {
    return { lat: null, lng: null, shortened: true };
  }
  
  // Format 5: Raw coordinates: 13.7465,100.4927
  if (!lat) {
    match = url.match(/^([-\d.]+)\s*,\s*([-\d.]+)$/);
    if (match) { lat = parseFloat(match[1]); lng = parseFloat(match[2]); }
  }
  
  if (lat !== null && lng !== null) {
    return { lat, lng };
  }
  return null;
};

/**
 * Geocode address using Google Places Text Search API
 * @returns {{ lat, lng, address, displayName } | null}
 */
window.BKK.geocodeAddress = async (address) => {
  if (!address || !address.trim()) return null;

  const cityName = (window.BKK.selectedCity?.nameEn || 'Bangkok');
  const countryName = (window.BKK.selectedCity?.country || 'Thailand');
  const searchQuery = address.toLowerCase().includes(cityName.toLowerCase()) 
    ? address 
    : `${address}, ${cityName}, ${countryName}`;
  
  const response = await fetch(
    'https://places.googleapis.com/v1/places:searchText',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY,
        'X-Goog-FieldMask': 'places.displayName,places.location,places.formattedAddress'
      },
      body: JSON.stringify({ textQuery: searchQuery, maxResultCount: 1 })
    }
  );
  
  const data = await response.json();
  
  if (data.places && data.places.length > 0) {
    const place = data.places[0];
    return {
      lat: place.location.latitude,
      lng: place.location.longitude,
      address: place.formattedAddress || place.displayName?.text || searchQuery,
      displayName: place.displayName?.text || ''
    };
  }
  return null;
};

/**
 * Geocode by place name
 * @returns {{ lat, lng, address, displayName } | null}
 */
window.BKK.geocodeByName = async (name) => {
  if (!name || !name.trim()) return null;

  const cityName = (window.BKK.selectedCity?.nameEn || 'Bangkok');
  const countryName = (window.BKK.selectedCity?.country || 'Thailand');
  const searchQuery = name.toLowerCase().includes(cityName.toLowerCase()) 
    ? name 
    : `${name}, ${cityName}, ${countryName}`;
  
  const response = await fetch(
    'https://places.googleapis.com/v1/places:searchText',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY,
        'X-Goog-FieldMask': 'places.displayName,places.location,places.formattedAddress'
      },
      body: JSON.stringify({ textQuery: searchQuery, maxResultCount: 1 })
    }
  );
  
  const data = await response.json();
  
  if (data.places && data.places.length > 0) {
    const place = data.places[0];
    return {
      lat: place.location.latitude,
      lng: place.location.longitude,
      address: place.formattedAddress || '',
      displayName: place.displayName?.text || name
    };
  }
  return null;
};

/**
 * Reverse geocode: get address from coordinates
 * @returns {string} formatted address
 */
window.BKK.reverseGeocode = async (lat, lng) => {
  try {
    const response = await fetch(
      'https://places.googleapis.com/v1/places:searchText',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY,
          'X-Goog-FieldMask': 'places.formattedAddress'
        },
        body: JSON.stringify({ textQuery: `${lat},${lng}`, maxResultCount: 1 })
      }
    );
    
    const data = await response.json();
    if (data.places && data.places.length > 0) {
      return data.places[0].formattedAddress || '';
    }
    return '';
  } catch (error) {
    console.error('[REVERSE GEOCODE] Error:', error);
    return '';
  }
};

// ============================================================================
// IMAGE HANDLING
// ============================================================================

/**
 * Compress image file to target size
 * @returns {Promise<string>} base64 compressed image (fallback) or URL
 */
window.BKK.compressImage = (file, maxSizeKB = 150) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        const maxDimension = 600;
        if (width > height && width > maxDimension) {
          height = (height / width) * maxDimension;
          width = maxDimension;
        } else if (height > maxDimension) {
          width = (width / height) * maxDimension;
          height = maxDimension;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        let quality = 0.7;
        let compressed = canvas.toDataURL('image/jpeg', quality);
        
        while (compressed.length > maxSizeKB * 1024 * 1.37 && quality > 0.2) {
          quality -= 0.1;
          compressed = canvas.toDataURL('image/jpeg', quality);
        }
        
        console.log('[IMAGE] Compressed:', {
          original: file.size,
          compressed: Math.round(compressed.length / 1024),
          quality
        });
        
        resolve(compressed);
      };
      img.src = e.target.result;
    };
    
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

/**
 * Upload an image to Firebase Storage and return the download URL.
 * Falls back to base64 if Storage is not available.
 */
window.BKK.uploadImage = async (file, cityId, locationId) => {
  // Compress first
  const compressed = await window.BKK.compressImage(file);
  
  // Try Firebase Storage
  if (typeof firebase !== 'undefined' && firebase.storage) {
    try {
      const storageRef = firebase.storage().ref();
      const path = `cities/${cityId}/images/${locationId}_${Date.now()}.jpg`;
      const imageRef = storageRef.child(path);
      
      // Convert base64 to blob for upload
      const response = await fetch(compressed);
      const blob = await response.blob();
      
      const snapshot = await imageRef.put(blob, { contentType: 'image/jpeg' });
      const downloadURL = await snapshot.ref.getDownloadURL();
      
      console.log('[STORAGE] Uploaded image:', path, 'URL:', downloadURL.substring(0, 60) + '...');
      return downloadURL;
    } catch (err) {
      console.error('[STORAGE] Upload failed, falling back to base64:', err);
      return compressed;
    }
  }
  
  // Fallback: return base64
  console.log('[STORAGE] Not available, using base64 fallback');
  return compressed;
};

// ============================================================================
// UI HELPERS
// ============================================================================

/**
 * Consistent button style generator
 */
window.BKK.getButtonStyle = (isActive = false, variant = 'primary') => {
  const baseStyle = {
    border: isActive ? '5px solid #f97316' : '3px solid #d1d5db',
    backgroundColor: isActive ? '#fed7aa' : '#ffffff',
    boxShadow: isActive ? '0 10px 15px -3px rgba(0, 0, 0, 0.3)' : 'none',
    padding: '12px 16px',
    borderRadius: '12px',
    fontWeight: 'bold',
    cursor: 'pointer',
    transition: 'all 0.2s'
  };
  
  if (variant === 'danger') {
    return {
      ...baseStyle,
      border: '3px solid #ef4444',
      backgroundColor: isActive ? '#fecaca' : '#ffffff',
      color: '#dc2626'
    };
  }
  
  if (variant === 'success') {
    return {
      ...baseStyle,
      border: '3px solid #10b981',
      backgroundColor: isActive ? '#d1fae5' : '#ffffff',
      color: '#059669'
    };
  }
  
  return baseStyle;
};

/**
 * Build Google Maps directions URL from stops
 */
window.BKK.buildMapsUrl = (stops, circular = false) => {
  if (!stops || stops.length === 0) return '';
  
  const validStops = stops.filter(s => s.lat && s.lng && s.lat !== 0 && s.lng !== 0);
  if (validStops.length === 0) return '';
  
  let waypoints = validStops.map(s => `${s.lat},${s.lng}`);
  
  if (circular && validStops.length > 1) {
    waypoints.push(waypoints[0]);
  }
  
  const origin = waypoints[0];
  const destination = waypoints[waypoints.length - 1];
  const middlePoints = waypoints.slice(1, -1).join('|');
  
  let mapUrl = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}`;
  if (middlePoints) {
    mapUrl += `&waypoints=${middlePoints}`;
  }
  mapUrl += '&travelmode=walking';
  
  return mapUrl;
};

/**
 * Parse user agent for readable browser/OS info
 */
window.BKK.parseUserAgent = (ua) => {
  let browser = 'Unknown', os = 'Unknown';
  if (ua.includes('SamsungBrowser')) browser = 'Samsung';
  else if (ua.includes('Chrome') && !ua.includes('Edg')) browser = 'Chrome';
  else if (ua.includes('Safari') && !ua.includes('Chrome')) browser = 'Safari';
  else if (ua.includes('Firefox')) browser = 'Firefox';
  else if (ua.includes('Edg')) browser = 'Edge';
  if (ua.includes('iPhone')) os = 'iPhone';
  else if (ua.includes('iPad')) os = 'iPad';
  else if (ua.includes('Android')) os = 'Android';
  else if (ua.includes('Windows')) os = 'Windows';
  else if (ua.includes('Mac OS')) os = 'Mac';
  else if (ua.includes('Linux')) os = 'Linux';
  return { browser, os };
};

/**
 * SHA-256 hash a string (for password protection)
 * Returns hex string. Uses Web Crypto API.
 */
window.BKK.hashPassword = async function(password) {
  if (!password) return '';
  var encoder = new TextEncoder();
  var data = encoder.encode(password);
  var hashBuffer = await crypto.subtle.digest('SHA-256', data);
  var hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(function(b) { return b.toString(16).padStart(2, '0'); }).join('');
};

/**
 * Build the best Google Maps URL for a place.
 * Priority: Place ID ‚Üí name search for Google-origin places ‚Üí address ‚Üí raw coords.
 */
window.BKK.getGoogleMapsUrl = (place) => {
  if (!place) return '#';
  const hasCoords = place.lat && place.lng;
  if (!hasCoords && !place.address?.trim()) return '#';
  
  // Best: use Place ID ‚Üí opens the actual Google Maps place page
  if (place.googlePlaceId) {
    const query = encodeURIComponent(place.name || place.address || `${place.lat},${place.lng}`);
    return `https://www.google.com/maps/search/?api=1&query=${query}&query_place_id=${place.googlePlaceId}`;
  }
  
  // Google-origin place without Place ID (saved before this feature):
  // Search by name near coords ‚Äî Google will likely match the real place
  if ((place.fromGoogle || place.googlePlace) && place.name && hasCoords) {
    return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place.name)}&center=${place.lat},${place.lng}&zoom=17`;
  }
  
  // Fallback: address
  if (place.address?.trim()) {
    return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place.address.trim())}`;
  }
  
  // Last resort: raw coordinates (pin on map)
  if (hasCoords) {
    return `https://www.google.com/maps/search/?api=1&query=${place.lat},${place.lng}`;
  }
  
  return '#';
};

console.log('[UTILS] Loaded successfully');

// Build Google Maps direction URLs, splitting into multiple if exceeding maxPoints limit
// maxPoints = total points including origin + destination (default 12 = 10 waypoints + origin + dest)
// Returns array of { url, fromIndex, toIndex, label } objects
window.BKK.buildGoogleMapsUrls = (stops, origin, isCircular, maxPoints) => {
  maxPoints = maxPoints || 12;
  const maxWaypoints = maxPoints - 2; // subtract origin + destination
  
  if (stops.length === 0) return [];
  
  // Single stop, no splitting needed
  if (stops.length === 1) {
    let url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${stops[0].lat},${stops[0].lng}&travelmode=walking`;
    return [{ url, fromIndex: 0, toIndex: 0, part: 1, total: 1 }];
  }
  
  // All stops fit in one URL (stops as waypoints + last as destination, or circular back to origin)
  const totalWaypointsNeeded = isCircular ? stops.length : stops.length - 1;
  
  if (totalWaypointsNeeded <= maxWaypoints) {
    // Everything fits in one URL
    let destination, waypointsArr;
    if (isCircular) {
      destination = origin;
      waypointsArr = stops.map(s => `${s.lat},${s.lng}`);
    } else {
      destination = `${stops[stops.length - 1].lat},${stops[stops.length - 1].lng}`;
      waypointsArr = stops.slice(0, -1).map(s => `${s.lat},${s.lng}`);
    }
    let url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}`;
    if (waypointsArr.length > 0) url += `&waypoints=${waypointsArr.join('|')}`;
    url += '&travelmode=walking';
    return [{ url, fromIndex: 0, toIndex: stops.length - 1, part: 1, total: 1 }];
  }
  
  // Need to split into multiple URLs
  // Each segment: origin ‚Üí maxWaypoints waypoints ‚Üí destination
  // Next segment starts from previous destination
  const urls = [];
  let currentIndex = 0;
  let currentOrigin = origin;
  
  while (currentIndex < stops.length) {
    const remaining = stops.length - currentIndex;
    const isLastSegment = remaining <= maxWaypoints + 1;
    
    let segmentStops, destination;
    
    if (isLastSegment) {
      // Last segment: take all remaining stops
      segmentStops = stops.slice(currentIndex);
      if (isCircular && urls.length === 0 && segmentStops.length <= maxWaypoints + 1) {
        // Edge case: would have fit without split - shouldn't happen, but handle gracefully
        destination = origin;
        const wps = segmentStops.map(s => `${s.lat},${s.lng}`);
        let url = `https://www.google.com/maps/dir/?api=1&origin=${currentOrigin}&destination=${destination}`;
        if (wps.length > 0) url += `&waypoints=${wps.join('|')}`;
        url += '&travelmode=walking';
        urls.push({ url, fromIndex: currentIndex, toIndex: stops.length - 1, part: urls.length + 1, total: 0 });
        break;
      } else if (isCircular) {
        // Last segment of circular: return to original origin
        destination = origin;
        const wps = segmentStops.map(s => `${s.lat},${s.lng}`);
        let url = `https://www.google.com/maps/dir/?api=1&origin=${currentOrigin}&destination=${destination}`;
        if (wps.length > 0) url += `&waypoints=${wps.join('|')}`;
        url += '&travelmode=walking';
        urls.push({ url, fromIndex: currentIndex, toIndex: stops.length - 1, part: urls.length + 1, total: 0 });
        break;
      } else {
        // Last segment of linear
        destination = `${segmentStops[segmentStops.length - 1].lat},${segmentStops[segmentStops.length - 1].lng}`;
        const wps = segmentStops.slice(0, -1).map(s => `${s.lat},${s.lng}`);
        let url = `https://www.google.com/maps/dir/?api=1&origin=${currentOrigin}&destination=${destination}`;
        if (wps.length > 0) url += `&waypoints=${wps.join('|')}`;
        url += '&travelmode=walking';
        urls.push({ url, fromIndex: currentIndex, toIndex: stops.length - 1, part: urls.length + 1, total: 0 });
        break;
      }
    } else {
      // Not last segment: take maxWaypoints stops as waypoints, last one is destination
      segmentStops = stops.slice(currentIndex, currentIndex + maxWaypoints + 1);
      destination = `${segmentStops[segmentStops.length - 1].lat},${segmentStops[segmentStops.length - 1].lng}`;
      const wps = segmentStops.slice(0, -1).map(s => `${s.lat},${s.lng}`);
      let url = `https://www.google.com/maps/dir/?api=1&origin=${currentOrigin}&destination=${destination}`;
      if (wps.length > 0) url += `&waypoints=${wps.join('|')}`;
      url += '&travelmode=walking';
      urls.push({ url, fromIndex: currentIndex, toIndex: currentIndex + segmentStops.length - 1, part: urls.length + 1, total: 0 });
      
      // Next segment starts from the last stop of this segment
      currentOrigin = destination;
      currentIndex += segmentStops.length - 1; // overlap: last stop becomes next origin
    }
  }
  
  // Fill in total count
  const total = urls.length;
  urls.forEach(u => u.total = total);
  
  return urls;
};


    </script>

    
    <script>
      tailwind.config = {
        theme: {
          extend: {
            borderWidth: {
              '3': '3px',
              '4': '4px',
            }
          }
        }
      }
    </script>
</head>
<body>
    <div id="root">
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;gap:16px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%)">
        <div style="width:48px;height:48px;border:4px solid rgba(255,255,255,0.3);border-top:4px solid white;border-radius:50%;animation:spin 0.8s linear infinite"></div>
        <div style="color:white;font-size:18px;font-weight:bold;font-family:system-ui">City Explorer</div>
        <div style="color:rgba(255,255,255,0.7);font-size:13px">Loading...</div>
      </div>
      <style>@keyframes spin{to{transform:rotate(360deg)}}</style>
    </div>
    
    <script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;

// Firebase Configuration - loaded from config.js
const firebaseConfig = window.BKK.firebaseConfig;

// Initialize Firebase (deferred until SDK loads)
let firebaseApp = null;
let database = null;
let storage = null;
let isFirebaseAvailable = false;

function initFirebase() {
  try {
    if (typeof firebase !== 'undefined') {
      const cfg = window.BKK.firebaseConfig;
      if (!cfg || !cfg.apiKey) {
        console.error('[FIREBASE] Config not found on window.BKK');
        return;
      }
      firebaseApp = firebase.initializeApp(cfg);
      database = firebase.database();
      if (firebase.storage) {
        storage = firebase.storage();
        console.log('[FIREBASE] Storage initialized');
      }
      isFirebaseAvailable = true;
      console.log('[FIREBASE] Initialized successfully');
    } else {
      console.log('[FIREBASE] Not available - using localStorage only');
    }
  } catch (error) {
    console.error('[FIREBASE] Initialization failed:', error);
    console.log('[FIREBASE] Falling back to localStorage');
  }
}

// Google Places API - loaded from config.js
const GOOGLE_PLACES_API_KEY = window.BKK.GOOGLE_PLACES_API_KEY;
const GOOGLE_PLACES_API_URL = window.BKK.GOOGLE_PLACES_API_URL;

const CityExplorer = () => {

  // Load saved preferences
  const loadPreferences = () => {
    try {
      const saved = localStorage.getItem('bangkok_preferences');
      if (saved) {
        const prefs = JSON.parse(saved);
        // Admin-controlled defaults (will be overridden by Firebase on load)
        if (!prefs.maxStops) prefs.maxStops = 12;
        if (!prefs.fetchMoreCount) prefs.fetchMoreCount = 3;
        // User-specific settings preserved from last session
        if (!prefs.searchMode) prefs.searchMode = 'area';
        if (prefs.searchMode === 'radius' && prefs.radiusMeters === 15000 && prefs.radiusPlaceName === t('general.allCity')) prefs.searchMode = 'all';
        if (!prefs.radiusMeters) prefs.radiusMeters = 500;
        if (!prefs.radiusSource) prefs.radiusSource = 'gps';
        if (!prefs.radiusPlaceName) prefs.radiusPlaceName = '';
        return prefs;
      }
    } catch (e) {}
    // First time user: area and interests empty, defaults for everything else
    return {
      hours: 3,
      area: '',
      interests: [],
      circular: true,
      startPoint: '',
      maxStops: 12,
      fetchMoreCount: 3,
      searchMode: 'area',
      radiusMeters: 500,
      radiusSource: 'gps',
      radiusPlaceId: null,
      radiusPlaceName: '',
      gpsLat: null,
      gpsLng: null,
      currentLat: null,
      currentLng: null
    };
  };

  const [currentView, setCurrentView] = useState('form');
  const [currentLang, setCurrentLang] = useState(() => {
    return window.BKK.i18n.currentLang || 'he';
  });
  const [selectedCityId, setSelectedCityId] = useState(() => {
    try { return localStorage.getItem('city_explorer_city') || 'bangkok'; } catch(e) { return 'bangkok'; }
  });
  const [wizardMode, setWizardMode] = useState(() => {
    try { return localStorage.getItem('bangkok_wizard_mode') !== 'false'; } catch(e) { return true; }
  });
  const [wizardStep, setWizardStep] = useState(1);
  const [formData, setFormData] = useState(loadPreferences());
  const [route, setRoute] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [disabledStops, setDisabledStops] = useState([]); // Track disabled stop IDs
  const [showRoutePreview, setShowRoutePreview] = useState(false); // Route stop reorder view
  const [manualStops, setManualStops] = useState([]); // Manually added stops (session only)
  const [showManualAddDialog, setShowManualAddDialog] = useState(false);
  const [routeType, setRouteType] = useState(() => {
    // Load from localStorage or default to 'circular'
    const saved = localStorage.getItem('bangkok_route_type');
    return saved || 'circular';
  }); // 'circular' or 'linear'
  const [savedRoutes, setSavedRoutes] = useState([]);
  const [customLocations, setCustomLocations] = useState([]);
  const [showAddLocationDialog, setShowAddLocationDialog] = useState(false);
  const [showBlacklistLocations, setShowBlacklistLocations] = useState(false);
  const [updateAvailable, setUpdateAvailable] = useState(false);
  const [placesGroupBy, setPlacesGroupBy] = useState('interest'); // 'interest' or 'area'
  const [routesSortBy, setRoutesSortBy] = useState('area'); // 'area' or 'name'
  const [editingRoute, setEditingRoute] = useState(null);
  const [showRouteDialog, setShowRouteDialog] = useState(false);
  const [routeDialogMode, setRouteDialogMode] = useState('edit'); // 'add' or 'edit'
  const [newLocation, setNewLocation] = useState({
    name: '',
    description: '',
    notes: '',
    area: formData.area,
    areas: [formData.area],
    interests: [],
    lat: null,
    lng: null,
    mapsUrl: '',
    address: '',  // Address for geocoding
    uploadedImage: null,  // Base64 image data
    imageUrls: [],  // Array of URL strings
    inProgress: true  // Auto-check for new locations
  });
  const [customInterests, setCustomInterests] = useState([]);
  const [interestStatus, setInterestStatus] = useState({}); // { interestId: true/false }
  
  // Interest search configuration (editable)
  const [interestConfig, setInterestConfig] = useState({});
  const [googlePlaceInfo, setGooglePlaceInfo] = useState(null);
  const [loadingGoogleInfo, setLoadingGoogleInfo] = useState(false);
  const [locationSearchResults, setLocationSearchResults] = useState(null); // null=hidden, []=no results, [...]= results
  const [editingCustomInterest, setEditingCustomInterest] = useState(null);
  const [showAddInterestDialog, setShowAddInterestDialog] = useState(false);
  const [newInterest, setNewInterest] = useState({ label: '', icon: 'üìç', searchMode: 'types', types: '', textSearch: '', blacklist: '' });
  const [showEditLocationDialog, setShowEditLocationDialog] = useState(false);
  const [editingLocation, setEditingLocation] = useState(null);
  const [showImageModal, setShowImageModal] = useState(false);
  const [showAddressDialog, setShowAddressDialog] = useState(false);
  const [showMapModal, setShowMapModal] = useState(false);
  const [settingsTab, setSettingsTab] = useState('cities'); // 'cities' or 'general'
  const [editingArea, setEditingArea] = useState(null); // area being edited on map
  const [mapMode, setMapMode] = useState('areas'); // 'areas' or 'radius'
  const leafletMapRef = React.useRef(null);
  
  // Cache for unused Google Places results per interest (avoids redundant API calls)
  const googleCacheRef = React.useRef({});

  // Leaflet Map initialization
  React.useEffect(() => {
    if (!showMapModal) {
      if (leafletMapRef.current) {
        leafletMapRef.current.remove();
        leafletMapRef.current = null;
      }
      return;
    }
    
    // Wait for DOM
    const timer = setTimeout(() => {
      const container = document.getElementById('leaflet-map-container');
      if (!container) return;
      // Clean previous map if exists
      if (leafletMapRef.current) {
        leafletMapRef.current.remove();
        leafletMapRef.current = null;
      }
      
      try {
        const coords = window.BKK.areaCoordinates || {};
        const areas = window.BKK.areaOptions || [];
        
        // Generate area colors dynamically from palette
        const colorPalette = ['#3b82f6', '#f59e0b', '#ef4444', '#10b981', '#ec4899', '#6366f1', '#8b5cf6', '#06b6d4', '#f97316', '#a855f7', '#14b8a6', '#e11d48', '#84cc16', '#0ea5e9', '#d946ef', '#f43f5e'];
        const areaColors = {};
        areas.forEach((area, i) => { areaColors[area.id] = colorPalette[i % colorPalette.length]; });
        
        if (mapMode === 'areas') {
          // All areas mode - center on selected city
          const cityCenter = window.BKK.selectedCity?.center || { lat: 13.7500, lng: 100.5350 };
          const map = L.map(container).setView([cityCenter.lat, cityCenter.lng], 12);
          L.tileLayer(window.BKK.getTileUrl(), {
            attribution: '¬© OpenStreetMap contributors', maxZoom: 18
          }).addTo(map);
          
          const allCircles = [];
          areas.forEach(area => {
            const c = coords[area.id];
            if (!c) return;
            const color = areaColors[area.id] || '#6b7280';
            const circle = L.circle([c.lat, c.lng], {
              radius: c.radius, color: color, fillColor: color,
              fillOpacity: 0.15, weight: 2
            }).addTo(map).bindPopup(
              '<div style="text-align:center;direction:rtl;font-size:13px;">' +
              '<b>' + tLabel(area) + '</b><br/>' +
              '<span style="color:#666;font-size:11px;">' + area.labelEn + '</span><br/>' +
              '<span style="color:#999;font-size:10px;">Radius: ' + c.radius + ' m</span></div>'
            );
            // Name label with background for readability
            L.marker([c.lat, c.lng], {
              icon: L.divIcon({
                className: '',
                html: '<div style="font-size:10px;font-weight:bold;text-align:center;color:' + color + ';background:rgba(255,255,255,0.88);padding:2px 5px;border-radius:4px;border:1.5px solid ' + color + ';white-space:nowrap;line-height:1.2;box-shadow:0 1px 3px rgba(0,0,0,0.15);">' + tLabel(area) + '</div>',
                iconSize: [80, 22], iconAnchor: [40, 11]
              })
            }).addTo(map);
            allCircles.push(circle);
          });
          
          // Auto-fit to show all areas
          if (allCircles.length > 0) {
            const group = L.featureGroup(allCircles);
            map.fitBounds(group.getBounds().pad(0.1));
          }
          
          leafletMapRef.current = map;
        } else {
          // Radius mode
          const lat = formData.currentLat;
          const lng = formData.currentLng;
          if (!lat || !lng) return;
          
          const map = L.map(container).setView([lat, lng], 15);
          L.tileLayer(window.BKK.getTileUrl(), {
            attribution: '¬© OpenStreetMap contributors', maxZoom: 18
          }).addTo(map);
          
          // Radius circle FIRST (so marker is on top)
          const radiusCircle = L.circle([lat, lng], {
            radius: formData.radiusMeters, color: '#e11d48', fillColor: '#e11d48',
            fillOpacity: 0.12, weight: 3, dashArray: '8,6'
          }).addTo(map);
          
          // Center marker (red, prominent)
          L.circleMarker([lat, lng], {
            radius: 8, color: '#e11d48', fillColor: '#e11d48',
            fillOpacity: 1, weight: 2
          }).addTo(map).bindPopup(
            '<div style="text-align:center;direction:rtl;">' +
            '<b>üìç ' + (formData.radiusPlaceName || t('form.currentLocation')) + '</b><br/>' +
            '<span style="font-size:11px;color:#666;">Radius: ' + formData.radiusMeters + ' m</span></div>'
          ).openPopup();
          
          // Fit to circle bounds
          map.fitBounds(radiusCircle.getBounds().pad(0.15));
          
          // Show area circles faintly for context
          areas.forEach(area => {
            const c = coords[area.id];
            if (!c) return;
            L.circle([c.lat, c.lng], {
              radius: c.radius, color: '#94a3b8', fillColor: '#94a3b8',
              fillOpacity: 0.04, weight: 1
            }).addTo(map);
            L.marker([c.lat, c.lng], {
              icon: L.divIcon({
                className: '',
                html: '<div style="font-size:8px;color:#94a3b8;text-align:center;white-space:nowrap;">' + tLabel(area) + '</div>',
                iconSize: [50, 15], iconAnchor: [25, 7]
              })
            }).addTo(map);
          });
          
          leafletMapRef.current = map;
        }
      } catch(err) {
        console.error('[MAP]', err);
      }
    }, 150);
    
    return () => clearTimeout(timer);
  }, [showMapModal, mapMode, formData.currentLat, formData.currentLng, formData.radiusMeters]);
  const [modalImage, setModalImage] = useState(null);
  const [toastMessage, setToastMessage] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [placeSearchQuery, setPlaceSearchQuery] = useState(() => {
    try {
      const prefs = JSON.parse(localStorage.getItem('bangkok_preferences'));
      return prefs?.radiusPlaceName || '';
    } catch(e) { return ''; }
  });
  const [searchResults, setSearchResults] = useState([]);
  const [addingPlaceIds, setAddingPlaceIds] = useState([]); // Track places being added
  const [showImportDialog, setShowImportDialog] = useState(false);
  const [importedData, setImportedData] = useState(null);
  
  // Access Log System (Admin Only)
  const [accessLogs, setAccessLogs] = useState([]);
  const [hasNewEntries, setHasNewEntries] = useState(false);
  const [isCurrentUserAdmin, setIsCurrentUserAdmin] = useState(() => {
    return localStorage.getItem('bangkok_is_admin') === 'true';
  });
  const [showAccessLog, setShowAccessLog] = useState(false);

  // Feedback System
  const [showFeedbackDialog, setShowFeedbackDialog] = useState(false);
  const [feedbackText, setFeedbackText] = useState('');
  const [feedbackCategory, setFeedbackCategory] = useState('general');
  const [feedbackList, setFeedbackList] = useState([]);
  const [showFeedbackList, setShowFeedbackList] = useState(false);
  const [hasNewFeedback, setHasNewFeedback] = useState(false);

  // Confirm Dialog (replaces browser confirm)
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmConfig, setConfirmConfig] = useState({ message: '', onConfirm: null });

  // Help System
  const [showHelp, setShowHelp] = useState(false);
  const [helpContext, setHelpContext] = useState('main');
  
  // Debug Mode System
  const [debugMode, setDebugMode] = useState(() => {
    return localStorage.getItem('bangkok_debug_mode') === 'true';
  });
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isDataLoaded, setIsDataLoaded] = useState(false); // Tracks initial Firebase/localStorage load
  const dataLoadTracker = React.useRef({ locations: false, interests: false, config: false, status: false, routes: false });
  const markLoaded = (key) => {
    dataLoadTracker.current[key] = true;
    const t = dataLoadTracker.current;
    if (t.locations && t.interests && t.config && t.status && t.routes) {
      setIsDataLoaded(true);
      window.scrollTo(0, 0);
    }
  };
  
  // Safety timeout - don't show loading forever
  useEffect(() => {
    const timer = setTimeout(() => {
      if (!isDataLoaded) {
        console.warn('[LOAD] Safety timeout - forcing data loaded after 5s');
        setIsDataLoaded(true);
        window.scrollTo(0, 0);
      }
    }, 5000);
    return () => clearTimeout(timer);
  }, [isDataLoaded]);
  const [startPointCoords, setStartPointCoords] = useState(null); // { lat, lng }
  const [isLocating, setIsLocating] = useState(false);
  const [rightColWidth, setRightColWidth] = useState(() => {
    try {
      const saved = parseInt(localStorage.getItem('bangkok_right_col_width'));
      return saved && saved >= 100 && saved <= 250 ? saved : 130;
    } catch(e) { return 130; }
  });
  
  // Admin System - Password based
  const [adminPassword, setAdminPassword] = useState('');
  const [adminUsers, setAdminUsers] = useState([]);
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [showVersionPasswordDialog, setShowVersionPasswordDialog] = useState(false);
  const [showAddCityDialog, setShowAddCityDialog] = useState(false);
  const [addCityInput, setAddCityInput] = useState('');
  const [addCitySearchStatus, setAddCitySearchStatus] = useState(''); // '', 'searching', 'found', 'error', 'generating', 'done'
  const [addCityFound, setAddCityFound] = useState(null);
  const [addCityGenerated, setAddCityGenerated] = useState(null);
  const [googleMaxWaypoints, setGoogleMaxWaypoints] = useState(12);
  const [googleMaxMapPoints, setGoogleMaxMapPoints] = useState(10);
  const [cityModified, setCityModified] = useState(false);
  const [cityEditCounter, setCityEditCounter] = useState(0); // Force re-render on city object mutation
  const [showSettingsMap, setShowSettingsMap] = useState(false);
  const [passwordInput, setPasswordInput] = useState('');
  const [newAdminPassword, setNewAdminPassword] = useState(''); // For setting new password in admin panel
  
  // Add debug log entry (console only)
  const addDebugLog = (category, message, data = null) => {
    if (!debugMode) return;
    console.log(`[${category}] ${message}`, data || '');
  };
  
  // Save debug mode preference
  useEffect(() => {
    localStorage.setItem('bangkok_debug_mode', debugMode.toString());
  }, [debugMode]);
  
  // Help content - loaded from config.js
  const helpContent = window.BKK.helpContent;

  const showHelpFor = (context) => {
    setHelpContext(context);
    setShowHelp(true);
  };

  const showConfirm = (message, onConfirm) => {
    setConfirmConfig({ message, onConfirm });
    setShowConfirmDialog(true);
  };

  // Toast notification helper
  const showToast = (message, type = 'success', customDuration = null) => {
    setToastMessage({ message, type, sticky: customDuration === 'sticky' });
    if (customDuration !== 'sticky') {
      const duration = customDuration || Math.min(4000, Math.max(1500, message.length * 50));
      setTimeout(() => setToastMessage(null), duration);
    }
  };

  // Get current GPS location and reverse geocode to address
  const getMyLocation = () => {
    if (!navigator.geolocation) {
      showToast(t('toast.browserNoLocation'), 'error');
      return;
    }
    
    setIsLocating(true);
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const { latitude: lat, longitude: lng } = position.coords;
        console.log('[GPS] Got location:', lat, lng);
        
        // Try to get address via reverse geocode
        try {
          const address = await window.BKK.reverseGeocode(lat, lng);
          const displayAddress = address || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          setStartPointCoords({ lat, lng, address: displayAddress });
          setFormData(prev => ({ ...prev, startPoint: displayAddress }));
          showToast(address ? t('form.locationDetectedFull') : t('form.locationDetectedNoAddr'), 'success');
        } catch (err) {
          const fallback = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          setStartPointCoords({ lat, lng, address: fallback });
          setFormData(prev => ({ ...prev, startPoint: fallback }));
          showToast(t('form.locationDetected'), 'success');
        }
        
        setIsLocating(false);
      },
      (error) => {
        setIsLocating(false);
        console.error('[GPS] Error:', error);
        if (error.code === 1) {
          showToast(t('toast.locationNoPermission'), 'error');
        } else if (error.code === 2) {
          showToast(t('toast.locationUnavailable'), 'error');
        } else {
          showToast(t('toast.locationError'), 'error');
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
    );
  };

  // Geocode typed start point address to coordinates
  const validateStartPoint = async () => {
    const text = formData.startPoint?.trim();
    if (!text) {
      showToast(t('form.enterAddressOrName'), 'warning');
      return;
    }
    
    setIsLocating(true);
    try {
      const result = await window.BKK.geocodeAddress(text);
      if (result) {
        const validatedAddress = result.address || result.displayName || text;
        setStartPointCoords({ lat: result.lat, lng: result.lng, address: validatedAddress });
        setFormData(prev => ({ ...prev, startPoint: validatedAddress }));
        showToast(`${t("toast.addressVerified")} ${result.displayName || result.address}`, 'success');
        console.log('[START_POINT] Geocoded:', text, '->', result);
      } else {
        showToast(t('places.addressNotFound'), 'warning');
      }
    } catch (err) {
      console.error('[START_POINT] Geocode error:', err);
      showToast(t('toast.addressSearchError'), 'error');
    }
    setIsLocating(false);
  };

  // Detect which area the user is currently in based on GPS
  const detectArea = () => {
    if (!navigator.geolocation) {
      showToast(t('toast.browserNoLocation'), 'error');
      return;
    }
    setIsLocating(true);
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude: lat, longitude: lng } = position.coords;
        const coords = window.BKK.areaCoordinates;
        
        // Calculate distance to each area center
        let closest = null;
        let closestDist = Infinity;
        
        for (const [areaId, center] of Object.entries(coords)) {
          const dlat = (lat - center.lat) * 111320;
          const dlng = (lng - center.lng) * 111320 * Math.cos(lat * Math.PI / 180);
          const dist = Math.sqrt(dlat * dlat + dlng * dlng);
          
          if (dist <= center.radius && dist < closestDist) {
            closest = areaId;
            closestDist = dist;
          }
        }
        
        if (closest) {
          const areaName = areaOptions.find(a => a.id === closest)? tLabel(areaOptions.find(a => a.id === closest)) : closest;
          setFormData(prev => ({ ...prev, area: closest }));
          showToast(`${t("toast.foundInArea")} ${areaName}`, 'success');
        } else {
          showToast(t('places.locationOutsideSelection'), 'warning');
        }
        setIsLocating(false);
      },
      (error) => {
        setIsLocating(false);
        if (error.code === 1) {
          showToast(t('toast.locationNoPermission'), 'error');
        } else {
          showToast(t('toast.locationUnavailable'), 'error');
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
    );
  };
  // One-time migration: move old customLocations to per-city structure
  useEffect(() => {
    if (isFirebaseAvailable && database) {
      window.BKK.migrateLocationsToPerCity(database);
    }
  }, []);

  // Load saved routes from Firebase - PER CITY
  useEffect(() => {
    if (!selectedCityId) return;
    
    if (isFirebaseAvailable && database) {
      const routesRef = database.ref(`cities/${selectedCityId}/routes`);
      
      const onValue = routesRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const routesArray = Object.keys(data).map(key => ({
            ...data[key],
            firebaseId: key
          }));
          setSavedRoutes(routesArray);
          console.log('[FIREBASE] Loaded', routesArray.length, 'saved routes for', selectedCityId);
        } else {
          setSavedRoutes([]);
        }
        markLoaded('routes');
      });
      
      return () => routesRef.off('value', onValue);
    } else {
      try {
        const saved = localStorage.getItem('bangkok_saved_routes');
        if (saved) {
          setSavedRoutes(JSON.parse(saved));
        }
      } catch (e) {
        // Silent fail
      }
      markLoaded('routes');
    }
  }, [selectedCityId]);

  // Load custom locations from Firebase - PER CITY
  useEffect(() => {
    if (!selectedCityId) return;
    
    if (isFirebaseAvailable && database) {
      console.log('[DATA] Loading locations for city:', selectedCityId);
      const locationsRef = database.ref(`cities/${selectedCityId}/locations`);
      
      const onValue = locationsRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const locationsArray = Object.keys(data).map(key => ({
            ...data[key],
            firebaseId: key,
            cityId: selectedCityId
          }));
          setCustomLocations(locationsArray);
          console.log('[FIREBASE] Loaded', locationsArray.length, 'locations for', selectedCityId);
        } else {
          setCustomLocations([]);
        }
        markLoaded('locations');
      });
      
      return () => locationsRef.off('value', onValue);
    } else {
      console.log('[DATA] Firebase not available - using localStorage fallback');
      try {
        const allLocs = JSON.parse(localStorage.getItem('bangkok_custom_locations') || '[]');
        const cityLocs = allLocs.filter(l => (l.cityId || 'bangkok') === selectedCityId);
        setCustomLocations(cityLocs);
      } catch (e) {
        console.error('[LOCALSTORAGE] Error loading locations:', e);
      }
      markLoaded('locations');
    }
  }, [selectedCityId]);

  // Load custom interests from Firebase
  useEffect(() => {
    if (isFirebaseAvailable && database) {
      const interestsRef = database.ref('customInterests');
      const builtInIds = new Set([...window.BKK.interestOptions.map(i => i.id), ...window.BKK.uncoveredInterests.map(i => i.id)]);
      
      const unsubscribe = interestsRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const allEntries = Object.keys(data).map(key => ({
            ...data[key],
            firebaseId: key
          }));
          // Filter out built-in IDs that were accidentally saved as custom
          const duplicates = allEntries.filter(i => builtInIds.has(i.id));
          const interestsArray = allEntries.filter(i => !builtInIds.has(i.id));
          // Auto-cleanup duplicates from Firebase
          if (duplicates.length > 0) {
            console.log('[CLEANUP] Removing', duplicates.length, 'built-in duplicates from customInterests');
            duplicates.forEach(d => database.ref(`customInterests/${d.firebaseId}`).remove());
          }
          setCustomInterests(interestsArray);
          console.log('[FIREBASE] Loaded', interestsArray.length, 'interests');
        } else {
          setCustomInterests([]);
        }
        markLoaded('interests');
      });
      
      return () => interestsRef.off('value', unsubscribe);
    } else {
      try {
        const customInts = localStorage.getItem('bangkok_custom_interests');
        if (customInts) {
          setCustomInterests(JSON.parse(customInts));
        }
      } catch (e) {
        console.error('[LOCALSTORAGE] Error loading interests:', e);
      }
      markLoaded('interests');
    }
  }, []);

  // Load interest search configurations from Firebase
  useEffect(() => {
    // Default configurations
    const defaultConfig = {
      temples: { types: ['hindu_temple', 'buddhist_temple', 'church', 'mosque'], blacklist: ['hotel', 'restaurant', 'school'] },
      food: { types: ['restaurant', 'meal_takeaway'], blacklist: ['bar', 'pub', 'club', 'hotel', 'hostel'] },
      graffiti: { textSearch: 'street art', blacklist: ['tattoo', 'ink', 'piercing', 'salon'] },
      artisans: { types: ['store', 'art_gallery'], blacklist: ['cannabis', 'weed', 'kratom', 'massage', 'spa', '7-eleven', 'convenience'] },
      galleries: { types: ['art_gallery', 'museum'], blacklist: ['cannabis', 'weed', 'kratom', 'massage', 'spa', 'cafe', 'coffee', 'hotel'] },
      architecture: { types: ['historical_landmark'], blacklist: ['hotel', 'restaurant', 'mall', 'parking'] },
      canals: { types: ['boat_tour_agency', 'marina'], blacklist: ['hotel', 'restaurant', 'parking'] },
      cafes: { types: ['cafe', 'coffee_shop'], blacklist: ['cannabis', 'weed', 'kratom', 'hookah', 'shisha'] },
      markets: { types: ['market', 'shopping_mall'], blacklist: ['hotel', 'supermarket', '7-eleven', 'convenience', 'tesco', 'big c', 'makro'] },
      nightlife: { types: ['bar', 'night_club'], blacklist: ['restaurant', 'hotel', 'hostel', 'cafe'] },
      parks: { types: ['park', 'national_park'], blacklist: ['hotel', 'parking', 'car park', 'garage', 'water park'] },
      rooftop: { types: ['bar', 'restaurant'], blacklist: ['parking', 'car park', 'garage'] },
      entertainment: { types: ['movie_theater', 'amusement_park', 'performing_arts_theater'], blacklist: ['hotel', 'mall'] },
      // Uncovered interests (inactive by default)
      massage_spa: { types: ['spa', 'massage'], blacklist: ['cannabis', 'weed', 'kratom', 'hotel'] },
      fitness: { types: ['gym', 'fitness_center', 'sports_club'], blacklist: ['hotel', 'hostel', 'physiotherapy'] },
      shopping_special: { types: ['clothing_store', 'jewelry_store', 'shoe_store'], blacklist: ['market', 'wholesale', 'pawn'] },
      learning: { types: ['school', 'university'], blacklist: ['kindergarten', 'nursery', 'daycare', 'driving school'] },
      health: { types: ['pharmacy', 'hospital', 'doctor'], blacklist: ['veterinary', 'pet'] },
      accommodation: { types: ['hotel', 'lodging'], blacklist: [] },
      transport: { types: ['car_rental', 'transit_station'], blacklist: [] },
      business: { types: ['coworking_space'], blacklist: ['hotel', 'hostel'] },
    };
    
    if (isFirebaseAvailable && database) {
      const configRef = database.ref('settings/interestConfig');
      
      configRef.once('value').then((snapshot) => {
        const data = snapshot.val();
        if (data) {
          // Deep merge: for each interest, use Firebase config but fall back to default blacklist if empty
          const merged = { ...defaultConfig };
          for (const [key, val] of Object.entries(data)) {
            if (merged[key]) {
              merged[key] = { ...merged[key], ...val };
              // If Firebase has empty blacklist but default has values, keep default
              if ((!val.blacklist || val.blacklist.length === 0) && defaultConfig[key]?.blacklist?.length > 0) {
                merged[key].blacklist = defaultConfig[key].blacklist;
              }
            } else {
              merged[key] = val;
            }
          }
          setInterestConfig(merged);
          console.log('[FIREBASE] Loaded interest config (deep merge)');
        } else {
          // Save defaults to Firebase
          configRef.set(defaultConfig);
          setInterestConfig(defaultConfig);
          console.log('[FIREBASE] Saved default interest config');
        }
        markLoaded('config');
      });
      
      // Listen for changes
      configRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const merged = { ...defaultConfig };
          for (const [key, val] of Object.entries(data)) {
            if (merged[key]) {
              merged[key] = { ...merged[key], ...val };
              if ((!val.blacklist || val.blacklist.length === 0) && defaultConfig[key]?.blacklist?.length > 0) {
                merged[key].blacklist = defaultConfig[key].blacklist;
              }
            } else {
              merged[key] = val;
            }
          }
          setInterestConfig(merged);
        }
      });
    } else {
      setInterestConfig(defaultConfig);
      markLoaded('config');
    }
  }, []);

  // Load interest active/inactive status (per-user with admin defaults)
  useEffect(() => {
    // Default status: built-in = active, uncovered = inactive
    const builtInIds = interestOptions.map(i => i.id);
    const uncoveredIds = uncoveredInterests.map(i => i.id || i.name.replace(/\s+/g, '_').toLowerCase());
    
    const defaultStatus = {};
    builtInIds.forEach(id => { defaultStatus[id] = true; });
    uncoveredIds.forEach(id => { defaultStatus[id] = false; });
    
    if (isFirebaseAvailable && database) {
      const userId = localStorage.getItem('bangkok_user_id') || 'unknown';
      const adminStatusRef = database.ref('settings/interestStatus');
      const userStatusRef = database.ref(`users/${userId}/interestStatus`);
      
      // Load admin defaults first, then user overrides
      adminStatusRef.once('value').then((adminSnap) => {
        const adminData = adminSnap.val() || defaultStatus;
        // Save admin defaults if not present
        if (!adminSnap.val()) {
          adminStatusRef.set(defaultStatus);
        }
        
        return userStatusRef.once('value').then((userSnap) => {
          const userData = userSnap.val();
          if (userData) {
            // User has their own preferences
            setInterestStatus({ ...defaultStatus, ...adminData, ...userData });
            console.log('[FIREBASE] Loaded user interest status');
          } else {
            // New user - use admin defaults
            setInterestStatus({ ...defaultStatus, ...adminData });
            console.log('[FIREBASE] Using admin defaults for new user');
          }
          markLoaded('status');
        });
      }).catch(err => {
        console.error('[FIREBASE] Error loading interest status:', err);
        setInterestStatus(defaultStatus);
        markLoaded('status');
      });
      
      // Listen for user's own changes
      userStatusRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          setInterestStatus(prev => ({ ...prev, ...data }));
        }
      });
    } else {
      try {
        const saved = localStorage.getItem('bangkok_interest_status');
        if (saved) {
          setInterestStatus({ ...defaultStatus, ...JSON.parse(saved) });
        } else {
          setInterestStatus(defaultStatus);
        }
      } catch (e) {
        setInterestStatus(defaultStatus);
      }
      markLoaded('status');
    }
  }, []);

  // ============================================================
  // Refresh All Data - Manual reload from Firebase & localStorage
  // ============================================================
  const refreshAllData = async () => {
    setIsRefreshing(true);
    console.log('[REFRESH] Starting full data refresh...');
    
    try {
      // 1. Saved Routes
      if (isFirebaseAvailable && database) {
        try {
          const routeSnap = await database.ref(`cities/${selectedCityId}/routes`).once('value');
          const routeData = routeSnap.val();
          if (routeData) {
            const routesArray = Object.keys(routeData).map(key => ({
              ...routeData[key],
              firebaseId: key
            }));
            setSavedRoutes(routesArray);
            console.log('[REFRESH] Loaded', routesArray.length, 'saved routes from Firebase');
          } else {
            setSavedRoutes([]);
          }
        } catch (e) {
          console.error('[REFRESH] Error loading saved routes:', e);
        }
      } else {
        try {
          const saved = localStorage.getItem('bangkok_saved_routes');
          if (saved) {
            setSavedRoutes(JSON.parse(saved));
            console.log('[REFRESH] Saved routes loaded from localStorage');
          }
        } catch (e) {
          console.error('[REFRESH] Error loading saved routes:', e);
        }
      }
      
      if (isFirebaseAvailable && database) {
        // 2. Custom Locations
        try {
          const locSnap = await database.ref(`cities/${selectedCityId}/locations`).once('value');
          const locData = locSnap.val();
          if (locData) {
            const locationsArray = Object.keys(locData).map(key => ({
              ...locData[key],
              firebaseId: key,
              cityId: selectedCityId
            }));
            setCustomLocations(locationsArray);
            console.log('[REFRESH] Loaded', locationsArray.length, 'locations');
          } else {
            setCustomLocations([]);
          }
        } catch (e) {
          console.error('[REFRESH] Error loading locations:', e);
        }
        
        // 3. Custom Interests
        try {
          const intSnap = await database.ref('customInterests').once('value');
          const intData = intSnap.val();
          if (intData) {
            const builtInIds = new Set([...window.BKK.interestOptions.map(i => i.id), ...window.BKK.uncoveredInterests.map(i => i.id)]);
            const interestsArray = Object.keys(intData).map(key => ({
              ...intData[key],
              firebaseId: key
            })).filter(i => !builtInIds.has(i.id));
            setCustomInterests(interestsArray);
            console.log('[REFRESH] Loaded', interestsArray.length, 'interests');
          } else {
            setCustomInterests([]);
          }
        } catch (e) {
          console.error('[REFRESH] Error loading interests:', e);
        }
        
        // 4. Interest Config
        try {
          const configSnap = await database.ref('settings/interestConfig').once('value');
          const configData = configSnap.val();
          if (configData) {
            setInterestConfig(prev => ({ ...prev, ...configData }));
            console.log('[REFRESH] Loaded interest config');
          }
        } catch (e) {
          console.error('[REFRESH] Error loading interest config:', e);
        }
        
        // 5. Interest Status
        try {
          const statusSnap = await database.ref('settings/interestStatus').once('value');
          const statusData = statusSnap.val();
          if (statusData) {
            const builtInIds = interestOptions.map(i => i.id);
            const uncoveredIds = uncoveredInterests.map(i => i.id || i.name.replace(/\s+/g, '_').toLowerCase());
            const defaultStatus = {};
            builtInIds.forEach(id => { defaultStatus[id] = true; });
            uncoveredIds.forEach(id => { defaultStatus[id] = false; });
            setInterestStatus({ ...defaultStatus, ...statusData });
            console.log('[REFRESH] Loaded interest status');
          }
        } catch (e) {
          console.error('[REFRESH] Error loading interest status:', e);
        }
        
        // 6. Admin Settings
        try {
          const pwSnap = await database.ref('settings/adminPassword').once('value');
          setAdminPassword(pwSnap.val() || '');
          
          const usersSnap = await database.ref('settings/adminUsers').once('value');
          const usersData = usersSnap.val() || {};
          const usersList = Object.entries(usersData).map(([oderId, data]) => ({
            oderId,
            ...data
          }));
          setAdminUsers(usersList);
          
          const userId = localStorage.getItem('bangkok_user_id');
          const isInAdminList = usersList.some(u => u.oderId === userId);
          const passwordEmpty = !pwSnap.val();
          const noAdminListExists = usersList.length === 0;
          const userIsAdmin = isInAdminList || (passwordEmpty && noAdminListExists);
          setIsUnlocked(userIsAdmin);
          setIsCurrentUserAdmin(userIsAdmin);
          console.log('[REFRESH] Loaded admin settings');
        } catch (e) {
          console.error('[REFRESH] Error loading admin settings:', e);
        }
        
        // 7. Google Max Waypoints setting + admin-controlled form settings
        try {
          const gmwSnap = await database.ref('settings/googleMaxWaypoints').once('value');
          if (gmwSnap.val() !== null) setGoogleMaxWaypoints(gmwSnap.val());
          const gmmSnap = await database.ref('settings/googleMaxMapPoints').once('value');
          if (gmmSnap.val() !== null) setGoogleMaxMapPoints(gmmSnap.val());
          const msSnap = await database.ref('settings/maxStops').once('value');
          const fmSnap = await database.ref('settings/fetchMoreCount').once('value');
          const drSnap = await database.ref('settings/defaultRadius').once('value');
          const updates = {};
          if (msSnap.val() !== null) updates.maxStops = msSnap.val();
          if (fmSnap.val() !== null) updates.fetchMoreCount = fmSnap.val();
          if (drSnap.val() !== null) window.BKK._defaultRadius = drSnap.val();
          if (Object.keys(updates).length > 0) {
            setFormData(prev => ({...prev, ...updates}));
          }
          console.log('[REFRESH] Loaded settings:', { googleMaxWaypoints: gmwSnap.val() || 12, googleMaxMapPoints: gmmSnap.val() || 10, ...updates });
        } catch (e) {
          console.error('[REFRESH] Error loading settings:', e);
        }
        
        showToast(t('toast.dataRefreshed'), 'success');
      } else {
        // Firebase not available - load from localStorage fallbacks
        try {
          const customLocs = localStorage.getItem('bangkok_custom_locations');
          if (customLocs) setCustomLocations(JSON.parse(customLocs));
        } catch (e) {}
        try {
          const customInts = localStorage.getItem('bangkok_custom_interests');
          if (customInts) setCustomInterests(JSON.parse(customInts));
        } catch (e) {}
        try {
          const saved = localStorage.getItem('bangkok_interest_status');
          if (saved) {
            const builtInIds = interestOptions.map(i => i.id);
            const uncoveredIds = uncoveredInterests.map(i => i.id || i.name.replace(/\s+/g, '_').toLowerCase());
            const defaultStatus = {};
            builtInIds.forEach(id => { defaultStatus[id] = true; });
            uncoveredIds.forEach(id => { defaultStatus[id] = false; });
            setInterestStatus({ ...defaultStatus, ...JSON.parse(saved) });
          }
        } catch (e) {}
        
        showToast(t('toast.dataRefreshedLocal'), 'warning');
      }
    } catch (error) {
      console.error('[REFRESH] Unexpected error:', error);
      showToast(t('toast.refreshError'), 'error');
    } finally {
      setIsRefreshing(false);
      console.log('[REFRESH] Complete');
    }
  };

  // Save routeType to localStorage when it changes
  useEffect(() => {
    localStorage.setItem('bangkok_route_type', routeType);
  }, [routeType]);

  // Access Log System - Track visits
  useEffect(() => {
    if (!isFirebaseAvailable || !database) return;
    
    // Generate or retrieve user ID
    let userId = localStorage.getItem('bangkok_user_id');
    if (!userId) {
      userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
      localStorage.setItem('bangkok_user_id', userId);
    }
    
    console.log('[ACCESS LOG] User ID:', userId);
    
    // Admin detection: Password-based system
    const loadAdminSettings = async () => {
      try {
        // Load admin password
        const pwSnapshot = await database.ref('settings/adminPassword').once('value');
        const storedPassword = pwSnapshot.val() || '';
        setAdminPassword(storedPassword);
        
        // Load admin users list
        const usersSnapshot = await database.ref('settings/adminUsers').once('value');
        const usersData = usersSnapshot.val() || {};
        const usersList = Object.entries(usersData).map(([oderId, data]) => ({
          oderId,
          ...data
        }));
        setAdminUsers(usersList);
        
        // Check if user is admin: must be in admin list
        // Only if NO admin list AND NO password (first-time setup), allow access
        const isInAdminList = usersList.some(u => u.oderId === userId);
        const passwordEmpty = !storedPassword || storedPassword === '';
        const noAdminListExists = usersList.length === 0;
        const userIsAdmin = isInAdminList || (passwordEmpty && noAdminListExists);
        
        setIsUnlocked(userIsAdmin);
        setIsCurrentUserAdmin(userIsAdmin);
        localStorage.setItem('bangkok_is_admin', userIsAdmin ? 'true' : 'false');
        
        console.log('[ADMIN] Password empty:', passwordEmpty, 'In list:', isInAdminList, 'Unlocked:', userIsAdmin);
      } catch (err) {
        console.error('[ADMIN] Error loading settings:', err);
      }
    };
    
    loadAdminSettings();
    
    // Listen to admin settings changes
    database.ref('settings/adminPassword').on('value', (snap) => {
      const pw = snap.val() || '';
      setAdminPassword(pw);
      const cachedUserId = localStorage.getItem('bangkok_user_id');
      database.ref('settings/adminUsers').once('value').then(usersSnap => {
        const usersData = usersSnap.val() || {};
        const isInList = Object.keys(usersData).includes(cachedUserId);
        setIsUnlocked(isInList || !pw);
      });
    });
    
    database.ref('settings/adminUsers').on('value', (snap) => {
      const usersData = snap.val() || {};
      const usersList = Object.entries(usersData).map(([oderId, data]) => ({
        oderId,
        ...data
      }));
      setAdminUsers(usersList);
    });
    
    // Listen for googleMaxWaypoints changes
    database.ref('settings/googleMaxWaypoints').on('value', (snap) => {
      if (snap.val() !== null) setGoogleMaxWaypoints(snap.val());
    });
    
    // Listen for googleMaxMapPoints changes
    database.ref('settings/googleMaxMapPoints').on('value', (snap) => {
      if (snap.val() !== null) setGoogleMaxMapPoints(snap.val());
    });
    
    // Listen for maxStops changes (admin setting)
    database.ref('settings/maxStops').on('value', (snap) => {
      if (snap.val() !== null) setFormData(prev => ({...prev, maxStops: snap.val()}));
    });
    
    // Listen for fetchMoreCount changes (admin setting)
    database.ref('settings/fetchMoreCount').on('value', (snap) => {
      if (snap.val() !== null) setFormData(prev => ({...prev, fetchMoreCount: snap.val()}));
    });
    
    // Listen for defaultRadius changes (admin setting) - only apply if user hasn't customized
    database.ref('settings/defaultRadius').on('value', (snap) => {
      if (snap.val() !== null) {
        // Store globally for first-time users
        window.BKK._defaultRadius = snap.val();
      }
    });
    
    // Load admin-controlled settings and apply to formData
    const loadAdminControlledSettings = async () => {
      try {
        const [msSnap, fmSnap, drSnap] = await Promise.all([
          database.ref('settings/maxStops').once('value'),
          database.ref('settings/fetchMoreCount').once('value'),
          database.ref('settings/defaultRadius').once('value')
        ]);
        const updates = {};
        if (msSnap.val() !== null) updates.maxStops = msSnap.val();
        if (fmSnap.val() !== null) updates.fetchMoreCount = fmSnap.val();
        // defaultRadius: only apply if user has no saved preferences (first time)
        const hasSavedPrefs = !!localStorage.getItem('bangkok_preferences');
        if (drSnap.val() !== null) {
          window.BKK._defaultRadius = drSnap.val();
          if (!hasSavedPrefs) updates.radiusMeters = drSnap.val();
        }
        if (Object.keys(updates).length > 0) {
          setFormData(prev => ({...prev, ...updates}));
        }
        console.log('[SETTINGS] Loaded admin settings:', updates);
      } catch (e) {
        console.error('[SETTINGS] Error loading admin settings:', e);
      }
    };
    loadAdminControlledSettings();
    
    // Log access (skip if admin)
    const isAdmin = localStorage.getItem('bangkok_is_admin') === 'true';
    
    if (!isAdmin) {
      const lastLogTime = parseInt(localStorage.getItem('bangkok_last_log_time') || '0');
      const oneHour = 60 * 60 * 1000;
      
      if (Date.now() - lastLogTime >= oneHour) {
        localStorage.setItem('bangkok_last_log_time', Date.now().toString());
        
        const { browser, os } = window.BKK.parseUserAgent(navigator.userAgent);
        
        const accessEntry = {
          userId, 
          timestamp: Date.now(), 
          date: new Date().toISOString(),
          userAgent: navigator.userAgent.substring(0, 100),
          browser, 
          os,
          screenSize: `${screen.width}x${screen.height}`,
          language: navigator.language || 'unknown',
          country: '', 
          city: '', 
          region: ''
        };
        
        const entryRef = database.ref('accessLog').push();
        entryRef.set(accessEntry)
          .then(() => {
            console.log('[ACCESS LOG] Visit logged');
            fetch('https://ipapi.co/json/')
              .then(r => r.json())
              .then(geo => {
                entryRef.update({
                  country: geo.country_name || '',
                  countryCode: geo.country_code || '',
                  city: geo.city || '',
                  region: geo.region || '',
                  ip: geo.ip ? geo.ip.substring(0, 12) + '***' : '',
                  isp: geo.org || ''
                });
              })
              .catch(err => console.log('[ACCESS LOG] Geo lookup failed:', err));
          })
          .catch(err => console.error('[ACCESS LOG] Error:', err));
      }
    }
    
    // Listen to access log (admin only)
    if (isAdmin) {
      const logRef = database.ref('accessLog').orderByChild('timestamp').limitToLast(50);
      const lastSeen = parseInt(localStorage.getItem('bangkok_last_seen') || '0');
      
      const unsubscribe = logRef.on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const logsArray = Object.keys(data).map(key => ({
            ...data[key], 
            id: key
          })).sort((a, b) => b.timestamp - a.timestamp);
          
          setAccessLogs(logsArray);
          
          const hasNew = logsArray.some(log => log.timestamp > lastSeen);
          if (hasNew && lastSeen > 0) {
            setHasNewEntries(true);
          }
        } else {
          setAccessLogs([]);
        }
      });
      
      return () => logRef.off('value', unsubscribe);
    }
  }, []);

  // Mark logs as seen
  const markLogsAsSeen = () => {
    const latest = accessLogs.length > 0 ? accessLogs[0].timestamp : Date.now();
    localStorage.setItem('bangkok_last_seen', latest.toString());
    setHasNewEntries(false);
  };

  // Feedback System
  const submitFeedback = () => {
    if (!feedbackText.trim()) {
      showToast(t('settings.writeFeedback'), 'warning');
      return;
    }
    
    const feedbackEntry = {
      category: feedbackCategory,
      text: feedbackText.trim(),
      userId: localStorage.getItem('bangkok_user_id') || 'unknown',
      currentView: currentView,
      timestamp: Date.now(),
      date: new Date().toISOString(),
      resolved: false
    };
    
    if (isFirebaseAvailable && database) {
      database.ref('feedback').push(feedbackEntry)
        .then(() => {
          showToast(t('toast.feedbackThanks'), 'success');
          setFeedbackText('');
          setFeedbackCategory('general');
          setShowFeedbackDialog(false);
        })
        .catch(() => showToast(t('toast.sendError'), 'error'));
    } else {
      showToast(t('toast.firebaseUnavailable'), 'error');
    }
  };

  // Load feedback list (admin only)
  useEffect(() => {
    if (!isFirebaseAvailable || !database) return;
    if (!isCurrentUserAdmin) return;
    
    const feedbackRef = database.ref('feedback').orderByChild('timestamp').limitToLast(100);
    const lastSeenFeedback = parseInt(localStorage.getItem('bangkok_last_seen_feedback') || '0');
    
    const unsubscribe = feedbackRef.on('value', (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const arr = Object.keys(data).map(key => ({
          ...data[key],
          firebaseId: key
        })).sort((a, b) => b.timestamp - a.timestamp);
        setFeedbackList(arr);
        
        const hasNew = arr.some(f => f.timestamp > lastSeenFeedback);
        if (hasNew && lastSeenFeedback > 0) {
          setHasNewFeedback(true);
        }
      } else {
        setFeedbackList([]);
      }
    });
    
    return () => feedbackRef.off('value', unsubscribe);
  }, [isCurrentUserAdmin]);

  const markFeedbackAsSeen = () => {
    const latest = feedbackList.length > 0 ? feedbackList[0].timestamp : Date.now();
    localStorage.setItem('bangkok_last_seen_feedback', latest.toString());
    setHasNewFeedback(false);
  };

  const toggleFeedbackResolved = (feedbackItem) => {
    if (isFirebaseAvailable && database && feedbackItem.firebaseId) {
      database.ref(`feedback/${feedbackItem.firebaseId}`).update({
        resolved: !feedbackItem.resolved
      });
    }
  };

  const deleteFeedback = (feedbackItem) => {
    if (isFirebaseAvailable && database && feedbackItem.firebaseId) {
      database.ref(`feedback/${feedbackItem.firebaseId}`).remove()
        .then(() => showToast(t('toast.feedbackDeleted'), 'success'));
    }
  };

  // Config - loaded from config.js, re-read on city change via selectedCityId dependency
  const interestOptions = window.BKK.interestOptions || [];

  const interestToGooglePlaces = window.BKK.interestToGooglePlaces || {};

  const uncoveredInterests = window.BKK.uncoveredInterests || [];

  const interestTooltips = window.BKK.interestTooltips || {};

  const areaCoordinates = window.BKK.areaCoordinates || {};

  // Switch city function
  const switchCity = (cityId, stayOnView) => {
    if (cityId === selectedCityId) return;
    if (!window.BKK.cities[cityId]) return;
    
    window.BKK.selectCity(cityId);
    setSelectedCityId(cityId);
    localStorage.setItem('city_explorer_city', cityId);
    
    // Reset form data for new city, but preserve user settings
    const firstArea = window.BKK.areaOptions[0]?.id || '';
    setFormData(prev => ({
      hours: 3, area: firstArea, interests: [], circular: true, startPoint: '',
      maxStops: prev.maxStops || 12, fetchMoreCount: prev.fetchMoreCount || 3, searchMode: 'area',
      radiusMeters: prev.radiusMeters || 500, radiusSource: 'gps', radiusPlaceId: null, radiusPlaceName: '',
      gpsLat: null, gpsLng: null, currentLat: null, currentLng: null
    }));
    setRoute(null);
    setWizardStep(1);
    if (!stayOnView) {
      setCurrentView('form');
      window.scrollTo(0, 0);
    }
    setDisabledStops([]);
    setShowRoutePreview(false);
    setManualStops([]);
    setCityModified(false);
    showToast(window.BKK.selectedCity.icon + ' ' + tLabel(window.BKK.selectedCity), 'success');
  };

  const switchLanguage = (lang) => {
    if (lang === currentLang) return;
    window.BKK.i18n.setLang(lang);
    setCurrentLang(lang);
  };
  
  // Utility functions - loaded from utils.js
  const checkLocationInArea = window.BKK.checkLocationInArea;
  const getButtonStyle = window.BKK.getButtonStyle;

  // Text Search URL
  const GOOGLE_PLACES_TEXT_SEARCH_URL = window.BKK.GOOGLE_PLACES_TEXT_SEARCH_URL || 'https://places.googleapis.com/v1/places:searchText';

  // Calculate distance between two coordinates in meters (Haversine)
  const calcDistance = (lat1, lng1, lat2, lng2) => {
    const R = 6371e3;
    const r1 = lat1 * Math.PI / 180;
    const r2 = lat2 * Math.PI / 180;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2)**2 + Math.cos(r1)*Math.cos(r2)*Math.sin(dLng/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  };

  // Detect which area a coordinate belongs to (returns areaId or null)
  const detectAreaFromCoords = (lat, lng) => {
    const coords = window.BKK.areaCoordinates;
    let closest = null;
    let closestDist = Infinity;
    
    for (const [areaId, center] of Object.entries(coords)) {
      const check = checkLocationInArea(lat, lng, areaId);
      if (check.valid && check.distance < closestDist) {
        closest = areaId;
        closestDist = check.distance;
      }
    }
    return closest;
  };

  const fetchGooglePlaces = async (area, interests, radiusOverride) => {
    // radiusOverride: { lat, lng, radius } for radius mode
    let center, searchRadius;
    
    if (radiusOverride) {
      center = { lat: radiusOverride.lat, lng: radiusOverride.lng };
      searchRadius = radiusOverride.radius;
    } else {
      const areaCenter = areaCoordinates[area];
      if (!areaCenter) {
        addDebugLog('API', `No coordinates for area: ${area}`);
        console.error('[DYNAMIC] No coordinates for area:', area);
        return [];
      }
      center = { lat: areaCenter.lat, lng: areaCenter.lng };
      searchRadius = areaCenter.radius || 2000;
    }

    // Filter out invalid interests (those without search config)
    const validInterests = interests.filter(id => isInterestValid(id));
    if (validInterests.length === 0) {
      const names = interests.map(id => allInterestOptions.find(o => o.id === id)).filter(Boolean).map(o => tLabel(o) || o?.id || id).join(', ');
      addDebugLog('API', `No valid config for: ${names}`);
      console.warn('[DYNAMIC] No valid interests - all are missing search config:', names);
      return [];
    }
    
    if (validInterests.length < interests.length) {
      const skipped = interests.filter(id => !isInterestValid(id));
      const skippedNames = skipped.map(id => allInterestOptions.find(o => o.id === id)).filter(Boolean).map(o => tLabel(o) || o?.id || id).join(', ');
      addDebugLog('API', `Skipped interests without config: ${skippedNames}`);
      console.warn('[DYNAMIC] Skipped invalid interests:', skippedNames);
    }

    try {
      // Get config for the first valid interest (primary)
      const primaryInterest = validInterests[0];
      
      // Check if this interest has direct config or through baseCategory
      let config = interestConfig[primaryInterest];
      if (!config) {
        const customInterest = customInterests.find(ci => ci.id === primaryInterest);
        if (customInterest?.baseCategory) {
          config = interestConfig[customInterest.baseCategory] || {};
        } else {
          config = {};
        }
      }
      
      // Check if this interest uses text search (Firebase config first, then city defaults)
      const textSearchQuery = config.textSearch || (window.BKK.textSearchInterests || {})[validInterests[0]] || '';
      
      // Collect blacklist words from all valid interests
      const blacklistWords = validInterests
        .flatMap(interest => {
          const directConfig = interestConfig[interest];
          if (directConfig?.blacklist) return directConfig.blacklist;
          const ci = customInterests.find(c => c.id === interest);
          if (ci?.baseCategory) return interestConfig[ci.baseCategory]?.blacklist || [];
          return [];
        })
        .map(word => word.toLowerCase());
      
      let response;
      let placeTypes = [];
      
      if (textSearchQuery) {
        // Use Text Search API for interests like "graffiti" -> "street art"
        const areaName = area ? (areaOptions.find(a => a.id === area)?.labelEn || area) : '';
        const cityName = window.BKK.cityNameForSearch || 'Bangkok';
        const searchQuery = `${textSearchQuery} ${areaName} ${cityName}`.trim();
        
        addDebugLog('API', `Text Search`, { query: searchQuery, area });
        console.log('[DYNAMIC] Using Text Search:', searchQuery);
        
        response = await fetch(GOOGLE_PLACES_TEXT_SEARCH_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount,places.types,places.primaryType,places.currentOpeningHours'
          },
          body: JSON.stringify({
            textQuery: searchQuery,
            maxResultCount: 20,
            locationBias: {
              circle: {
                center: {
                  latitude: center.lat,
                  longitude: center.lng
                },
                radius: searchRadius
              }
            }
          })
        });
      } else {
        // Use Nearby Search API with types from interestConfig
        placeTypes = [...new Set(
          validInterests.flatMap(interest => {
            // First check if this interest has direct config
            if (interestConfig[interest]?.types) {
              return interestConfig[interest].types;
            }
            // Fallback to baseCategory if it's a custom interest
            const customInterest = customInterests.find(ci => ci.id === interest);
            if (customInterest?.baseCategory && interestConfig[customInterest.baseCategory]?.types) {
              return interestConfig[customInterest.baseCategory].types;
            }
            // Fallback to interestToGooglePlaces
            return interestToGooglePlaces[interest] || interestToGooglePlaces[customInterest?.baseCategory] || ['point_of_interest'];
          })
        )];

        addDebugLog('API', `Fetching Google Places`, { area, validInterests, placeTypes: placeTypes.slice(0, 10), center });
        console.log('[DYNAMIC] Fetching from Google Places API:', { area, validInterests });

        response = await fetch(GOOGLE_PLACES_API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount,places.types,places.primaryType,places.currentOpeningHours'
          },
          body: JSON.stringify({
            includedTypes: placeTypes.slice(0, 10),
            maxResultCount: 20,
            locationRestriction: {
              circle: {
                center: {
                  latitude: center.lat,
                  longitude: center.lng
                },
                radius: searchRadius
              }
            },
            rankPreference: radiusOverride ? 'DISTANCE' : 'POPULARITY'
          })
        });
      }

      console.log('[DYNAMIC] Google Places Response:', { 
        status: response.status, 
        ok: response.ok,
        statusText: response.statusText
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('[DYNAMIC] Error fetching Google Places:', {
          status: response.status,
          error: errorText,
          area,
          placeTypes
        });
        
        // Handle 400 Unsupported types - retry without bad types
        if (response.status === 400 && errorText.includes('Unsupported types') && !isTextSearch && placeTypes.length > 1) {
          console.warn('[DYNAMIC] Unsupported types detected, retrying one type at a time...');
          let allRetryPlaces = [];
          for (const singleType of placeTypes) {
            try {
              const retryResponse = await fetch(GOOGLE_PLACES_API_URL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
                  'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount,places.types,places.primaryType,places.currentOpeningHours'
                },
                body: JSON.stringify({
                  includedTypes: [singleType],
                  maxResultCount: 20,
                  locationRestriction: {
                    circle: {
                      center: { latitude: center.lat, longitude: center.lng },
                      radius: searchRadius
                    }
                  }
                })
              });
              if (retryResponse.ok) {
                const retryData = await retryResponse.json();
                if (retryData.places) {
                  allRetryPlaces.push(...retryData.places);
                  console.log(`[DYNAMIC] Retry success for type: ${singleType}, got ${retryData.places.length} places`);
                }
              } else {
                const interestNames = validInterests.map(id => allInterestOptions.find(o => o.id === id)).filter(Boolean).map(o => tLabel(o) || o?.id || id).join(', ');
                addDebugLog('API', `Type "${singleType}" not supported by Google (${interestNames})`);
                console.warn(`[DYNAMIC] Type "${singleType}" not supported, skipping`);
              }
            } catch (retryErr) {
              console.warn(`[DYNAMIC] Retry failed for type: ${singleType}`, retryErr);
            }
          }
          if (allRetryPlaces.length > 0) {
            // Process retry results - jump to processing section
            const data = { places: allRetryPlaces };
            response = { ok: true }; // Fake ok response
            // Continue with processing below using data
            const isTextSearchRetry = false;
            const textSearchPhraseRetry = '';
            let typeFilteredCountRetry = 0;
            let blacklistFilteredCountRetry = 0;
            let relevanceFilteredCountRetry = 0;
            
            const places = data.places.map(place => {
              const name = place.displayName?.text || 'Unknown';
              const placeTypesFromGoogle = place.types || [];
              const openingHours = place.currentOpeningHours;
              const todayIndex = new Date().getDay();
              const googleDayIndex = todayIndex === 0 ? 6 : todayIndex - 1;
              const todayHours = openingHours?.weekdayDescriptions?.[googleDayIndex] || '';
              const hoursOnly = todayHours.includes(':') ? todayHours.substring(todayHours.indexOf(':') + 1).trim() : todayHours;
              return {
                name,
                description: place.formattedAddress || '',
                address: place.formattedAddress || '',
                lat: place.location?.latitude || 0,
                lng: place.location?.longitude || 0,
                rating: place.rating || 0,
                ratingCount: place.userRatingCount || 0,
                duration: 45,
                interests: validInterests,
                googleTypes: placeTypesFromGoogle,
                primaryType: place.primaryType || null,
                googlePlaceId: place.id || null,
                openNow: openingHours?.openNow ?? null,
                todayHours: hoursOnly || '',
                custom: false
              };
            }).filter(place => place.lat !== 0 && place.lng !== 0);
            
            addDebugLog('API', `Got ${places.length} results from retry`, { names: places.slice(0, 5).map(p => p.name) });
            return places;
          }
          return []; // No results from any type
        }
        
        throw new Error(`Google API Error ${response.status}: ${errorText}`);
      }

      const data = await response.json();
      
      console.log('[DYNAMIC] Google Places Response:', {
        area,
        interests,
        placeTypes,
        foundPlaces: data.places?.length || 0
      });
      
      if (!data.places) {
        console.warn('[DYNAMIC] No places found in response');
        return [];
      }

      // Check if this was a text search
      const isTextSearch = !!textSearchQuery;
      
      // For text search: use the full query phrase for relevance filtering
      const textSearchPhrase = isTextSearch ? textSearchQuery.toLowerCase().trim() : '';
      
      // Filter and transform Google Places data
      let typeFilteredCount = 0;
      let blacklistFilteredCount = 0;
      let relevanceFilteredCount = 0;
      
      const transformed = data.places
        .filter(place => {
          const placeName = (place.displayName?.text || '').toLowerCase();
          const placeTypesFromGoogle = place.types || [];
          
          // Filter 1: Blacklist check - filter out places with blacklisted words in name
          if (blacklistWords.length > 0) {
            const isBlacklisted = blacklistWords.some(word => placeName.includes(word));
            if (isBlacklisted) {
              blacklistFilteredCount++;
              console.log('[DYNAMIC] ‚ùå Filtered out (blacklist):', {
                name: place.displayName?.text,
                matchedWord: blacklistWords.find(word => placeName.includes(word))
              });
              return false;
            }
          }
          
          // Filter 2: For text search - relevance check
          // Place name must contain the FULL search phrase (e.g. "street art")
          if (isTextSearch && textSearchPhrase) {
            const nameHasPhrase = placeName.includes(textSearchPhrase);
            
            if (!nameHasPhrase) {
              relevanceFilteredCount++;
              console.log('[DYNAMIC] ‚ùå Filtered out (text search irrelevant):', {
                name: place.displayName?.text,
                searchPhrase: textSearchPhrase
              });
              return false;
            }
          }
          
          // Filter 3: Type validation - for category search only
          if (!isTextSearch && placeTypes.length > 0) {
            const placeTypesFromGoogle = place.types || [];
            const hasValidType = placeTypesFromGoogle.some(type => placeTypes.includes(type));
            
            if (!hasValidType) {
              typeFilteredCount++;
              console.log('[DYNAMIC] ‚ùå Filtered out (invalid type):', {
                name: place.displayName?.text,
                googleTypes: placeTypesFromGoogle,
                expectedTypes: placeTypes
              });
              return false;
            }
          }
          
          console.log('[DYNAMIC] ‚úÖ Kept:', {
            name: place.displayName?.text,
            isTextSearch
          });
          
          return true;
        })
        .map((place, index) => {
          // Extract today's opening hours
          const openingHours = place.currentOpeningHours;
          const todayIndex = new Date().getDay(); // 0=Sun, need to map to weekdayDescriptions (0=Mon in Google)
          const googleDayIndex = todayIndex === 0 ? 6 : todayIndex - 1; // Convert: Sun=6, Mon=0, Tue=1...
          const todayHours = openingHours?.weekdayDescriptions?.[googleDayIndex] || '';
          // Remove day name prefix (e.g. "Monday: 9:00 AM ‚Äì 5:00 PM" -> "9:00 AM ‚Äì 5:00 PM")
          const hoursOnly = todayHours.includes(':') ? todayHours.substring(todayHours.indexOf(':') + 1).trim() : todayHours;
          
          return {
            name: place.displayName?.text || 'Unknown Place',
            lat: place.location?.latitude || center.lat,
            lng: place.location?.longitude || center.lng,
            description: `‚≠ê ${place.rating?.toFixed(1) || 'N/A'} (${place.userRatingCount || 0} reviews)`,
            duration: 45,
            googlePlace: true,
            rating: place.rating || 0,
            ratingCount: place.userRatingCount || 0,
            googleTypes: place.types || [],
            primaryType: place.primaryType || '',
            googlePlaceId: place.id || null,
            address: place.formattedAddress || '',
            openNow: openingHours?.openNow ?? null,
            todayHours: hoursOnly || '',
            interests: interests
          };
        });
      
      console.log('[DYNAMIC] Filtering summary:', {
        received: data.places.length,
        typeFiltered: typeFilteredCount,
        blacklistFiltered: blacklistFilteredCount,
        relevanceFiltered: relevanceFilteredCount,
        beforeDistFilter: transformed.length
      });
      
      // Filter 4: Distance check - remove places too far from search center
      // Use per-area distanceMultiplier, fallback to city default, fallback to 1.2
      const areaConfig = areaCoordinates[area] || {};
      const distMultiplier = areaConfig.distanceMultiplier || window.BKK.selectedCity?.distanceMultiplier || 1.2;
      const maxDistance = searchRadius * distMultiplier;
      const distanceFiltered = transformed.filter(place => {
        const dist = calcDistance(center.lat, center.lng, place.lat, place.lng);
        if (dist > maxDistance) {
          console.log('[DYNAMIC] ‚ùå Filtered out (too far):', {
            name: place.name,
            distance: Math.round(dist) + 'm',
            maxAllowed: Math.round(maxDistance) + 'm'
          });
          return false;
        }
        return true;
      });
      
      if (distanceFiltered.length < transformed.length) {
        console.log(`[DYNAMIC] Distance filter removed ${transformed.length - distanceFiltered.length} far places`);
      }
      
      addDebugLog('API', `Got ${distanceFiltered.length} results (filtered ${blacklistFilteredCount} blacklist, ${typeFilteredCount} type, ${relevanceFilteredCount} irrelevant, ${transformed.length - distanceFiltered.length} too far)`, {
        names: distanceFiltered.slice(0, 5).map(p => p.name)
      });
      
      return distanceFiltered;
    } catch (error) {
      console.error('[DYNAMIC] Error fetching Google Places:', {
        error: error.message,
        stack: error.stack,
        area,
        interests
      });
      
      // Throw error to be handled by caller
      throw {
        type: 'GOOGLE_API_ERROR',
        message: error.message,
        details: { area, interests, stack: error.stack }
      };
    }
  };

  // Function to fetch Google Place info for a location
  const fetchGooglePlaceInfo = async (location) => {
    if (!location || (!location.lat && !location.name)) {
      showToast(t('places.notEnoughInfo'), 'error');
      return null;
    }
    
    setLoadingGoogleInfo(true);
    
    try {
      // Use Text Search to find the place
      const searchQuery = location.name + ' ' + (window.BKK.cityNameForSearch || 'Bangkok');
      
      const response = await fetch(GOOGLE_PLACES_TEXT_SEARCH_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
          'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount,places.types,places.primaryType,places.primaryTypeDisplayName,places.currentOpeningHours'
        },
        body: JSON.stringify({
          textQuery: searchQuery,
          maxResultCount: 5,
          locationBias: location.lat && location.lng ? {
            circle: {
              center: { latitude: location.lat, longitude: location.lng },
              radius: 1000.0
            }
          } : undefined
        })
      });
      
      if (!response.ok) {
        throw new Error('Google API error');
      }
      
      const data = await response.json();
      
      if (!data.places || data.places.length === 0) {
        setGooglePlaceInfo({ notFound: true, searchQuery });
        showToast(t('places.placeNotOnGoogle'), 'warning');
        return null;
      }
      
      // Find best match (closest to our coordinates if available)
      let bestMatch = data.places[0];
      
      if (location.lat && location.lng && data.places.length > 1) {
        const getDistance = (place) => {
          const lat = place.location?.latitude || 0;
          const lng = place.location?.longitude || 0;
          return Math.sqrt(Math.pow(lat - location.lat, 2) + Math.pow(lng - location.lng, 2));
        };
        
        bestMatch = data.places.reduce((best, place) => 
          getDistance(place) < getDistance(best) ? place : best
        );
      }
      
      const placeInfo = {
        name: bestMatch.displayName?.text,
        address: bestMatch.formattedAddress,
        types: bestMatch.types || [],
        primaryType: bestMatch.primaryType,
        primaryTypeDisplayName: bestMatch.primaryTypeDisplayName?.text,
        rating: bestMatch.rating,
        ratingCount: bestMatch.userRatingCount,
        location: bestMatch.location,
        googlePlaceId: bestMatch.id || null,
        allResults: data.places.map(p => ({
          name: p.displayName?.text,
          types: p.types,
          primaryType: p.primaryType
        }))
      };
      
      setGooglePlaceInfo(placeInfo);
      addDebugLog('API', 'Fetched Google Place Info', { name: placeInfo.name, types: placeInfo.types });
      
      return placeInfo;
    } catch (error) {
      console.error('Error fetching Google place info:', error);
      showToast(t('toast.googleInfoError'), 'error');
      return null;
    } finally {
      setLoadingGoogleInfo(false);
    }
  };

  // Combine all interests: built-in + uncovered + custom (city-filtered)
  const allInterestOptions = [...interestOptions, ...uncoveredInterests, ...(cityCustomInterests || [])].map(opt => {
    const config = interestConfig[opt.id];
    if (!config) return opt;
    return {
      ...opt,
      label: config.labelOverride || opt.label, labelEn: config.labelOverrideEn || opt.labelEn,
      icon: config.iconOverride || opt.icon,
      inProgress: config.inProgress !== undefined ? config.inProgress : opt.inProgress,
      locked: config.locked !== undefined ? config.locked : opt.locked
    };
  });

  // Save preferences whenever they change
  useEffect(() => {
    // Don't save if data hasn't loaded yet - prevents overwriting saved interests with empty state
    if (!isDataLoaded) return;
    localStorage.setItem('bangkok_preferences', JSON.stringify(formData));
  }, [formData, isDataLoaded]);

  // Version check - auto-check on load + manual check
  const checkForUpdates = async (silent = false) => {
    try {
      const response = await fetch('version.json?t=' + Date.now(), { cache: 'no-store' });
      if (!response.ok) return false;
      const data = await response.json();
      const serverVersion = data.version;
      const localVersion = window.BKK.VERSION;
      
      if (serverVersion && serverVersion !== localVersion) {
        console.log(`[UPDATE] New version available: ${serverVersion} (current: ${localVersion})`);
        setUpdateAvailable(true);
        if (!silent) {
          showToast(`${t("toast.newVersionAvailable")} ${serverVersion}`, 'success');
        }
        return true;
      } else {
        if (!silent) showToast(t('toast.appUpToDate'), 'success');
        return false;
      }
    } catch (e) {
      console.log('[UPDATE] Check failed:', e);
      if (!silent) showToast(t('toast.cannotCheckUpdates'), 'error');
      return false;
    }
  };

  const applyUpdate = () => {
    // Clear all caches and hard reload
    if ('caches' in window) {
      caches.keys().then(names => {
        names.forEach(name => caches.delete(name));
      });
    }
    window.location.reload(true);
  };

  // Auto-check for updates on load (silent)
  useEffect(() => {
    const timer = setTimeout(() => checkForUpdates(true), 5000);
    return () => clearTimeout(timer);
  }, []);

  // Save column width
  useEffect(() => {
    localStorage.setItem('bangkok_right_col_width', rightColWidth.toString());
  }, [rightColWidth]);

  // Sync editingLocation to newLocation when edit dialog opens
  useEffect(() => {
    if (showEditLocationDialog && editingLocation) {
      console.log('[useEffect] Syncing editingLocation to newLocation');
      setNewLocation({
        name: editingLocation.name || '',
        description: editingLocation.description || '',
        notes: editingLocation.notes || '',
        area: editingLocation.area || formData.area,
        interests: editingLocation.interests || [],
        lat: editingLocation.lat || null,
        lng: editingLocation.lng || null,
        mapsUrl: editingLocation.mapsUrl || '',
        address: editingLocation.address || '',
        uploadedImage: editingLocation.uploadedImage || null,
        imageUrls: editingLocation.imageUrls || [],
        inProgress: editingLocation.inProgress || false,
        locked: editingLocation.locked || false,
        areas: editingLocation.areas || (editingLocation.area ? [editingLocation.area] : [])
      });
    }
  }, [showEditLocationDialog, editingLocation]);

  const areaOptions = window.BKK.areaOptions || [];

  // Memoized lookup maps to avoid O(n) .find() calls in render loops
  const interestMap = useMemo(() => {
    try {
      const map = {};
      if (allInterestOptions) allInterestOptions.forEach(o => { if (o && o.id) map[o.id] = o; });
      return map;
    } catch(e) { console.error('[MEMO] interestMap error:', e); return {}; }
  }, [cityCustomInterests, allInterestOptions.length]);

  const areaMap = useMemo(() => {
    try {
      const map = {};
      if (areaOptions) areaOptions.forEach(o => { if (o && o.id) map[o.id] = o; });
      return map;
    } catch(e) { console.error('[MEMO] areaMap error:', e); return {}; }
  }, [areaOptions]);

  // City-filtered custom locations and saved routes
  const cityCustomLocations = useMemo(() => {
    return customLocations; // Already filtered per city by Firebase subscription
  }, [customLocations, selectedCityId]);

  const citySavedRoutes = useMemo(() => {
    return savedRoutes.filter(r => (r.cityId || 'bangkok') === selectedCityId);
  }, [savedRoutes, selectedCityId]);

  const cityCustomInterests = useMemo(() => {
    return (customInterests || []).filter(i => (i.cityId || 'bangkok') === selectedCityId);
  }, [customInterests, selectedCityId]);

  // Memoize expensive places grouping/sorting
  const groupedPlaces = useMemo(() => {
    try {
      if (!cityCustomLocations || cityCustomLocations.length === 0) {
        return { groups: {}, ungrouped: [], sortedKeys: [], activeCount: 0, blacklistedLocations: [] };
      }
      const activeLocations = cityCustomLocations.filter(loc => loc.status !== 'blacklist');
      const blacklistedLocations = cityCustomLocations.filter(loc => loc.status === 'blacklist');
      
      if (activeLocations.length === 0) return { groups: {}, ungrouped: [], sortedKeys: [], activeCount: 0, blacklistedLocations };
      
      const groups = {};
      const ungrouped = [];
      
      activeLocations.forEach(loc => {
        if (placesGroupBy === 'interest') {
          const interests = (loc.interests || []).filter(i => i !== '_manual');
          if (interests.length === 0) {
            ungrouped.push(loc);
          } else {
            interests.forEach(int => {
              if (!groups[int]) groups[int] = [];
              groups[int].push(loc);
            });
          }
        } else {
          const locAreas = loc.areas || (loc.area ? [loc.area] : ['unknown']);
          locAreas.forEach(areaId => {
            if (!groups[areaId]) groups[areaId] = [];
            groups[areaId].push(loc);
          });
        }
      });
      
      const sortedKeys = Object.keys(groups).sort((a, b) => {
        if (placesGroupBy === 'interest') {
          return (tLabel(interestMap[a]) || a).localeCompare(tLabel(interestMap[b]) || b);
        } else {
          return (tLabel(areaMap[a]) || a).localeCompare(tLabel(areaMap[b]) || b);
        }
      });
      
      const sortWithin = (locs) => [...locs].sort((a, b) => {
        if (placesGroupBy === 'interest') {
          const aArea = tLabel(areaMap[(a.areas || [a.area])[0]]) || '';
          const bArea = tLabel(areaMap[(b.areas || [b.area])[0]]) || '';
          return aArea.localeCompare(bArea, 'he') || a.name.localeCompare(b.name, 'he');
        } else {
          return (a.interests?.[0] || '').localeCompare(b.interests?.[0] || '') || a.name.localeCompare(b.name, 'he');
        }
      });
      
      const sortedGroups = {};
      sortedKeys.forEach(key => { sortedGroups[key] = sortWithin(groups[key]); });
      const sortedUngrouped = sortWithin(ungrouped);
      
      return { groups: sortedGroups, ungrouped: sortedUngrouped, sortedKeys, activeCount: activeLocations.length, blacklistedLocations };
    } catch(e) {
      console.error('[MEMO] groupedPlaces error:', e);
      return { groups: {}, ungrouped: [], sortedKeys: [], activeCount: 0, blacklistedLocations: [] };
    }
  }, [cityCustomLocations, placesGroupBy, interestMap, areaMap]);

  // Image handling - loaded from utils.js
  const uploadImage = window.BKK.uploadImage;
  
  const handleImageUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
      showToast(t('places.selectImageFile'), 'error');
      return;
    }
    
    try {
      showToast(t('toast.uploadingImage'), 'info');
      const locationId = newLocation.id || 'loc_' + Date.now();
      const imageUrl = await uploadImage(file, selectedCityId, locationId);
      setNewLocation(prev => ({ ...prev, uploadedImage: imageUrl }));
      showToast(t('toast.imageUploaded'), 'success');
    } catch (error) {
      console.error('[IMAGE] Upload error:', error);
      showToast(t('toast.imageUploadError'), 'error');
    }
  };

  const toggleInterest = (id) => {
    setFormData(prev => ({
      ...prev,
      interests: prev.interests.includes(id)
        ? prev.interests.filter(i => i !== id)
        : [...prev.interests, id]
    }));
  };

  // Auto-clean: remove selected interests that are no longer valid/visible
  // IMPORTANT: Only runs after initial data is loaded to prevent race condition
  // where saved interests get cleared before Firebase data arrives
  useEffect(() => {
    if (!isDataLoaded) return;
    if (formData.interests.length === 0) return;
    const visibleIds = allInterestOptions
      .filter(opt => opt && opt.id && isInterestValid(opt.id))
      .map(opt => opt.id);
    const cleaned = formData.interests.filter(id => visibleIds.includes(id));
    if (cleaned.length !== formData.interests.length) {
      const removed = formData.interests.filter(id => !visibleIds.includes(id));
      const removedNames = removed.map(id => allInterestOptions.find(o => o.id === id)).filter(Boolean).map(o => tLabel(o) || o?.id || id).join(', ');
      console.log('[CLEANUP] Removed invalid interests from selection:', removedNames);
      setFormData(prev => ({ ...prev, interests: cleaned }));
    }
  }, [interestConfig, cityCustomInterests, isDataLoaded]);

  // Button styles - loaded from utils.js

  const getStopsForInterests = () => {
    // Now we only collect CUSTOM locations - Google Places will be fetched in generateRoute
    const isRadiusMode = formData.searchMode === 'radius' || formData.searchMode === 'all';
    
    // Filter custom locations that match current city, area/radius and selected interests
    const matchingCustomLocations = customLocations.filter(loc => {
      // Filter by current city (locations without cityId are treated as 'bangkok')
      if ((loc.cityId || 'bangkok') !== selectedCityId) return false;
      
      // CRITICAL: Skip blacklisted locations!
      if (loc.status === 'blacklist') return false;
      
      // Skip invalid locations (missing required data)
      if (!isLocationValid(loc)) return false;
      
      if (isRadiusMode) {
        // In radius mode: filter by distance from current position
        if (!formData.currentLat || !formData.currentLng || !loc.lat || !loc.lng) return false;
        const dist = calcDistance(formData.currentLat, formData.currentLng, loc.lat, loc.lng);
        if (dist > formData.radiusMeters) return false;
      } else {
        // In area mode: filter by area (supports multi-area)
        const locAreas = loc.areas || (loc.area ? [loc.area] : []);
        if (!locAreas.includes(formData.area)) return false;
      }
      
      if (!loc.interests || loc.interests.length === 0) return false;
      
      // Check if location interests match selected interests
      return loc.interests.some(locInterest => {
        // Direct match
        if (formData.interests.includes(locInterest)) return true;
        
        // Check if selected interest is a custom one with baseCategory that matches
        for (const selectedInterest of formData.interests) {
          const customInterest = allInterestOptions.find(opt => 
            opt.id === selectedInterest && opt.custom && opt.baseCategory
          );
          
          if (customInterest && locInterest === customInterest.baseCategory) {
            return true;
          }
        }
        
        return false;
      });
    });
    
    // Remove duplicates
    const seen = new Set();
    return matchingCustomLocations.filter(stop => {
      const key = `${stop.lat},${stop.lng}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  };

  // ========== ROUTE OPTIMIZATION (Nearest Neighbor + 2-opt) ==========
  const optimizeStopOrder = (stops, startCoords, isCircular) => {
    if (stops.length <= 2) return stops;
    
    // Filter stops with valid coordinates
    const withCoords = stops.filter(s => s.lat && s.lng);
    const noCoords = stops.filter(s => !s.lat || !s.lng);
    
    if (withCoords.length <= 1) return [...withCoords, ...noCoords];
    
    // Distance matrix (using calcDistance which is Haversine)
    const dist = (a, b) => calcDistance(a.lat, a.lng, b.lat, b.lng);
    
    // --- Step 1: Nearest Neighbor from start point ---
    const unvisited = [...withCoords];
    const ordered = [];
    
    // Determine start: use startCoords if available, otherwise pick the stop closest to center
    let currentPos;
    if (startCoords?.lat && startCoords?.lng) {
      currentPos = startCoords;
    } else {
      // Use centroid of all stops as reference, pick nearest to it
      const avgLat = withCoords.reduce((s, p) => s + p.lat, 0) / withCoords.length;
      const avgLng = withCoords.reduce((s, p) => s + p.lng, 0) / withCoords.length;
      // For linear: start from the stop furthest from centroid (creates a more natural path)
      // For circular: start from stop nearest to centroid
      if (!isCircular) {
        let maxDist = -1, startIdx = 0;
        unvisited.forEach((s, i) => {
          const d = calcDistance(avgLat, avgLng, s.lat, s.lng);
          if (d > maxDist) { maxDist = d; startIdx = i; }
        });
        ordered.push(unvisited.splice(startIdx, 1)[0]);
      } else {
        let minDist = Infinity, startIdx = 0;
        unvisited.forEach((s, i) => {
          const d = calcDistance(avgLat, avgLng, s.lat, s.lng);
          if (d < minDist) { minDist = d; startIdx = i; }
        });
        ordered.push(unvisited.splice(startIdx, 1)[0]);
      }
      currentPos = ordered[0];
    }
    
    // If we have startCoords (external start point), find nearest stop to it first
    if (startCoords?.lat && startCoords?.lng && unvisited.length > 0) {
      let minDist = Infinity, nearIdx = 0;
      unvisited.forEach((s, i) => {
        const d = dist(currentPos, s);
        if (d < minDist) { minDist = d; nearIdx = i; }
      });
      ordered.push(unvisited.splice(nearIdx, 1)[0]);
      currentPos = ordered[ordered.length - 1];
    }
    
    // Greedily pick nearest unvisited
    while (unvisited.length > 0) {
      let minDist = Infinity, nearIdx = 0;
      unvisited.forEach((s, i) => {
        const d = dist(currentPos, s);
        if (d < minDist) { minDist = d; nearIdx = i; }
      });
      ordered.push(unvisited.splice(nearIdx, 1)[0]);
      currentPos = ordered[ordered.length - 1];
    }
    
    // --- Step 2: 2-opt improvement (uncross paths) ---
    const totalDist = (route) => {
      let d = 0;
      // If start coords exist, include distance from start to first stop
      if (startCoords?.lat && startCoords?.lng) {
        d += dist(startCoords, route[0]);
      }
      for (let i = 0; i < route.length - 1; i++) {
        d += dist(route[i], route[i + 1]);
      }
      // Circular: add return to start
      if (isCircular) {
        const returnTo = startCoords?.lat ? startCoords : route[0];
        d += dist(route[route.length - 1], returnTo);
      }
      return d;
    };
    
    let improved = true;
    let passes = 0;
    const maxPasses = 5; // 2-opt passes (each pass is O(n¬≤))
    
    while (improved && passes < maxPasses) {
      improved = false;
      passes++;
      for (let i = 0; i < ordered.length - 1; i++) {
        for (let j = i + 2; j < ordered.length; j++) {
          // Check if reversing segment [i+1..j] reduces total distance
          // Only need to compare the 2 edges being broken/reconnected
          const A = i === 0 && startCoords?.lat ? startCoords : ordered[i];
          const B = ordered[i + 1];
          const C = ordered[j];
          const D = j + 1 < ordered.length ? ordered[j + 1] 
            : (isCircular ? (startCoords?.lat ? startCoords : ordered[0]) : null);
          
          const oldDist = dist(A, B) + (D ? dist(C, D) : 0);
          const newDist = dist(A, C) + (D ? dist(B, D) : 0);
          
          if (newDist < oldDist - 1) { // 1m threshold to avoid float noise
            // Reverse segment in place
            const reversed = ordered.slice(i + 1, j + 1).reverse();
            ordered.splice(i + 1, j - i, ...reversed);
            improved = true;
          }
        }
      }
    }
    
    console.log(`[OPTIMIZE] ${withCoords.length} stops optimized in ${passes} passes`);
    console.log(`[OPTIMIZE] Total distance: ${Math.round(totalDist(ordered))}m (${isCircular ? 'circular' : 'linear'})`);
    
    // Append stops without coordinates at the end
    return [...ordered, ...noCoords];
  };

  const generateRoute = async () => {
    const isRadiusMode = formData.searchMode === 'radius' || formData.searchMode === 'all';
    
    // Clear old start point to avoid stale data
    setStartPointCoords(null);
    setFormData(prev => ({...prev, startPoint: ''}));
    
    // For 'all' mode, auto-set city center and large radius
    if (formData.searchMode === 'all') {
      if (!formData.currentLat) {
        const cityCenter = window.BKK.selectedCity?.center || { lat: 13.7563, lng: 100.5018 };
        const cityRadius = window.BKK.selectedCity?.allCityRadius || 15000;
        const cityName = tLabel(window.BKK.selectedCity) || t('general.allCity');
        const allCityLabel = t('general.all') + ' ' + cityName;
        setFormData(prev => ({...prev, currentLat: cityCenter.lat, currentLng: cityCenter.lng, radiusMeters: cityRadius, radiusPlaceName: allCityLabel}));
        formData.currentLat = cityCenter.lat;
        formData.currentLng = cityCenter.lng;
        formData.radiusMeters = cityRadius;
        formData.radiusPlaceName = allCityLabel;
      }
    }
    
    if (isRadiusMode) {
      if (!formData.currentLat || !formData.currentLng) {
        showToast(t('form.findLocationFirst'), 'warning');
        return;
      }
      if (formData.interests.length === 0) {
        showToast(t('form.selectAtLeastOneInterest'), 'warning');
        return;
      }
    } else {
      if (!formData.area || formData.interests.length === 0) {
        showToast(t('form.selectAreaAndInterest'), 'warning');
        return;
      }
    }
    
    setIsGenerating(true);
    
    try {
      addDebugLog('ROUTE', 'Starting route generation', { 
        mode: formData.searchMode, 
        area: formData.area, 
        radius: isRadiusMode ? formData.radiusMeters : null,
        interests: formData.interests, 
        maxStops: formData.maxStops 
      });
      console.log('[ROUTE] Starting route generation', isRadiusMode ? 'RADIUS mode' : 'AREA mode');
      
      // Get custom locations (always included)
      const customStops = getStopsForInterests();
      addDebugLog('ROUTE', `Found ${customStops.length} custom stops`);
      console.log('[ROUTE] Custom stops:', customStops.length);
      
      // Calculate stops needed per interest
      const numInterests = formData.interests.length || 1;
      const maxStops = formData.maxStops || 12;
      const stopsPerInterest = Math.ceil(maxStops / numInterests);
      
      // Track results per interest for smart completion
      const interestResults = {};
      const allStops = [...customStops]; // Start with custom stops (highest priority)
      let fetchErrors = [];
      
      // Clear Google cache for fresh route generation
      googleCacheRef.current = {};
      
      // ROUND 1: Fill from custom locations first, API only for gaps
      for (const interest of formData.interests) {
        // Check how many custom stops we already have for this interest
        const customStopsForInterest = customStops.filter(stop => 
          stop.interests && stop.interests.includes(interest)
        );
        
        const neededForInterest = Math.max(0, stopsPerInterest - customStopsForInterest.length);
        
        if (neededForInterest > 0) {
          // Check if this is a private-only interest (no Google API calls)
          const interestObj = allInterestOptions.find(o => o.id === interest);
          const interestPrivateOnly = interestObj?.privateOnly || false;
          
          let fetchedPlaces = [];
          
          if (interestPrivateOnly) {
            console.log(`[ROUTE] Skipping API for private interest: ${interest}`);
          } else {
          try {
            console.log(`[ROUTE] Fetching for interest: ${interest} (need ${neededForInterest}, have ${customStopsForInterest.length} custom)`);
            const radiusOverride = isRadiusMode ? { 
              lat: formData.currentLat, 
              lng: formData.currentLng, 
              radius: formData.radiusMeters 
            } : null;
            fetchedPlaces = await fetchGooglePlaces(isRadiusMode ? null : formData.area, [interest], radiusOverride);
          } catch (error) {
            // Track errors for user notification
            fetchErrors.push({
              interest,
              error: error.message || 'Unknown error',
              details: error.details || {}
            });
            console.error(`[ERROR] Failed to fetch for ${interest}:`, error);
            fetchedPlaces = [];
          }
          } // end if !privateOnly
          
          // Filter blacklisted places (status='blacklist') BEFORE sorting
          fetchedPlaces = filterBlacklist(fetchedPlaces);
          
          // Filter out Google places that duplicate custom locations
          fetchedPlaces = filterDuplicatesOfCustom(fetchedPlaces);
          
          // In radius mode: HARD filter by actual distance (API locationBias doesn't guarantee this)
          if (isRadiusMode) {
            const beforeFilter = fetchedPlaces.length;
            fetchedPlaces = fetchedPlaces.filter(p => {
              const dist = calcDistance(formData.currentLat, formData.currentLng, p.lat, p.lng);
              return dist <= formData.radiusMeters;
            });
            const removed = beforeFilter - fetchedPlaces.length;
            if (removed > 0) {
              addDebugLog('RADIUS', `Filtered ${removed} places beyond ${formData.radiusMeters}m radius`);
              console.log(`[RADIUS] Filtered ${removed}/${beforeFilter} places beyond radius`);
            }
          }
          
          // Sort
          let sortedAll;
          if (isRadiusMode) {
            sortedAll = fetchedPlaces
              .map(p => ({ ...p, _dist: calcDistance(formData.currentLat, formData.currentLng, p.lat, p.lng) }))
              .sort((a, b) => a._dist - b._dist || (b.rating * Math.log10((b.ratingCount || 0) + 1)) - (a.rating * Math.log10((a.ratingCount || 0) + 1)));
          } else {
            sortedAll = fetchedPlaces
              .sort((a, b) => (b.rating * Math.log10((b.ratingCount || 0) + 1)) - (a.rating * Math.log10((a.ratingCount || 0) + 1)));
          }
          
          // Take what we need, cache the rest
          const sortedPlaces = sortedAll.slice(0, neededForInterest);
          const cachedPlaces = sortedAll.slice(neededForInterest);
          
          // Store unused places in cache for "find more"
          googleCacheRef.current[interest] = cachedPlaces;
          console.log(`[CACHE] Stored ${cachedPlaces.length} unused places for ${interest}`);
          
          // Track results
          interestResults[interest] = {
            requested: stopsPerInterest,
            custom: customStopsForInterest.length,
            fetched: sortedPlaces.length,
            total: customStopsForInterest.length + sortedPlaces.length,
            allPlaces: sortedAll // Keep all for round 2
          };
          
          // Add to allStops
          allStops.push(...sortedPlaces);
        } else {
          // Already have enough from custom - no API call needed!
          console.log(`[ROUTE] Skipping API for ${interest}: ${customStopsForInterest.length} custom stops suffice`);
          googleCacheRef.current[interest] = []; // Empty cache
          interestResults[interest] = {
            requested: stopsPerInterest,
            custom: customStopsForInterest.length,
            fetched: 0,
            total: customStopsForInterest.length,
            allPlaces: []
          };
        }
      }
      
      // Remove duplicates after round 1 - check ONLY exact name match
      // Allow same coordinates with different names (same physical location, different interests)
      const seen = new Set();
      let uniqueStops = allStops.filter(stop => {
        const normalizedName = stop.name.toLowerCase().trim();
        
        if (seen.has(normalizedName)) {
          console.log('[DEDUP] Removed duplicate by exact name:', stop.name);
          return false;
        }
        
        seen.add(normalizedName);
        return true;
      });
      
      // ROUND 2: If we didn't reach maxStops, try to add more from successful interests
      const totalFound = uniqueStops.length;
      const missing = maxStops - totalFound;
      
      console.log('[ROUTE] Round 1 complete:', { totalFound, maxStops, missing });
      
      if (missing > 0) {
        // Find interests that might have more places available
        const additionalPlaces = [];
        
        for (const interest of formData.interests) {
          const result = interestResults[interest];
          const alreadyUsed = result.fetched;
          const available = result.allPlaces.length;
          const canAddMore = available - alreadyUsed;
          
          if (canAddMore > 0) {
            // This interest has more places we can use
            const ratingSort = (a, b) => (b.rating * Math.log10((b.ratingCount || 0) + 1)) - (a.rating * Math.log10((a.ratingCount || 0) + 1));
            const distSort = (a, b) => calcDistance(formData.currentLat, formData.currentLng, a.lat, a.lng) - calcDistance(formData.currentLat, formData.currentLng, b.lat, b.lng);
            const morePlaces = result.allPlaces
              .sort(isRadiusMode ? distSort : ratingSort)
              .slice(alreadyUsed, alreadyUsed + canAddMore);
            
            additionalPlaces.push(...morePlaces);
          }
        }
        
        // Add additional places up to the missing amount
        const ratingSort2 = (a, b) => (b.rating * Math.log10((b.ratingCount || 0) + 1)) - (a.rating * Math.log10((a.ratingCount || 0) + 1));
        const distSort2 = (a, b) => calcDistance(formData.currentLat, formData.currentLng, a.lat, a.lng) - calcDistance(formData.currentLat, formData.currentLng, b.lat, b.lng);
        const sorted = additionalPlaces
          .sort(isRadiusMode ? distSort2 : ratingSort2)
          .slice(0, missing);
        
        uniqueStops = [...uniqueStops, ...sorted];
        
        // Remove duplicates again - check ONLY exact name match
        const seenNames = new Set();
        const finalStops = [];
        
        for (const stop of uniqueStops) {
          const normalizedName = stop.name.toLowerCase().trim();
          
          if (!seenNames.has(normalizedName)) {
            finalStops.push(stop);
            seenNames.add(normalizedName);
          } else {
            console.log('[DEDUP Round 2] Removed duplicate:', stop.name);
          }
        }
        
        uniqueStops = finalStops;
        
        console.log('[ROUTE] Round 2 complete:', { added: sorted.length, total: uniqueStops.length });
        
        // Update Google cache: remove places that Round 2 used
        const usedInRound2 = new Set(sorted.map(s => s.name.toLowerCase().trim()));
        for (const interest of formData.interests) {
          if (googleCacheRef.current[interest]?.length > 0) {
            googleCacheRef.current[interest] = googleCacheRef.current[interest]
              .filter(p => !usedInRound2.has(p.name.toLowerCase().trim()));
          }
        }
      }
      
      // Show errors if any occurred
      if (fetchErrors.length > 0) {
        const errorMsg = fetchErrors.map(e => `${e.interest}: ${e.error}`).join(', ');
        
        console.error('[ROUTE] Data source errors:', fetchErrors);
        showToast(`${t("toast.errorsGettingPlaces")} ${errorMsg}`, 'warning');
      }
      
      // In radius mode: detect area for each stop + filter out places outside known areas + add distance
      if (isRadiusMode) {
        const beforeCount = uniqueStops.length;
        uniqueStops = uniqueStops.map(stop => {
          const detectedArea = detectAreaFromCoords(stop.lat, stop.lng);
          const distFromCenter = Math.round(calcDistance(formData.currentLat, formData.currentLng, stop.lat, stop.lng));
          return { ...stop, detectedArea, distFromCenter };
        }).filter(stop => {
          if (stop.detectedArea) return true;
          console.log('[RADIUS] Filtered out (outside known areas):', stop.name);
          return false;
        });
        const filtered = beforeCount - uniqueStops.length;
        if (filtered > 0) {
          addDebugLog('ROUTE', `Radius: filtered ${filtered} places outside known areas`);
        }
      } else {
        // In area mode: set detectedArea = formData.area for all
        uniqueStops = uniqueStops.map(stop => ({ ...stop, detectedArea: formData.area }));
      }
      
      if (uniqueStops.length === 0) {
        showToast(isRadiusMode 
          ? t('places.noPlacesInRadius') 
          : t('places.noMatchingPlaces'), 'error');
        setIsGenerating(false);
        return;
      }

      // Route name and area info
      let areaName, interestsText;
      if (isRadiusMode) {
        const allCityLabel = t('general.all') + ' ' + (tLabel(window.BKK.selectedCity) || t('general.city'));
        if (formData.searchMode === 'all' || formData.radiusPlaceName === allCityLabel || formData.radiusPlaceName === t('general.allCity')) {
          areaName = allCityLabel;
        } else {
          const sourceName = formData.radiusSource === 'myplace' && formData.radiusPlaceId
            ? customLocations.find(l => l.id === formData.radiusPlaceId)?.name || t('form.myPlace')
            : formData.radiusPlaceName || t('form.currentLocation');
          areaName = `${formData.radiusMeters}m - ${sourceName}`;
        }
      } else {
        const selectedArea = areaOptions.find(a => a.id === formData.area);
        areaName = tLabel(selectedArea) || t('general.allCity');
      }
      interestsText = formData.interests
        .map(id => allInterestOptions.filter(o => o && o.id).find(o => o.id === id)).map(o => o ? tLabel(o) : null)
        .filter(Boolean)
        .join(', ');
      
      // Find highest sequential number for similar routes
      const baseName = `${areaName} - ${interestsText}`;
      const existingNumbers = savedRoutes
        .filter(r => r.name && r.name.startsWith(baseName))
        .map(r => {
          const match = r.name.match(/#(\d+)$/);
          return match ? parseInt(match[1]) : 0;
        });
      const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
      const defaultName = `${baseName} #${nextNumber}`;
      
      const newRoute = {
        id: Date.now(),
        name: '', // Will be set when user saves
        defaultName: defaultName,
        createdAt: new Date().toISOString(),
        areaName: areaName,
        interestsText: interestsText,
        title: `${areaName} - ${uniqueStops.length} ${t("route.places")}`,
        description: `Route ${routeType === 'circular' ? t('route.circular') : t('route.linear')}`,
        duration: formData.hours, // Keep for backward compatibility but not displayed
        circular: routeType === 'circular',
        startPoint: (startPointCoords?.address) || formData.startPoint || t('form.startPointFirst'),
        startPointCoords: startPointCoords || null,
        stops: uniqueStops,
        preferences: { ...formData },
        stats: {
          custom: customStops.length,
          fetched: uniqueStops.length - customStops.length,
          total: uniqueStops.length
        },
        // Warning if didn't reach maxStops
        incomplete: uniqueStops.length < maxStops ? {
          requested: maxStops,
          found: uniqueStops.length,
          missing: maxStops - uniqueStops.length
        } : null,
        // Errors if any
        errors: fetchErrors.length > 0 ? fetchErrors : null,
        optimized: false
      };

      // Include manually added stops (if any)
      if (manualStops.length > 0) {
        const existingNames = new Set(uniqueStops.map(s => s.name.toLowerCase().trim()));
        const nonDuplicateManual = manualStops.filter(ms => !existingNames.has(ms.name.toLowerCase().trim()));
        if (nonDuplicateManual.length > 0) {
          newRoute.stops = [...newRoute.stops, ...nonDuplicateManual];
          newRoute.stats.manual = nonDuplicateManual.length;
          newRoute.stats.total = newRoute.stops.length;
        }
      }

      console.log('[ROUTE] Route created successfully:', {
        stops: newRoute.stops.length,
        stats: newRoute.stats,
        incomplete: newRoute.incomplete,
        errors: newRoute.errors
      });

      setRoute(newRoute);
      
      // Clean up disabled stops: keep only those that still exist in the new route
      if (disabledStops.length > 0) {
        const newStopNames = new Set(newRoute.stops.map(s => (s.name || '').toLowerCase().trim()));
        const stillRelevant = disabledStops.filter(name => newStopNames.has(name));
        if (stillRelevant.length !== disabledStops.length) {
          console.log('[ROUTE] Cleaned disabled stops:', disabledStops.length, '->', stillRelevant.length);
          setDisabledStops(stillRelevant);
        }
      }
      
      console.log('[ROUTE] Route set, staying in form view');
      console.log('[ROUTE] Route object:', newRoute);
      
      // Scroll to results
      setTimeout(() => {
        document.getElementById('route-results')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
      
      // Stay in form view to show compact list
    } catch (error) {
      console.error('[ROUTE] Fatal error generating route:', error);
      showToast(`${t('general.error')}: ${error.message || t('general.unknownError')}`, 'error');
    } finally {
      setIsGenerating(false);
    }
  };

  // Compute/recompute optimized route order from existing stops
  const computeRoute = () => {
    if (!route || route.stops.length < 2) return;
    if (!startPointCoords) {
      showToast(t('form.chooseStartBeforeCalc'), 'warning');
      return;
    }
    
    const isCircular = routeType === 'circular';
    
    // Filter out disabled stops for optimization, keep them at end
    const activeStops = route.stops.filter(stop => {
      return !disabledStops.includes((stop.name || '').toLowerCase().trim());
    });
    const inactiveStops = route.stops.filter(stop => {
      return disabledStops.includes((stop.name || '').toLowerCase().trim());
    });
    
    console.log(`[COMPUTE] Optimizing ${activeStops.length} active stops (${isCircular ? 'circular' : 'linear'})`);
    const optimized = optimizeStopOrder(activeStops, startPointCoords, isCircular);
    
    // Recombine: optimized active stops first, then inactive at end
    const newStops = [...optimized, ...inactiveStops];
    
    setRoute({
      ...route,
      stops: newStops,
      circular: isCircular,
      optimized: true,
      startPoint: startPointCoords.address || formData.startPoint || '',
      startPointCoords: startPointCoords
    });
    
    showToast(`${t("route.routeCalculated")} ${optimized.length} ${t("route.stops")}`, 'success');
    
    // Warn if route will need to be split for Google Maps
    if (optimized.length + 1 > googleMaxWaypoints) { // +1 for origin/startPoint
      const parts = Math.ceil((optimized.length + 1 - 2) / (googleMaxWaypoints - 2)) + (optimized.length + 1 > googleMaxWaypoints ? 0 : 0);
      // Calculate actual parts using the helper
      const testUrls = window.BKK.buildGoogleMapsUrls(
        optimized.map(s => ({ lat: s.lat, lng: s.lng })),
        `${startPointCoords.lat},${startPointCoords.lng}`,
        isCircular,
        googleMaxWaypoints
      );
      if (testUrls.length > 1) {
        showToast(t('route.splitRouteWarning').replace('{max}', googleMaxWaypoints).replace('{parts}', testUrls.length), 'info', 'sticky');
      }
    }
    
    setTimeout(() => {
      // Scroll to bottom of results to show the Google Maps button
      const el = document.getElementById('open-google-maps-btn');
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, 200);
  };

  // Fetch more places for a specific interest
  // Priority: 1) unused custom locations  2) Google cache  3) new API call
  const fetchMoreForInterest = async (interest) => {
    if (!route) return;
    
    setIsGenerating(true);
    
    try {
      const fetchCount = formData.fetchMoreCount || 3;
      const isRadiusMode = formData.searchMode === 'radius' || formData.searchMode === 'all';
      const existingNames = route.stops.map(s => s.name.toLowerCase().trim());
      const interestLabel = allInterestOptions.find(o => o.id === interest)?.label || interest;
      let placesToAdd = [];
      let source = '';
      
      console.log(`[FETCH_MORE] Need ${fetchCount} more for ${interest}`);
      
      // LAYER 1: Unused custom locations for this interest
      const unusedCustom = customLocations.filter(loc => {
        if (loc.status === 'blacklist') return false;
        if (!isLocationValid(loc)) return false;
        if (!loc.interests || !loc.interests.some(li => {
          if (li === interest) return true;
          const ci = allInterestOptions.find(opt => opt.id === interest && opt.custom && opt.baseCategory);
          return ci && li === ci.baseCategory;
        })) return false;
        // Must be in area/radius
        if (isRadiusMode) {
          if (!formData.currentLat || !formData.currentLng || !loc.lat || !loc.lng) return false;
          if (calcDistance(formData.currentLat, formData.currentLng, loc.lat, loc.lng) > formData.radiusMeters) return false;
        } else {
          const locAreas = loc.areas || (loc.area ? [loc.area] : []);
          if (!locAreas.includes(formData.area)) return false;
        }
        // Not already in route
        return !existingNames.includes(loc.name.toLowerCase().trim());
      });
      
      if (unusedCustom.length > 0) {
        const toAdd = unusedCustom.slice(0, fetchCount);
        placesToAdd = toAdd.map(p => ({ ...p, addedLater: true }));
        source = t('general.fromMyPlaces');
        console.log(`[FETCH_MORE] Found ${toAdd.length} from unused custom locations`);
      }
      
      // LAYER 2: Google cache (unused results from initial route generation)
      if (placesToAdd.length < fetchCount) {
        const cached = googleCacheRef.current[interest] || [];
        const allUsedNames = [...existingNames, ...placesToAdd.map(p => p.name.toLowerCase().trim())];
        const unusedCached = cached.filter(p => !allUsedNames.includes(p.name.toLowerCase().trim()));
        
        if (unusedCached.length > 0) {
          const needed = fetchCount - placesToAdd.length;
          const fromCache = unusedCached.slice(0, needed).map(p => ({
            ...p,
            addedLater: true,
            detectedArea: isRadiusMode ? detectAreaFromCoords(p.lat, p.lng) : formData.area
          }));
          placesToAdd.push(...fromCache);
          // Update cache: remove used ones
          googleCacheRef.current[interest] = unusedCached.slice(needed);
          source = source ? `${source} + ${t("places.fromGoogleCache")}` : t('places.fromGoogle');
          console.log(`[FETCH_MORE] Added ${fromCache.length} from Google cache (${googleCacheRef.current[interest].length} remaining)`);
        }
      }
      
      // LAYER 3: New API call (only if still need more AND not private-only)
      if (placesToAdd.length < fetchCount) {
        // Check privateOnly
        const interestObjFM = allInterestOptions.find(o => o.id === interest);
        const isPrivate = interestObjFM?.privateOnly || false;
        
        if (isPrivate) {
          console.log(`[FETCH_MORE] Private interest ${interest} - skipping API call`);
        } else {
        const needed = fetchCount - placesToAdd.length;
        console.log(`[FETCH_MORE] Cache exhausted, calling API for ${needed} more`);
        
        const radiusOverride = isRadiusMode ? { 
          lat: formData.currentLat, lng: formData.currentLng, radius: formData.radiusMeters 
        } : null;
        let newPlaces = await fetchGooglePlaces(isRadiusMode ? null : formData.area, [interest], radiusOverride);
        
        if (isRadiusMode) {
          newPlaces = newPlaces.map(p => ({ ...p, detectedArea: detectAreaFromCoords(p.lat, p.lng) }))
            .filter(p => p.detectedArea);
          newPlaces = newPlaces.filter(p => calcDistance(formData.currentLat, formData.currentLng, p.lat, p.lng) <= formData.radiusMeters);
        } else {
          newPlaces = newPlaces.map(p => ({ ...p, detectedArea: formData.area }));
        }
        
        newPlaces = filterBlacklist(newPlaces);
        newPlaces = filterDuplicatesOfCustom(newPlaces);
        
        const allUsedNames = [...existingNames, ...placesToAdd.map(p => p.name.toLowerCase().trim())];
        newPlaces = newPlaces.filter(p => !allUsedNames.includes(p.name.toLowerCase().trim()));
        
        if (isRadiusMode && formData.currentLat) {
          newPlaces.sort((a, b) => calcDistance(formData.currentLat, formData.currentLng, a.lat, a.lng) - calcDistance(formData.currentLat, formData.currentLng, b.lat, b.lng));
        } else {
          newPlaces.sort((a, b) => (b.rating * Math.log10((b.ratingCount || 0) + 1)) - (a.rating * Math.log10((a.ratingCount || 0) + 1)));
        }
        
        const fromApi = newPlaces.slice(0, needed).map(p => ({ ...p, addedLater: true }));
        // Cache remaining for future use
        googleCacheRef.current[interest] = newPlaces.slice(needed);
        placesToAdd.push(...fromApi);
        source = source ? `${source} + ${t("places.fromGoogle")}` : t('places.fromGoogle');
        console.log(`[FETCH_MORE] Got ${fromApi.length} from API, cached ${googleCacheRef.current[interest].length}`);
        } // end if !isPrivate
      }
      
      if (placesToAdd.length === 0) {
        showToast(`${t("toast.noMoreInInterest")} ${interestLabel}`, 'warning');
        return;
      }
      
      const updatedRoute = {
        ...route,
        stops: [...route.stops, ...placesToAdd]
      };
      
      setRoute(updatedRoute);
      showToast(`${placesToAdd.length} ${t("toast.addedMorePlaces")} ${interestLabel} (${source})`, 'success');
      
    } catch (error) {
      console.error('[FETCH_MORE] Error:', error);
      showToast(t('toast.addPlacesError'), 'error');
    } finally {
      setIsGenerating(false);
    }
  };

  // Fetch more places for all interests - delegates to fetchMoreForInterest per interest
  const fetchMoreAll = async () => {
    if (!route) return;
    
    setIsGenerating(true);
    
    try {
      const fetchCount = formData.fetchMoreCount || 3;
      const perInterest = Math.ceil(fetchCount / formData.interests.length);
      const isRadiusMode = formData.searchMode === 'radius' || formData.searchMode === 'all';
      const existingNames = route.stops.map(s => s.name.toLowerCase().trim());
      
      console.log(`[FETCH_MORE_ALL] Need ${perInterest} per interest, total target: ${fetchCount}`);
      
      const allNewPlaces = [];
      let fromCustom = 0;
      let fromCache = 0;
      let fromApi = 0;
      
      for (const interest of formData.interests) {
        const allUsedNames = [...existingNames, ...allNewPlaces.map(p => p.name.toLowerCase().trim())];
        let placesForInterest = [];
        
        // LAYER 1: Unused custom locations
        const unusedCustom = customLocations.filter(loc => {
          if (loc.status === 'blacklist') return false;
          if (!isLocationValid(loc)) return false;
          if (!loc.interests || !loc.interests.some(li => {
            if (li === interest) return true;
            const ci = allInterestOptions.find(opt => opt.id === interest && opt.custom && opt.baseCategory);
            return ci && li === ci.baseCategory;
          })) return false;
          if (isRadiusMode) {
            if (!formData.currentLat || !formData.currentLng || !loc.lat || !loc.lng) return false;
            if (calcDistance(formData.currentLat, formData.currentLng, loc.lat, loc.lng) > formData.radiusMeters) return false;
          } else {
            const locAreas = loc.areas || (loc.area ? [loc.area] : []);
            if (!locAreas.includes(formData.area)) return false;
          }
          return !allUsedNames.includes(loc.name.toLowerCase().trim());
        });
        
        if (unusedCustom.length > 0) {
          const toAdd = unusedCustom.slice(0, perInterest).map(p => ({ ...p, addedLater: true }));
          placesForInterest.push(...toAdd);
          fromCustom += toAdd.length;
        }
        
        // LAYER 2: Google cache
        if (placesForInterest.length < perInterest) {
          const cached = googleCacheRef.current[interest] || [];
          const usedNames = [...allUsedNames, ...placesForInterest.map(p => p.name.toLowerCase().trim())];
          const unusedCached = cached.filter(p => !usedNames.includes(p.name.toLowerCase().trim()));
          
          if (unusedCached.length > 0) {
            const needed = perInterest - placesForInterest.length;
            const fromC = unusedCached.slice(0, needed).map(p => ({
              ...p, addedLater: true,
              detectedArea: isRadiusMode ? detectAreaFromCoords(p.lat, p.lng) : formData.area
            }));
            placesForInterest.push(...fromC);
            googleCacheRef.current[interest] = unusedCached.slice(needed);
            fromCache += fromC.length;
          }
        }
        
        // LAYER 3: API (only if still need more)
        if (placesForInterest.length < perInterest) {
          // Check privateOnly
          const interestObjFA = allInterestOptions.find(o => o.id === interest);
          const isPrivateAll = interestObjFA?.privateOnly || false;
          
          if (!isPrivateAll) {
          const needed = perInterest - placesForInterest.length;
          console.log(`[FETCH_MORE_ALL] API call for ${interest} (need ${needed} more)`);
          
          const radiusOverride = isRadiusMode ? { 
            lat: formData.currentLat, lng: formData.currentLng, radius: formData.radiusMeters 
          } : null;
          let newPlaces = await fetchGooglePlaces(isRadiusMode ? null : formData.area, [interest], radiusOverride);
          
          if (isRadiusMode) {
            newPlaces = newPlaces.map(p => ({ ...p, detectedArea: detectAreaFromCoords(p.lat, p.lng) }))
              .filter(p => p.detectedArea);
            newPlaces = newPlaces.filter(p => calcDistance(formData.currentLat, formData.currentLng, p.lat, p.lng) <= formData.radiusMeters);
          } else {
            newPlaces = newPlaces.map(p => ({ ...p, detectedArea: formData.area }));
          }
          
          newPlaces = filterBlacklist(newPlaces);
          newPlaces = filterDuplicatesOfCustom(newPlaces);
          const usedNames = [...allUsedNames, ...placesForInterest.map(p => p.name.toLowerCase().trim())];
          newPlaces = newPlaces.filter(p => !usedNames.includes(p.name.toLowerCase().trim()));
          
          const fromA = newPlaces.slice(0, needed).map(p => ({ ...p, addedLater: true }));
          googleCacheRef.current[interest] = newPlaces.slice(needed);
          placesForInterest.push(...fromA);
          fromApi += fromA.length;
          } else {
            console.log(`[FETCH_MORE_ALL] Private interest ${interest} - skipping API`);
          }
        }
        
        allNewPlaces.push(...placesForInterest);
      }
      
      if (allNewPlaces.length === 0) {
        showToast(t('places.noMorePlaces'), 'warning');
        return;
      }
      
      const updatedRoute = {
        ...route,
        stops: [...route.stops, ...allNewPlaces]
      };
      
      setRoute(updatedRoute);
      
      // Build source message
      const sources = [];
      if (fromCustom > 0) sources.push(`${fromCustom} ${t("general.fromMyPlaces")}`);
      if (fromCache > 0) sources.push(`${fromCache} ${t("places.fromGoogleCache")}`);
      if (fromApi > 0) sources.push(`${fromApi} ${t("places.fromGoogle")}`);
      showToast(`${allNewPlaces.length} ${t("route.places")} (${sources.join(', ')})`, 'success');
      
      setTimeout(() => {
        document.getElementById('route-results')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
      
    } catch (error) {
      console.error('[FETCH_MORE_ALL] Error:', error);
      showToast(t('toast.addPlacesError'), 'error');
    } finally {
      setIsGenerating(false);
    }
  };

  // Filter blacklisted places
  // Filter out places that exist in custom locations with status='blacklist' (exact name match)
  const filterBlacklist = (places) => {
    const blacklistedNames = customLocations
      .filter(loc => loc.status === 'blacklist' && (loc.cityId || 'bangkok') === selectedCityId)
      .map(loc => loc.name.toLowerCase().trim());
    
    if (blacklistedNames.length === 0) return places;
    
    return places.filter(place => {
      const placeName = place.name.toLowerCase().trim();
      const isBlacklisted = blacklistedNames.includes(placeName);
      if (isBlacklisted) {
        console.log(`[BLACKLIST] Filtered out: ${place.name}`);
      }
      return !isBlacklisted;
    });
  };
  
  // Filter out Google places that already exist in custom locations (exact name match)
  const filterDuplicatesOfCustom = (places) => {
    const customNames = customLocations
      .filter(loc => loc.status !== 'blacklist' && (loc.cityId || 'bangkok') === selectedCityId)
      .map(loc => loc.name.toLowerCase().trim());
    
    if (customNames.length === 0) return places;
    
    return places.filter(place => {
      const placeName = place.name.toLowerCase().trim();
      const isDuplicate = customNames.includes(placeName);
      if (isDuplicate) {
        console.log(`[DEDUP] Filtered Google duplicate of custom location: ${place.name}`);
      }
      return !isDuplicate;
    });
  };

  // Strip heavy data (base64 images) from route before save - keep Storage URLs
  const stripRouteForStorage = (r) => {
    const stripped = { ...r };
    if (stripped.stops) {
      stripped.stops = stripped.stops.map(s => {
        // Only strip base64 data, keep URL strings
        if (s.uploadedImage && s.uploadedImage.startsWith('data:')) {
          const { uploadedImage, ...rest } = s;
          return rest;
        }
        return { ...s };
      });
    }
    return stripped;
  };

  const saveRoutesToStorage = (routes) => {
    if (isFirebaseAvailable && database) {
      // Firebase mode: no-op, individual operations handle persistence
      return;
    }
    try {
      const stripped = routes.map(stripRouteForStorage);
      localStorage.setItem('bangkok_saved_routes', JSON.stringify(stripped));
    } catch (e) {
      console.error('[STORAGE] Failed to save routes:', e);
      showToast(t('toast.storageFull'), 'error');
    }
  };

  const quickSaveRoute = () => {
    const name = route.defaultName || route.name || `Route ${Date.now()}`;
    
    const routeToSave = {
      ...route,
      name: name,
      notes: '',
      savedAt: new Date().toISOString(),
      inProgress: true,
      locked: false,
      cityId: selectedCityId
    };

    if (isFirebaseAvailable && database) {
      const stripped = stripRouteForStorage(routeToSave);
      database.ref(`cities/${selectedCityId}/routes`).push(stripped)
        .then((ref) => {
          console.log('[FIREBASE] Route saved');
          const savedWithFbId = { ...routeToSave, firebaseId: ref.key };
          setRoute(savedWithFbId);
          setEditingRoute({...savedWithFbId});
          setRouteDialogMode('add');
          setShowRouteDialog(true);
          showToast(t('route.routeSaved'), 'success');
        })
        .catch((error) => {
          console.error('[FIREBASE] Error saving route:', error);
          showToast(t('toast.routeSaveError'), 'error');
        });
    } else {
      const updated = [routeToSave, ...savedRoutes];
      setSavedRoutes(updated);
      saveRoutesToStorage(updated);
      setRoute(routeToSave);
      showToast(t('route.routeSaved'), 'success');
      setEditingRoute({...routeToSave});
      setRouteDialogMode('add');
      setShowRouteDialog(true);
    }
  };

  const deleteRoute = (routeId) => {
    if (isFirebaseAvailable && database) {
      const routeToDelete = savedRoutes.find(r => r.id === routeId);
      if (routeToDelete && routeToDelete.firebaseId) {
        database.ref(`cities/${selectedCityId}/routes/${routeToDelete.firebaseId}`).remove()
          .then(() => {
            console.log('[FIREBASE] Route deleted');
            showToast(t('route.routeDeleted'), 'success');
          })
          .catch((error) => {
            console.error('[FIREBASE] Error deleting route:', error);
            showToast(t('toast.deleteError'), 'error');
          });
      }
    } else {
      const updated = savedRoutes.filter(r => r.id !== routeId);
      setSavedRoutes(updated);
      saveRoutesToStorage(updated);
      showToast(t('route.routeDeleted'), 'success');
    }
  };

  const updateRoute = (routeId, updates) => {
    if (isFirebaseAvailable && database) {
      const routeToUpdate = savedRoutes.find(r => r.id === routeId);
      if (routeToUpdate && routeToUpdate.firebaseId) {
        database.ref(`cities/${selectedCityId}/routes/${routeToUpdate.firebaseId}`).update(updates)
          .then(() => {
            console.log('[FIREBASE] Route updated');
            showToast(t('route.routeUpdated'), 'success');
          })
          .catch((error) => {
            console.error('[FIREBASE] Error updating route:', error);
            showToast(t('toast.updateError'), 'error');
          });
      }
    } else {
      const updated = savedRoutes.map(r => r.id === routeId ? { ...r, ...updates } : r);
      setSavedRoutes(updated);
      saveRoutesToStorage(updated);
      showToast(t('route.routeUpdated'), 'success');
    }
  };

  const loadSavedRoute = (savedRoute) => {
    setRoute(savedRoute);
    // Restore startPoint: prefer startPointCoords.address (validated), then route.startPoint, then preferences
    const coords = savedRoute.startPointCoords || null;
    const validatedAddress = coords?.address || '';
    const startPointText = validatedAddress || 
      (savedRoute.startPoint !== t('form.startPointFirst') ? savedRoute.startPoint : '') || 
      '';
    setFormData({...savedRoute.preferences, startPoint: startPointText });
    setStartPointCoords(coords);
    // Restore route type (circular/linear)
    setRouteType(savedRoute.circular ? 'circular' : 'linear');
    setCurrentView('route');
  };

  // NOTE: addCustomInterest logic is now inline in the dialog footer (see Add Interest Dialog)
  // This allows direct configuration of search settings when creating an interest

  const deleteCustomInterest = (interestId) => {
    const interestToDelete = customInterests.find(i => i.id === interestId);
    
    // Check if any custom locations use this interest
    const locationsUsingInterest = customLocations.filter(loc => 
      loc.interests && loc.interests.includes(interestId)
    );
    
    // Delete from Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      if (interestToDelete && interestToDelete.firebaseId) {
        database.ref(`customInterests/${interestToDelete.firebaseId}`).remove()
          .then(() => {
            console.log('[FIREBASE] Interest deleted from shared database');
            if (locationsUsingInterest.length > 0) {
              showToast(`${t("toast.interestDeletedWithPlaces")} (${locationsUsingInterest.length})`, 'success');
            } else {
              showToast(t('interests.interestDeleted'), 'success');
            }
          })
          .catch((error) => {
            console.error('[FIREBASE] Error deleting interest:', error);
            showToast(t('toast.deleteError'), 'error');
          });
      }
    } else {
      // STATIC MODE: localStorage (local)
      const updated = customInterests.filter(i => i.id !== interestId);
      setCustomInterests(updated);
      localStorage.setItem('bangkok_custom_interests', JSON.stringify(updated));
      
      if (locationsUsingInterest.length > 0) {
        showToast(`${t("toast.interestDeletedWithPlaces")} (${locationsUsingInterest.length})`, 'success');
      } else {
        showToast(t('interests.interestDeleted'), 'success');
      }
    }
  };

  // Toggle interest active/inactive status (per-user)
  const toggleInterestStatus = (interestId) => {
    // Invalid interests cannot be activated
    if (!isInterestValid(interestId) && !interestStatus[interestId]) return;
    
    const newStatus = !interestStatus[interestId];
    const updatedStatus = { ...interestStatus, [interestId]: newStatus };
    setInterestStatus(updatedStatus);
    
    if (isFirebaseAvailable && database) {
      const userId = localStorage.getItem('bangkok_user_id') || 'unknown';
      database.ref(`users/${userId}/interestStatus/${interestId}`).set(newStatus)
        .then(() => {
          console.log('[FIREBASE] User interest status updated:', interestId, newStatus);
        })
        .catch(err => {
          console.error('Error updating interest status:', err);
        });
    } else {
      localStorage.setItem('bangkok_interest_status', JSON.stringify(updatedStatus));
    }
  };

  // Reset user interest preferences to admin defaults
  const resetInterestStatusToDefault = async () => {
    if (isFirebaseAvailable && database) {
      const userId = localStorage.getItem('bangkok_user_id') || 'unknown';
      try {
        // Remove user overrides
        await database.ref(`users/${userId}/interestStatus`).remove();
        // Reload admin defaults
        const adminSnap = await database.ref('settings/interestStatus').once('value');
        const adminData = adminSnap.val() || {};
        const builtInIds = interestOptions.map(i => i.id);
        const uncoveredIds = uncoveredInterests.map(i => i.id || i.name.replace(/\s+/g, '_').toLowerCase());
        const defaultStatus = {};
        builtInIds.forEach(id => { defaultStatus[id] = true; });
        uncoveredIds.forEach(id => { defaultStatus[id] = false; });
        setInterestStatus({ ...defaultStatus, ...adminData });
        showToast(t('interests.interestsReset'), 'success');
      } catch (err) {
        console.error('Error resetting interest status:', err);
        showToast(t('toast.resetError'), 'error');
      }
    } else {
      localStorage.removeItem('bangkok_interest_status');
      const builtInIds = interestOptions.map(i => i.id);
      const uncoveredIds = uncoveredInterests.map(i => i.id || i.name.replace(/\s+/g, '_').toLowerCase());
      const defaultStatus = {};
      builtInIds.forEach(id => { defaultStatus[id] = true; });
      uncoveredIds.forEach(id => { defaultStatus[id] = false; });
      setInterestStatus(defaultStatus);
      showToast(t('interests.interestsReset'), 'success');
    }
  };

  // Check if interest has valid search config
  const isInterestValid = (interestId) => {
    // Private interests are always valid (no Google search needed)
    const interestObj = allInterestOptions.find(o => o.id === interestId);
    if (interestObj?.privateOnly) return true;
    // Also check raw customInterests in case not yet in allInterestOptions
    const rawCustom = customInterests.find(o => o.id === interestId);
    if (rawCustom?.privateOnly) return true;
    
    const config = interestConfig[interestId];
    if (config) {
      // Valid if has textSearch OR has types array with items
      if (config.textSearch && config.textSearch.trim()) return true;
      if (config.types && Array.isArray(config.types) && config.types.length > 0) return true;
    }
    
    // Fallback: check city's built-in interestToGooglePlaces or textSearchInterests
    const cityPlaces = window.BKK.interestToGooglePlaces || {};
    const cityTextSearch = window.BKK.textSearchInterests || {};
    if (cityPlaces[interestId] && cityPlaces[interestId].length > 0) return true;
    if (cityTextSearch[interestId]) return true;
    
    return false;
  };

  // Check if location has all required data
  const isLocationValid = (loc) => {
    if (!loc) return false;
    // Must have name
    if (!loc.name || !loc.name.trim()) return false;
    // Must have at least one interest
    if (!loc.interests || loc.interests.length === 0) return false;
    // Must have address OR coordinates
    const hasAddress = loc.address && loc.address.trim();
    const hasCoords = loc.lat && loc.lng;
    if (!hasAddress && !hasCoords) return false;
    return true;
  };

  const deleteCustomLocation = (locationId) => {
    const locationToDelete = customLocations.find(loc => loc.id === locationId);
    
    // Delete from Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      if (locationToDelete && locationToDelete.firebaseId) {
        database.ref(`cities/${selectedCityId}/locations/${locationToDelete.firebaseId}`).remove()
          .then(() => {
            console.log('[FIREBASE] Location deleted from shared database');
            showToast(t('places.placeDeleted'), 'success');
          })
          .catch((error) => {
            console.error('[FIREBASE] Error deleting location:', error);
            showToast(t('toast.deleteError'), 'error');
          });
      }
    } else {
      // STATIC MODE: localStorage (local)
      const updated = customLocations.filter(loc => loc.id !== locationId);
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      showToast(t('places.placeDeleted'), 'success');
    }
  };
  
  // Toggle location status with review state
  const toggleLocationStatus = (locationId) => {
    const location = customLocations.find(loc => loc.id === locationId);
    if (!location) return;
    
    let newStatus = location.status;
    let newInProgress = location.inProgress;
    
    if (location.status === 'blacklist') {
      // From blacklist ‚Üí review (with inProgress badge)
      newStatus = 'review';
      newInProgress = true;
    } else if (location.status === 'review') {
      // From review ‚Üí active (remove badge)
      newStatus = 'active';
      newInProgress = false;
    } else {
      // From active ‚Üí blacklist
      newStatus = 'blacklist';
      newInProgress = false;
    }
    
    // Update in Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      if (location.firebaseId) {
        database.ref(`cities/${selectedCityId}/locations/${location.firebaseId}`).update({
          status: newStatus,
          inProgress: newInProgress
        })
          .then(() => {
            const statusText = 
              newStatus === 'blacklist' ? t('route.skipPermanently') : 
              newStatus === 'review' ? t('general.underReview') : 
              t('general.included');
            showToast(`${location.name}: ${statusText}`, 'success');
          })
          .catch((error) => {
            console.error('[FIREBASE] Error updating status:', error);
            showToast(t('toast.updateError'), 'error');
          });
      }
    } else {
      // STATIC MODE: localStorage (local)
      const updated = customLocations.map(loc => {
        if (loc.id === locationId) {
          return { ...loc, status: newStatus, inProgress: newInProgress };
        }
        return loc;
      });
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      
      const statusText = 
        newStatus === 'blacklist' ? t('route.skipPermanently') : 
        newStatus === 'review' ? t('general.underReview') : 
        t('general.included');
      showToast(`${location.name}: ${statusText}`, 'success');
    }
  };
  
  // Handle edit location - populate form with existing data
  const handleEditLocation = (loc) => {
    setEditingLocation(loc);
    const editFormData = {
      name: loc.name || '',
      description: loc.description || '',
      notes: loc.notes || '',
      area: loc.area || (loc.areas ? loc.areas[0] : formData.area),
      areas: loc.areas || (loc.area ? [loc.area] : [formData.area]),
      interests: loc.interests || [],
      lat: loc.lat || null,
      lng: loc.lng || null,
      mapsUrl: loc.mapsUrl || '',
      address: loc.address || '',
      uploadedImage: loc.uploadedImage || null,
      imageUrls: loc.imageUrls || [],
      inProgress: !!loc.inProgress,
      locked: !!loc.locked
    };
    
    setNewLocation(editFormData);
    setGooglePlaceInfo(null);
    setLocationSearchResults(null);
    setShowEditLocationDialog(true);
  };
  
  // Add Google place to My Locations
  const addGooglePlaceToCustom = async (place) => {
    // Check if already exists (by name, case-insensitive)
    const exists = customLocations.find(loc => 
      loc.name.toLowerCase().trim() === place.name.toLowerCase().trim()
    );
    
    if (exists) {
      showToast(`"${place.name}" ${t("places.alreadyInMyList")}`, 'warning');
      return false;
    }
    
    // Set adding state for dimmed button
    const placeId = place.id || place.name;
    setAddingPlaceIds(prev => [...prev, placeId]);
    
    const boundaryCheck = checkLocationInArea(place.lat, place.lng, formData.area);
    
    const locationToAdd = {
      id: Date.now(),
      name: place.name,
      description: place.description || t('general.addedFromGoogle'),
      notes: '',
      address: place.address || '',
      area: formData.area,
      areas: (() => { const d = window.BKK.getAreasForCoordinates(place.lat, place.lng); return d.length > 0 ? d : [formData.area]; })(),
      interests: place.interests || [],
      lat: place.lat,
      lng: place.lng,
      googlePlaceId: place.googlePlaceId || null,
      uploadedImage: null,
      imageUrls: [],
      outsideArea: !boundaryCheck.valid,
      duration: 45,
      custom: true,
      status: 'active',
      inProgress: false,
      addedAt: new Date().toISOString(),
      fromGoogle: true, // Mark as added from Google
      cityId: selectedCityId // Associate with current city
    };
    
    // Save to Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      try {
        await database.ref(`cities/${selectedCityId}/locations`).push(locationToAdd);
        addDebugLog('ADD', `Added "${place.name}" to Firebase`);
        showToast(`"${place.name}" ${t("places.addedToYourList")}`, 'success');
        setAddingPlaceIds(prev => prev.filter(id => id !== placeId));
        return true;
      } catch (error) {
        console.error('[FIREBASE] Error adding Google place:', error);
        addDebugLog('ERROR', `Failed to add "${place.name}"`, error);
        showToast(t('toast.saveError'), 'error');
        setAddingPlaceIds(prev => prev.filter(id => id !== placeId));
        return false;
      }
    } else {
      const updated = [...customLocations, locationToAdd];
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      showToast(`"${place.name}" ${t("places.addedToYourList")}`, 'success');
      setAddingPlaceIds(prev => prev.filter(id => id !== placeId));
      return true;
    }
  };
  
  // Skip place permanently (add to blacklist)
  const skipPlacePermanently = (place) => {
    // Check if already exists
    const exists = customLocations.find(loc => 
      loc.name.toLowerCase() === place.name.toLowerCase()
    );
    
    if (exists) {
      // Already exists - just update status to blacklist
      if (exists.status === 'blacklist') {
        showToast(`"${place.name}" ${t("places.alreadyBlacklisted")}`, 'warning');
        return;
      }
      
      // Update existing location to blacklist
      const locationId = exists.id;
      
      if (isFirebaseAvailable && database && exists.firebaseId) {
        database.ref(`cities/${selectedCityId}/locations/${exists.firebaseId}`).update({
          status: 'blacklist',
          inProgress: false
        })
          .then(() => {
            showToast(`"${place.name}" ${t("places.addedToSkipList")}`, 'success');
          })
          .catch((error) => {
            console.error('[FIREBASE] Error updating to blacklist:', error);
            showToast(t('toast.updateError'), 'error');
          });
      } else {
        const updated = customLocations.map(loc => {
          if (loc.id === locationId) {
            return { ...loc, status: 'blacklist', inProgress: false };
          }
          return loc;
        });
        setCustomLocations(updated);
        localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
        showToast(`"${place.name}" ${t("places.addedToSkipList")}`, 'success');
      }
      return;
    }
    
    // Doesn't exist - create new with blacklist status
    const boundaryCheck = checkLocationInArea(place.lat, place.lng, formData.area);
    
    // IMPORTANT: Copy interests from the place - blacklist needs same validation as active
    const locationToAdd = {
      id: Date.now(),
      name: place.name,
      description: place.description || t('toast.addedFromSearch'),
      notes: '',
      area: formData.area,
      areas: (() => { const d = window.BKK.getAreasForCoordinates(place.lat, place.lng); return d.length > 0 ? d : [formData.area]; })(),
      interests: place.interests && place.interests.length > 0 ? place.interests : [],
      lat: place.lat,
      lng: place.lng,
      uploadedImage: null,
      imageUrls: [],
      outsideArea: !boundaryCheck.valid,
      duration: 45,
      custom: true,
      status: 'blacklist', // Start as blacklisted!
      inProgress: false,
      addedAt: new Date().toISOString(),
      fromGoogle: true,
      cityId: selectedCityId
    };
    
    // Save to Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      database.ref(`cities/${selectedCityId}/locations`).push(locationToAdd)
        .then(() => {
          console.log('[FIREBASE] Place added to blacklist');
          showToast(`"${place.name}" ${t("places.addedToSkipList")}`, 'success');
        })
        .catch((error) => {
          console.error('[FIREBASE] Error adding to blacklist:', error);
          showToast(t('toast.saveError'), 'error');
        });
    } else {
      const updated = [...customLocations, locationToAdd];
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      showToast(`"${place.name}" ${t("places.addedToSkipList")}`, 'success');
    }
  };
  
  // Import function - add new only, skip existing
  const handleImportMerge = async () => {
    let addedInterests = 0;
    let skippedInterests = 0;
    let addedLocations = 0;
    let skippedLocations = 0;
    let addedRoutes = 0;
    let skippedRoutes = 0;
    let updatedConfigs = 0;
    let updatedStatuses = 0;
    
    // Helper to check if interest exists by label (not id)
    const interestExistsByLabel = (label) => {
      return customInterests.find(i => (i.label || i.name || '').toLowerCase() === label.toLowerCase());
    };
    
    // Helper to check if location exists by name (not id)
    const locationExistsByName = (name) => {
      return customLocations.find(l => l.name.toLowerCase() === name.toLowerCase());
    };
    
    // Import to Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      
      // 1. Import custom interests
      for (const interest of (importedData.customInterests || [])) {
        const label = tLabel(interest) || interest.name;
        if (!label) continue;
        
        const exists = interestExistsByLabel(label);
        if (exists) {
          skippedInterests++;
          continue;
        }
        
        try {
          const interestId = interest.id || `custom_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
          const newInterest = {
            id: interestId,
            label: label,
            name: label,
            icon: interest.icon || 'üìç',
            inProgress: !!interest.inProgress,
            locked: !!interest.locked
          };
          await database.ref(`customInterests/${interestId}`).set(newInterest);
          addedInterests++;
        } catch (error) {
          console.error('[FIREBASE] Error importing interest:', error);
        }
      }
      
      // 2. Import interest configurations (search settings)
      if (importedData.interestConfig) {
        for (const [interestId, config] of Object.entries(importedData.interestConfig)) {
          try {
            await database.ref(`settings/interestConfig/${interestId}`).set(config);
            updatedConfigs++;
          } catch (error) {
            console.error('[FIREBASE] Error importing config:', error);
          }
        }
      }
      
      // 3. Import interest statuses (active/inactive)
      if (importedData.interestStatus) {
        for (const [interestId, status] of Object.entries(importedData.interestStatus)) {
          try {
            await database.ref(`settings/interestStatus/${interestId}`).set(status);
            updatedStatuses++;
          } catch (error) {
            console.error('[FIREBASE] Error importing status:', error);
          }
        }
      }
      
      // 4. Import locations
      for (const loc of (importedData.customLocations || [])) {
        if (!loc.name) continue;
        
        const exists = locationExistsByName(loc.name);
        if (exists) {
          skippedLocations++;
          continue;
        }
        
        try {
          const newLocation = {
            id: loc.id || Date.now() + Math.floor(Math.random() * 1000),
            name: loc.name.trim(),
            description: loc.description || loc.notes || '',
            notes: loc.notes || '',
            area: loc.area || (loc.areas ? loc.areas[0] : 'sukhumvit'),
            areas: window.BKK.normalizeLocationAreas(loc),
            interests: Array.isArray(loc.interests) ? loc.interests : [],
            lat: loc.lat || null,
            lng: loc.lng || null,
            mapsUrl: loc.mapsUrl || '',
            address: loc.address || '',
            uploadedImage: loc.uploadedImage || null,
            imageUrls: Array.isArray(loc.imageUrls) ? loc.imageUrls : [],
            outsideArea: loc.outsideArea || false,
            missingCoordinates: !loc.lat || !loc.lng,
            duration: loc.duration || 45,
            custom: true,
            status: loc.status || 'active',
            inProgress: !!loc.inProgress,
            locked: !!loc.locked,
            rating: loc.rating || null,
            ratingCount: loc.ratingCount || null,
            fromGoogle: loc.fromGoogle || false,
            addedAt: loc.addedAt || new Date().toISOString()
          };
          
          await database.ref(`cities/${selectedCityId}/locations`).push(newLocation);
          addedLocations++;
        } catch (error) {
          console.error('[FIREBASE] Error importing location:', error);
        }
      }
      
      // 5. Import saved routes (to Firebase)
      for (const route of (importedData.savedRoutes || [])) {
        if (!route.name) continue;
        
        const exists = savedRoutes.find(r => r.name.toLowerCase() === route.name.toLowerCase());
        if (exists) {
          skippedRoutes++;
          continue;
        }
        
        try {
          const routeToSave = stripRouteForStorage({
            ...route,
            id: route.id || Date.now() + Math.floor(Math.random() * 1000),
            importedAt: new Date().toISOString()
          });
          await database.ref(`cities/${selectedCityId}/routes`).push(routeToSave);
          addedRoutes++;
        } catch (error) {
          console.error('[FIREBASE] Error importing route:', error);
        }
      }
      
    } else {
      // STATIC MODE: localStorage (local)
      const newInterests = [...customInterests];
      const newLocations = [...customLocations];
      const newConfig = { ...interestConfig };
      const newStatus = { ...interestStatus };
      
      // 1. Import custom interests
      (importedData.customInterests || []).forEach(interest => {
        const label = tLabel(interest) || interest.name;
        if (!label) return;
        
        const exists = newInterests.find(i => (i.label || i.name || '').toLowerCase() === label.toLowerCase());
        if (exists) {
          skippedInterests++;
          return;
        }
        
        const interestId = interest.id || `custom_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
        newInterests.push({
          id: interestId,
          label: label,
          name: label,
          icon: interest.icon || 'üìç',
          inProgress: !!interest.inProgress,
          locked: !!interest.locked
        });
        addedInterests++;
      });
      
      // 2. Import interest configurations
      if (importedData.interestConfig) {
        Object.entries(importedData.interestConfig).forEach(([id, config]) => {
          newConfig[id] = config;
          updatedConfigs++;
        });
      }
      
      // 3. Import interest statuses
      if (importedData.interestStatus) {
        Object.entries(importedData.interestStatus).forEach(([id, status]) => {
          newStatus[id] = status;
          updatedStatuses++;
        });
      }
      
      // 4. Import locations
      (importedData.customLocations || []).forEach(loc => {
        if (!loc.name) return;
        
        const exists = newLocations.find(l => l.name.toLowerCase() === loc.name.toLowerCase());
        if (exists) {
          skippedLocations++;
          return;
        }
        
        const newLocation = {
          id: loc.id || Date.now() + Math.floor(Math.random() * 1000),
          name: loc.name.trim(),
          description: loc.description || loc.notes || '',
          notes: loc.notes || '',
          area: loc.area || (loc.areas ? loc.areas[0] : 'sukhumvit'),
          areas: window.BKK.normalizeLocationAreas(loc),
          interests: Array.isArray(loc.interests) ? loc.interests : [],
          lat: loc.lat || null,
          lng: loc.lng || null,
          mapsUrl: loc.mapsUrl || '',
          address: loc.address || '',
          uploadedImage: loc.uploadedImage || null,
          imageUrls: Array.isArray(loc.imageUrls) ? loc.imageUrls : [],
          outsideArea: loc.outsideArea || false,
          missingCoordinates: !loc.lat || !loc.lng,
          duration: loc.duration || 45,
          custom: true,
          status: loc.status || 'active',
          inProgress: !!loc.inProgress,
          locked: !!loc.locked,
          rating: loc.rating || null,
          ratingCount: loc.ratingCount || null,
          fromGoogle: loc.fromGoogle || false,
          addedAt: loc.addedAt || new Date().toISOString()
        };
        
        newLocations.push(newLocation);
        addedLocations++;
      });
      
      // 5. Import saved routes
      const newRoutes = [...savedRoutes];
      (importedData.savedRoutes || []).forEach(route => {
        if (!route.name) return;
        
        const exists = newRoutes.find(r => r.name.toLowerCase() === route.name.toLowerCase());
        if (exists) {
          skippedRoutes++;
          return;
        }
        
        newRoutes.push({
          ...route,
          id: route.id || Date.now() + Math.floor(Math.random() * 1000),
          importedAt: new Date().toISOString()
        });
        addedRoutes++;
      });
      
      setCustomInterests(newInterests);
      setCustomLocations(newLocations);
      setSavedRoutes(newRoutes);
      setInterestConfig(newConfig);
      setInterestStatus(newStatus);
      
      localStorage.setItem('bangkok_custom_interests', JSON.stringify(newInterests));
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(newLocations));
      saveRoutesToStorage(newRoutes);
      localStorage.setItem('bangkok_interest_status', JSON.stringify(newStatus));
    }
    
    setShowImportDialog(false);
    setImportedData(null);
    
    // Build detailed report
    const report = [];
    if (addedInterests > 0 || skippedInterests > 0) {
      report.push(`${t("import.interests")} +${addedInterests}`);
    }
    if (updatedConfigs > 0) {
      report.push(`${t("import.configs")} +${updatedConfigs}`);
    }
    if (addedLocations > 0 || skippedLocations > 0) {
      report.push(`${t("import.locations")} +${addedLocations}`);
    }
    if (addedRoutes > 0 || skippedRoutes > 0) {
      report.push(`${t("import.routes")} +${addedRoutes}`);
    }
    
    const totalAdded = addedInterests + addedLocations + addedRoutes + updatedConfigs;
    showToast(report.join(' | ') || t('toast.noImportItems'), totalAdded > 0 ? 'success' : 'warning');
  };

  const addCustomLocation = (closeAfter = true) => {
    if (!newLocation.name.trim() || newLocation.interests.length === 0) {
      return; // Just don't add if validation fails
    }
    
    // Check for duplicate name
    const exists = customLocations.find(loc => 
      loc.name.toLowerCase().trim() === newLocation.name.toLowerCase().trim()
    );
    if (exists) {
      showToast(`"${newLocation.name}" ${t("places.alreadyInList")}`, 'warning');
      return;
    }
    
    // Use provided coordinates (can be null)
    let lat = newLocation.lat;
    let lng = newLocation.lng;
    let outsideArea = false;
    let hasCoordinates = (lat !== null && lng !== null && lat !== 0 && lng !== 0);
    
    // Check if location is within area boundaries (only if has coordinates)
    if (hasCoordinates) {
      const selectedAreas = newLocation.areas || (newLocation.area ? [newLocation.area] : []);
      const inAnyArea = selectedAreas.some(aId => checkLocationInArea(lat, lng, aId).valid);
      outsideArea = !inAnyArea && selectedAreas.length > 0;
      
      if (outsideArea) {
        const areaNames = selectedAreas.map(aId => areaOptions.find(a => a.id === aId)).filter(Boolean).map(a => tLabel(a)).join(', ');
        showToast(
          `${t("toast.outsideAreaWarning")} (${areaNames})`,
          'warning'
        );
      }
    }
    
    const newId = Date.now();
    const locationToAdd = {
      id: newId,
      name: newLocation.name.trim(),
      description: newLocation.description.trim() || newLocation.notes?.trim() || t('general.addedByUser'),
      notes: newLocation.notes?.trim() || '',
      area: (newLocation.areas || [newLocation.area])[0] || 'sukhumvit',
      areas: newLocation.areas || (newLocation.area ? [newLocation.area] : ['sukhumvit']),
      interests: newLocation.interests,
      lat: lat,
      lng: lng,
      mapsUrl: newLocation.mapsUrl || '',
      address: newLocation.address || '',
      uploadedImage: newLocation.uploadedImage || null,
      imageUrls: newLocation.imageUrls || [],
      outsideArea: outsideArea, // Flag for outside area
      missingCoordinates: !hasCoordinates, // Flag for missing coordinates
      duration: 45,
      custom: true,
      status: 'active',
      inProgress: newLocation.inProgress || false,
      locked: newLocation.locked || false,
      addedAt: new Date().toISOString(),
      cityId: selectedCityId
    };
    
    // Save to Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      database.ref(`cities/${selectedCityId}/locations`).push(locationToAdd)
        .then((ref) => {
          console.log('[FIREBASE] Location added to shared database');
          showToast(t('places.placeAddedShared'), 'success');
          
          // If staying open, switch to edit mode
          if (!closeAfter) {
            const addedWithFirebaseId = { ...locationToAdd, firebaseId: ref.key };
            setEditingLocation(addedWithFirebaseId);
            setShowAddLocationDialog(false);
            setShowEditLocationDialog(true);
          }
        })
        .catch((error) => {
          console.error('[FIREBASE] Error adding location:', error);
          showToast(t('toast.saveError'), 'error');
        });
    } else {
      // STATIC MODE: localStorage (local)
      const updated = [...customLocations, locationToAdd];
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      showToast(t('places.placeAdded'), 'success');
      
      // If staying open, switch to edit mode
      if (!closeAfter) {
        setEditingLocation(locationToAdd);
        setShowAddLocationDialog(false);
        setShowEditLocationDialog(true);
      }
    }
    
    // Add to current route if exists (only if has coordinates)
    if (route && hasCoordinates) {
      const updatedRoute = {
        ...route,
        stops: [...route.stops, locationToAdd]
      };
      setRoute(updatedRoute);
    }
    
    if (closeAfter) {
      setShowAddLocationDialog(false);
      setNewLocation({ 
        name: '', 
        description: '', 
        notes: '',
        area: formData.area, 
        areas: [formData.area],
        interests: [], 
        lat: null, 
        lng: null, 
        mapsUrl: '',
        address: '',
        uploadedImage: null,
        imageUrls: []
      });
    }
  };
  
  // Update existing location
  const updateCustomLocation = (closeAfter = true) => {
    if (!newLocation.name?.trim()) {
      showToast(t('places.enterPlaceName'), 'warning');
      return;
    }
    
    // Check for duplicate name (exclude current location)
    const exists = customLocations.find(loc => 
      loc.name.toLowerCase().trim() === newLocation.name.toLowerCase().trim() &&
      loc.id !== editingLocation.id
    );
    if (exists) {
      showToast(`"${newLocation.name}" ${t("places.alreadyInList")}`, 'warning');
      return;
    }
    
    // Check if anything actually changed (normalize null/undefined)
    const hasChanges = (() => {
      const e = editingLocation;
      const n = newLocation;
      const s = (v) => (v || '').toString().trim(); // normalize strings
      const nn = (v) => v ?? null; // normalize null/undefined
      if (s(n.name) !== s(e.name)) return true;
      if (s(n.description) !== s(e.description)) return true;
      if (s(n.notes) !== s(e.notes)) return true;
      if (JSON.stringify(n.areas || []) !== JSON.stringify(e.areas || (e.area ? [e.area] : []))) return true;
      if (JSON.stringify(n.interests || []) !== JSON.stringify(e.interests || [])) return true;
      if (nn(n.lat) !== nn(e.lat) || nn(n.lng) !== nn(e.lng)) return true;
      if (s(n.mapsUrl) !== s(e.mapsUrl)) return true;
      if (s(n.address) !== s(e.address)) return true;
      if (!!n.inProgress !== !!e.inProgress) return true;
      if (!!n.locked !== !!e.locked) return true;
      if (nn(n.uploadedImage) !== nn(e.uploadedImage)) return true;
      return false;
    })();
    
    if (!hasChanges) {
      if (closeAfter) {
        setShowEditLocationDialog(false);
        setEditingLocation(null);
      }
      return; // No toast, no save
    }
    
    // Use provided coordinates (can be null)
    let hasCoordinates = (newLocation.lat !== null && newLocation.lng !== null && 
                          newLocation.lat !== 0 && newLocation.lng !== 0);
    let outsideArea = false;
    
    // Check if location is within area boundaries (only if has coordinates)
    if (hasCoordinates) {
      const selectedAreas = newLocation.areas || (newLocation.area ? [newLocation.area] : []);
      const inAnyArea = selectedAreas.some(aId => checkLocationInArea(newLocation.lat, newLocation.lng, aId).valid);
      outsideArea = !inAnyArea && selectedAreas.length > 0;
      
      if (outsideArea) {
        const areaNames = selectedAreas.map(aId => areaOptions.find(a => a.id === aId)).filter(Boolean).map(a => tLabel(a)).join(', ');
        showToast(
          `${t("toast.outsideAreaWarning")} (${areaNames})`,
          'warning'
        );
      }
    }
    
    const updatedLocation = { 
      ...editingLocation, // Keep existing fields like status, inProgress
      ...newLocation, // Override with edited fields
      area: (newLocation.areas || [newLocation.area])[0] || editingLocation.area || 'sukhumvit',
      areas: newLocation.areas || (newLocation.area ? [newLocation.area] : editingLocation.areas || ['sukhumvit']),
      custom: true, 
      id: editingLocation.id,
      outsideArea: outsideArea, // Flag for outside area
      missingCoordinates: !hasCoordinates // Flag for missing coordinates
    };
    
    // Update in Firebase (or localStorage fallback)
    if (isFirebaseAvailable && database) {
      // DYNAMIC MODE: Firebase (shared)
      const { firebaseId, ...locationData } = updatedLocation;
      
      if (firebaseId) {
        database.ref(`cities/${selectedCityId}/locations/${firebaseId}`).set(locationData)
          .then(() => {
            console.log('[FIREBASE] Location updated in shared database');
            showToast(t('places.placeUpdated'), 'success');
            // Update editingLocation with latest data
            if (!closeAfter) {
              setEditingLocation({ ...updatedLocation, firebaseId });
            }
          })
          .catch((error) => {
            console.error('[FIREBASE] Error updating location:', error);
            showToast(t('toast.updateError'), 'error');
          });
      }
    } else {
      // STATIC MODE: localStorage (local)
      const updated = customLocations.map(loc => 
        loc.id === editingLocation.id ? updatedLocation : loc
      );
      setCustomLocations(updated);
      localStorage.setItem('bangkok_custom_locations', JSON.stringify(updated));
      showToast(t('places.placeUpdated'), 'success');
      // Update editingLocation with latest data
      if (!closeAfter) {
        setEditingLocation(updatedLocation);
      }
    }
    
    if (closeAfter) {
      setShowEditLocationDialog(false);
      setEditingLocation(null);
      setNewLocation({ 
        name: '', 
        description: '', 
        notes: '',
        area: formData.area, 
        areas: [formData.area],
        interests: [], 
        lat: null, 
        lng: null, 
        mapsUrl: '',
        address: '',
        uploadedImage: null,
        imageUrls: []
      });
    }
  };

  // Get current location from GPS
  const getCurrentLocation = () => {
    if (!navigator.geolocation) {
      showToast(t('toast.browserNoGps'), 'error');
      return;
    }
    
    showToast(t('form.searchingLocation'), 'info');
    
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        
        // First update with coordinates
        setNewLocation(prev => ({
          ...prev,
          lat: lat,
          lng: lng,
          mapsUrl: `https://maps.google.com/?q=${lat},${lng}`
        }));
        
        showToast(`${t("toast.locationDetectedCoords")} ${lat.toFixed(5)}, ${lng.toFixed(5)}`, 'success');
        
        // Then try to get address (reverse geocode)
        try {
          const address = await reverseGeocode(lat, lng);
          if (address) {
            setNewLocation(prev => ({
              ...prev,
              address: address
            }));
          }
        } catch (err) {
          console.log('[GPS] Reverse geocode failed (ok):', err);
        }
      },
      (error) => {
        let errorMessage = t('toast.locationFailed');
        
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = t('toast.locationNoPermissionBrowser');
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = t('toast.locationNotAvailable');
            break;
          case error.TIMEOUT:
            errorMessage = t('toast.locationTimeout');
            break;
        }
        
        showToast(`${errorMessage}`, 'error');
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  };

  // Parse Google Maps URL to extract coordinates
  const parseMapsUrl = (url) => {
    if (!url || !url.trim()) {
      setNewLocation({ ...newLocation, lat: null, lng: null, mapsUrl: '' });
      return;
    }

    // Try different Google Maps URL formats
    let lat = null, lng = null;
    
    // Format 1: https://maps.google.com/?q=13.7465,100.4927
    let match = url.match(/[?&]q=([-\d.]+),([-\d.]+)/);
    if (match) {
      lat = parseFloat(match[1]);
      lng = parseFloat(match[2]);
    }
    
    // Format 2: https://www.google.com/maps/@13.7465,100.4927,17z
    if (!match) {
      match = url.match(/@([-\d.]+),([-\d.]+)/);
      if (match) {
        lat = parseFloat(match[1]);
        lng = parseFloat(match[2]);
      }
    }
    
    // Format 3: https://maps.google.com/maps?q=...&ll=13.7465,100.4927
    if (!match) {
      match = url.match(/[?&]ll=([-\d.]+),([-\d.]+)/);
      if (match) {
        lat = parseFloat(match[1]);
        lng = parseFloat(match[2]);
      }
    }
    
    // Format 4: https://goo.gl/maps/... or https://maps.app.goo.gl/...
    // These shortened URLs need to be opened first, so just inform user
    if (!match && (url.includes('goo.gl') || url.includes('maps.app'))) {
      showToast(t('toast.shortLinksHint'), 'warning');
      setNewLocation({ ...newLocation, mapsUrl: url });
      return;
    }
    
    // Format 5: Just coordinates: 13.7465,100.4927 or 13.7465, 100.4927
    if (!match) {
      match = url.match(/^([-\d.]+)\s*,\s*([-\d.]+)$/);
      if (match) {
        lat = parseFloat(match[1]);
        lng = parseFloat(match[2]);
      }
    }
    
    if (lat !== null && lng !== null) {
      setNewLocation({ ...newLocation, lat, lng, mapsUrl: url });
      showToast(`${t("toast.coordsDetected")} ${lat.toFixed(5)}, ${lng.toFixed(5)}`, 'success');
    } else {
      showToast(t('toast.badCoords'), 'error');
      setNewLocation({ ...newLocation, mapsUrl: url });
    }
  };

  // Search address using Google Places API (instead of Geocoding)
  const geocodeAddress = async (address) => {
    if (!address || !address.trim()) {
      showToast(t('form.enterAddress'), 'warning');
      return;
    }

    try {
      showToast(t('places.searchingAddress'), 'info');
      
      // Add city name if not already included
      const cityName = window.BKK.cityNameForSearch || 'Bangkok';
      const countryName = window.BKK.selectedCity?.country || '';
      const searchQuery = address.toLowerCase().includes(cityName.toLowerCase()) 
        ? address 
        : `${address}, ${cityName}${countryName ? ', ' + countryName : ''}`;
      
      // Use Google Places API Text Search
      const response = await fetch(
        `https://places.googleapis.com/v1/places:searchText`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.location,places.formattedAddress'
          },
          body: JSON.stringify({
            textQuery: searchQuery,
            maxResultCount: 1
          })
        }
      );
      
      const data = await response.json();
      
      if (data.places && data.places.length > 0) {
        const place = data.places[0];
        const location = place.location;
        const formattedAddress = place.formattedAddress || place.displayName?.text || searchQuery;
        
        setNewLocation({
          ...newLocation,
          lat: location.latitude,
          lng: location.longitude,
          address: formattedAddress,
          googlePlaceId: place.id || null,
          mapsUrl: `https://maps.google.com/?q=${location.latitude},${location.longitude}`
        });
        
        showToast(`${t("toast.found")} ${formattedAddress}`, 'success');
      } else {
        showToast(t('places.addressNotFoundRetry'), 'error');
      }
    } catch (error) {
      console.error('[GEOCODING] Error:', error);
      showToast(t('toast.addressSearchErrorHint'), 'error');
    }
  };

  // Search places by name - returns multiple results for picking
  const searchPlacesByName = async (query) => {
    if (!query || !query.trim()) return;
    try {
      setLocationSearchResults([]); // show loading state
      const cityForSearch = window.BKK.cityNameForSearch || 'Bangkok';
      const countryForSearch = window.BKK.selectedCity?.country || '';
      const searchQuery = query.toLowerCase().includes(cityForSearch.toLowerCase()) ? query : `${query}, ${cityForSearch}${countryForSearch ? ', ' + countryForSearch : ''}`;
      const response = await fetch('https://places.googleapis.com/v1/places:searchText', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
          'X-Goog-FieldMask': 'places.id,places.displayName,places.location,places.formattedAddress,places.rating,places.userRatingCount'
        },
        body: JSON.stringify({ textQuery: searchQuery, maxResultCount: 5 })
      });
      const data = await response.json();
      if (data.places && data.places.length > 0) {
        setLocationSearchResults(data.places.map(p => ({
          name: p.displayName?.text || '',
          lat: p.location?.latitude,
          lng: p.location?.longitude,
          address: p.formattedAddress || '',
          rating: p.rating,
          ratingCount: p.userRatingCount,
          googlePlaceId: p.id
        })));
      } else {
        setLocationSearchResults([]);
        showToast(t('places.noPlacesFound'), 'warning');
      }
    } catch (err) {
      console.error('[SEARCH] Error:', err);
      showToast(t('toast.searchError'), 'error');
      setLocationSearchResults(null);
    }
  };

  // Search coordinates by place name
  const geocodeByName = async (name) => {
    if (!name || !name.trim()) {
      showToast(t('form.enterPlaceName'), 'warning');
      return;
    }

    try {
      showToast(t('form.searchingByName'), 'info');
      
      // Add city name for better results
      const cityForSearch = window.BKK.cityNameForSearch || 'Bangkok';
      const countryForSearch = window.BKK.selectedCity?.country || '';
      const searchQuery = name.toLowerCase().includes(cityForSearch.toLowerCase()) 
        ? name 
        : `${name}, ${cityForSearch}${countryForSearch ? ', ' + countryForSearch : ''}`;
      
      const response = await fetch(
        `https://places.googleapis.com/v1/places:searchText`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.location,places.formattedAddress'
          },
          body: JSON.stringify({
            textQuery: searchQuery,
            maxResultCount: 1
          })
        }
      );
      
      const data = await response.json();
      
      if (data.places && data.places.length > 0) {
        const place = data.places[0];
        const location = place.location;
        const formattedAddress = place.formattedAddress || '';
        
        setNewLocation({
          ...newLocation,
          lat: location.latitude,
          lng: location.longitude,
          address: formattedAddress,
          googlePlaceId: place.id || null,
          mapsUrl: `https://maps.google.com/?q=${location.latitude},${location.longitude}`
        });
        
        showToast(`${t("toast.foundPlace")} ${place.displayName?.text || name}`, 'success');
      } else {
        showToast(t('places.placeNotFoundRetry'), 'error');
      }
    } catch (error) {
      console.error('[GEOCODE BY NAME] Error:', error);
      showToast(t('toast.searchError'), 'error');
    }
  };

  // Reverse geocode: get address from coordinates
  const reverseGeocode = async (lat, lng) => {
    try {
      const response = await fetch(
        `https://places.googleapis.com/v1/places:searchText`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.formattedAddress'
          },
          body: JSON.stringify({
            textQuery: `${lat},${lng}`,
            maxResultCount: 1
          })
        }
      );
      
      const data = await response.json();
      
      if (data.places && data.places.length > 0) {
        return data.places[0].formattedAddress || '';
      }
      return '';
    } catch (error) {
      console.error('[REVERSE GEOCODE] Error:', error);
      return '';
    }
  };

  const toggleStopActive = (stopIndex) => {
    const stopName = route.stops[stopIndex]?.name?.toLowerCase().trim();
    if (!stopName) return;
    const newDisabledStops = disabledStops.includes(stopName)
      ? disabledStops.filter(n => n !== stopName)
      : [...disabledStops, stopName];
    
    setDisabledStops(newDisabledStops);
    
    // Regenerate map URL with only active stops
    const activeStops = route.stops.filter(s => 
      !newDisabledStops.includes(s.name?.toLowerCase().trim())
    );
    
    const hasStartPoint = startPointCoords && startPointCoords.lat && startPointCoords.lng;
    const origin = hasStartPoint
      ? `${startPointCoords.lat},${startPointCoords.lng}`
      : activeStops.length > 0 ? `${activeStops[0].lat},${activeStops[0].lng}` : '';
    const stopsForUrls = hasStartPoint ? activeStops : activeStops.slice(1);
    const isCircular = route.preferences?.circular || false;
    const urls = activeStops.length > 0
      ? window.BKK.buildGoogleMapsUrls(stopsForUrls, origin, isCircular, googleMaxWaypoints)
      : [];
    
    // Use first URL as legacy mapUrl for backward compat
    const mapUrl = urls.length > 0 ? urls[0].url : '';
    
    setRoute({...route, mapUrl, mapUrls: urls});
  };




  return (
    <div className="min-h-screen bg-gradient-to-br from-amber-50 to-rose-50" dir={window.BKK.i18n.isRTL() ? 'rtl' : 'ltr'}>
      {/* Loading Overlay */}
      {!isDataLoaded && (
        <div className="fixed inset-0 bg-gradient-to-br from-amber-50 to-rose-50 z-[9999] flex flex-col items-center justify-center">
          <div className="text-center">
            <div className="text-5xl mb-4 animate-bounce">üó∫Ô∏è</div>
            <h2 className="text-xl font-bold text-gray-700 mb-2">{tLabel(window.BKK.selectedCity) || 'City Explorer'}</h2>
            <div className="flex items-center justify-center gap-2 text-gray-500">
              <svg className="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
              </svg>
              <span className="text-sm">{t("general.loading")}</span>
            </div>
          </div>
        </div>
      )}

      {(() => {
        const theme = window.BKK.selectedCity?.theme || { color: '#e11d48', iconLeft: 'üèôÔ∏è', iconRight: 'üó∫Ô∏è' };
        const c = theme.color || '#e11d48';
        return (
      <div style={{
        background: `linear-gradient(135deg, ${c} 0%, ${c}dd 50%, ${c} 100%)`,
        backgroundSize: '200% 200%',
        animation: 'headerShimmer 6s ease infinite',
        padding: '6px 16px',
        boxShadow: `0 2px 8px ${c}33`
      }}>
        <div className="flex items-center justify-center gap-1.5">
          <span style={{ fontSize: '14px' }}>{theme.iconLeft || window.BKK.selectedCity?.secondaryIcon || 'üèôÔ∏è'}</span>
          <h1 style={{ 
            fontSize: '16px', 
            fontWeight: '800', 
            color: 'white',
            letterSpacing: '0.5px',
            margin: 0,
            textShadow: '0 1px 3px rgba(0,0,0,0.2)'
          }}>{tLabel(window.BKK.selectedCity) || 'City Explorer'}</h1>
          <span style={{ fontSize: '14px' }}>{theme.iconRight || window.BKK.selectedCity?.icon || 'üó∫Ô∏è'}</span>
          <span style={{ 
            fontSize: '8px', 
            color: 'rgba(255,255,255,0.5)',
            alignSelf: 'flex-end',
            marginBottom: '2px'
          }}>v{window.BKK.VERSION}</span>
        </div>
      </div>
      );
      })()}

      {/* Update Banner */}
      {updateAvailable && (
        <div className="mx-2 mb-2 bg-green-500 text-white rounded-lg p-2 flex items-center justify-between shadow-lg animate-pulse"
          style={{ animationDuration: '2s' }}>
          <span className="text-sm font-bold">{t("general.newVersionAvailableBanner")}</span>
          <button
            onClick={applyUpdate}
            className="bg-white text-green-700 px-3 py-1 rounded-lg text-sm font-bold hover:bg-green-100"
          >
            {t("general.updateNow")}
          </button>
        </div>
      )}      <div className="max-w-4xl mx-auto p-2 sm:p-4 pb-32">
        {/* WIZARD MODE */}
        {wizardMode && wizardStep < 3 && (
          <div className="view-fade-in">
            {/* Wizard Header */}
            <div style={{ textAlign: 'center', marginBottom: '4px' }}>
              {/* Advanced mode toggle and language toggle at top */}
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0px' }}>
                <button onClick={() => { setWizardMode(false); localStorage.setItem('bangkok_wizard_mode', 'false'); }} style={{ background: 'none', border: 'none', color: '#9ca3af', fontSize: '10px', cursor: 'pointer', textDecoration: 'underline' }}>
                  {`‚öôÔ∏è ${t("nav.advancedMode")}`}
                </button>
                <button onClick={() => switchLanguage(currentLang === 'he' ? 'en' : 'he')} style={{ background: 'none', border: '1px solid #e5e7eb', borderRadius: '12px', padding: '2px 8px', color: '#6b7280', fontSize: '10px', cursor: 'pointer' }}>
                  {currentLang === 'he' ? 'üá¨üáß EN' : 'üáÆüá± ◊¢◊ë'}
                </button>
              </div>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '6px', marginBottom: '4px' }}>
                {[1, 2, 3].map(step => (
                  <div key={step} style={{
                    width: '28px', height: '28px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    fontSize: '12px', fontWeight: 'bold',
                    background: wizardStep === step ? '#e11d48' : wizardStep > step ? '#22c55e' : '#e5e7eb',
                    color: wizardStep >= step ? 'white' : '#9ca3af',
                    transition: 'all 0.3s'
                  }}>{wizardStep > step ? '‚úì' : step}</div>
                ))}
              </div>
            </div>

            {/* Step 1: Choose Area */}
            {wizardStep === 1 && (
              <div className="bg-white rounded-xl shadow-lg p-3">
                {/* City Selector - small button only */}
                {Object.values(window.BKK.cities || {}).filter(c => c.active !== false).length > 1 && (
                  <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '4px' }}>
                    <select
                      value={selectedCityId}
                      onChange={(e) => switchCity(e.target.value)}
                      style={{ padding: '4px 8px', borderRadius: '12px', border: '1.5px solid #e5e7eb', fontSize: '12px', fontWeight: 'bold', color: '#374151', background: 'white', cursor: 'pointer' }}
                    >
                      {Object.values(window.BKK.cities || {}).filter(c => c.active !== false).map(city => (
                        <option key={city.id} value={city.id}>{city.icon} {tLabel(city)}</option>
                      ))}
                    </select>
                  </div>
                )}

                <h2 style={{ textAlign: 'center', fontSize: '16px', fontWeight: 'bold', marginBottom: '1px' }}>{`üìç ${t("wizard.step1Title")}`}</h2>
                <p style={{ textAlign: 'center', fontSize: '11px', color: '#6b7280', marginBottom: '6px' }}>
                  {t("wizard.step1Subtitle")}
                  {' '}
                  <button onClick={() => showHelpFor('main')} style={{ background: 'none', border: 'none', fontSize: '11px', cursor: 'pointer', color: '#3b82f6', marginRight: '4px', textDecoration: 'underline' }}>
                    {t("general.howItWorks")}
                  </button>
                </p>
                
                {/* Map button */}
                <div style={{ textAlign: 'center', marginBottom: '8px' }}>
                  <button
                    onClick={() => { setMapMode('areas'); setShowMapModal(true); }}
                    style={{ background: 'linear-gradient(135deg, #10b981, #059669)', color: 'white', border: 'none', borderRadius: '10px', padding: '6px 16px', fontSize: '12px', fontWeight: 'bold', cursor: 'pointer', boxShadow: '0 2px 6px rgba(5,150,105,0.3)' }}
                  >{t("wizard.showMap")}</button>
                </div>

                {/* Area Grid */}
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '4px', marginBottom: '6px' }}>
                  {(window.BKK.areaOptions || []).map(area => {
                    const safety = (window.BKK.areaCoordinates?.[area.id]?.safety) || 'safe';
                    return (
                    <button
                      key={area.id}
                      onClick={() => setFormData({...formData, area: area.id, searchMode: 'area'})}
                      style={{
                        padding: '6px 6px', borderRadius: '8px', border: formData.area === area.id && formData.searchMode === 'area' ? '2px solid #2563eb' : '1.5px solid #e5e7eb',
                        background: formData.area === area.id && formData.searchMode === 'area' ? '#eff6ff' : 'white',
                        cursor: 'pointer', textAlign: window.BKK.i18n.isRTL() ? 'right' : 'left', direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr', transition: 'all 0.2s'
                      }}
                    >
                      <div style={{ fontWeight: 'bold', fontSize: '12px', color: '#1f2937' }}>
                        {tLabel(area)}
                        {safety === 'caution' && <span style={{ color: '#f59e0b', marginRight: '3px' }} title={t("general.cautionArea")}>‚ö†Ô∏è</span>}
                        {safety === 'danger' && <span style={{ color: '#ef4444', marginRight: '3px' }} title={t("general.dangerArea")}>üî¥</span>}
                      </div>
                      <div style={{ fontSize: '9px', color: '#6b7280', marginTop: '1px' }}>{tDesc(area) || tLabel(area)}</div>
                    </button>
                    );
                  })}
                </div>
                
                {/* Radius - search near me */}
                <button
                  onClick={() => {
                    if (navigator.geolocation) {
                      navigator.geolocation.getCurrentPosition(
                        (pos) => {
                          setFormData({...formData, searchMode: 'radius', radiusMeters: 1000, currentLat: pos.coords.latitude, currentLng: pos.coords.longitude, radiusPlaceName: t('wizard.myLocation'), radiusSource: 'gps'});
                          showToast(t('wizard.locationFound'), 'success');
                        },
                        () => showToast(t('toast.locationInaccessible'), 'warning')
                      );
                    }
                  }}
                  style={{
                    width: '100%', padding: '8px', borderRadius: '10px', cursor: 'pointer', textAlign: 'center', direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr',
                    border: formData.searchMode === 'radius' ? '2px solid #2563eb' : '1.5px solid #e5e7eb',
                    background: formData.searchMode === 'radius' ? '#eff6ff' : 'white',
                    marginBottom: '4px', transition: 'all 0.2s'
                  }}
                >
                  <div style={{ fontWeight: 'bold', fontSize: '13px', color: '#2563eb' }}>{`üìç ${t("general.nearMe")}`}</div>
                  <div style={{ fontSize: '10px', color: '#6b7280', marginTop: '1px' }}>GPS (1km)</div>
                </button>

                {/* All Bangkok option */}
                <button
                  onClick={() => setFormData({...formData, searchMode: 'all'})}
                  style={{
                    width: '100%', padding: '8px', borderRadius: '10px', cursor: 'pointer', textAlign: 'center', direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr',
                    border: formData.searchMode === 'all' ? '2px solid #8b5cf6' : '1.5px solid #e5e7eb',
                    background: formData.searchMode === 'all' ? 'linear-gradient(135deg, #f5f3ff, #ede9fe)' : 'white',
                    marginBottom: '6px', transition: 'all 0.2s'
                  }}
                >
                  <div style={{ fontWeight: 'bold', fontSize: '13px', color: '#7c3aed' }}>{`üåè ${t('general.all')} ${tLabel(window.BKK.selectedCity) || t('general.city')}`}</div>
                  <div style={{ fontSize: '10px', color: '#6b7280', marginTop: '1px' }}>{t('places.thisCity')}</div>
                </button>

                {/* Continue button */}
                <button
                  onClick={() => { setWizardStep(2); window.scrollTo(0, 0); }}
                  disabled={!formData.area && formData.searchMode !== 'radius' && formData.searchMode !== 'all'}
                  style={{
                    width: '100%', padding: '12px', borderRadius: '12px', border: 'none', cursor: formData.area || formData.searchMode === 'radius' || formData.searchMode === 'all' ? 'pointer' : 'not-allowed',
                    background: formData.area || formData.searchMode === 'radius' || formData.searchMode === 'all' ? 'linear-gradient(135deg, #2563eb, #1d4ed8)' : '#d1d5db',
                    color: 'white', fontSize: '16px', fontWeight: 'bold', boxShadow: formData.area || formData.searchMode === 'radius' || formData.searchMode === 'all' ? '0 4px 6px rgba(37,99,235,0.3)' : 'none'
                  }}
                >{t("general.next")}</button>
              </div>
            )}

            {/* Step 2: Choose Interests */}
            {wizardStep === 2 && (
              <div className="bg-white rounded-xl shadow-lg p-3">
                <h2 style={{ textAlign: 'center', fontSize: '17px', fontWeight: 'bold', marginBottom: '2px' }}>{`‚≠ê ${t("wizard.step2Title")}`}</h2>
                <p style={{ textAlign: 'center', fontSize: '11px', color: '#6b7280', marginBottom: '10px' }}>{t("wizard.step2Subtitle")}</p>
                
                {/* Interest Grid */}
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '6px', marginBottom: '12px' }}>
                  {allInterestOptions.filter(option => {
                    const status = interestStatus[option.id];
                    if (option.uncovered) return status === true;
                    return status !== false;
                  }).filter(option => isInterestValid(option.id)).map(option => {
                    const isSelected = formData.interests.includes(option.id);
                    return (
                      <button
                        key={option.id}
                        onClick={() => {
                          const newInterests = isSelected
                            ? formData.interests.filter(id => id !== option.id)
                            : [...formData.interests, option.id];
                          setFormData({...formData, interests: newInterests});
                        }}
                        style={{
                          padding: '8px 4px', borderRadius: '10px', cursor: 'pointer', textAlign: 'center', transition: 'all 0.2s',
                          border: isSelected ? '2px solid #2563eb' : '2px solid #e5e7eb',
                          background: isSelected ? '#eff6ff' : 'white'
                        }}
                      >
                        <div style={{ fontSize: '22px', marginBottom: '2px' }}>{option.icon?.startsWith?.('data:') ? <img src={option.icon} alt="" style={{ width: '24px', height: '24px', objectFit: 'contain', display: 'inline' }} /> : option.icon}</div>
                        <div style={{ fontWeight: '700', fontSize: '11px', color: isSelected ? '#1e40af' : '#374151', wordBreak: 'break-word' }}>{tLabel(option)}</div>
                      </button>
                    );
                  })}
                </div>

                {/* Selected count + buttons */}
                <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                  <button
                    onClick={() => { setWizardStep(1); window.scrollTo(0, 0); }}
                    style={{ flex: '0 0 auto', padding: '12px 20px', borderRadius: '12px', border: '2px solid #e5e7eb', background: 'white', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold', color: '#6b7280' }}
                  >{t("general.back")}</button>
                  <button
                    onClick={() => { generateRoute(); setWizardStep(3); window.scrollTo(0, 0); }}
                    disabled={formData.interests.length === 0}
                    style={{
                      flex: 1, padding: '14px', borderRadius: '12px', border: 'none',
                      cursor: formData.interests.length > 0 ? 'pointer' : 'not-allowed',
                      background: formData.interests.length > 0 ? 'linear-gradient(135deg, #2563eb, #1d4ed8)' : '#d1d5db',
                      color: 'white', fontSize: '14px', fontWeight: 'bold',
                      boxShadow: formData.interests.length > 0 ? '0 4px 6px rgba(37,99,235,0.3)' : 'none'
                    }}
                  >{`üîç ${t('wizard.findPlaces')} (${formData.maxStops})`}</button>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Wizard Step 3 = results, or normal mode */}
        
        {/* Navigation Tabs - hidden in wizard mode */}
        {!wizardMode && (
        <div className="flex flex-wrap gap-1 mb-4 bg-white rounded-lg p-1.5 shadow">
          <button
            onClick={() => { setCurrentView('form'); window.scrollTo(0, 0); }}
            className={`flex-1 min-w-0 py-1.5 px-1 rounded-lg font-medium transition text-[9px] sm:text-xs leading-tight ${
              currentView === 'form' || currentView === 'route' ? 'bg-rose-500 text-white' : 'text-gray-600 hover:bg-gray-100'
            }`}
          >
            <div className="text-center">üó∫Ô∏è</div>
            <div className="truncate text-center text-[8px]">{t("nav.route")}</div>
          </button>
          <button
            onClick={() => { setCurrentView('saved'); window.scrollTo(0, 0); }}
            className={`flex-1 min-w-0 py-1.5 px-1 rounded-lg font-medium transition text-[9px] sm:text-xs leading-tight ${
              currentView === 'saved' ? 'bg-blue-500 text-white' : 'text-gray-600 hover:bg-gray-100'
            }`}
          >
            <div className="text-center">üíæ</div>
            <div className="truncate text-center text-[8px]">{t("nav.saved")} {citySavedRoutes.length > 0 ? `(${citySavedRoutes.length})` : ''}</div>
          </button>
          <button
            onClick={() => { setCurrentView('myPlaces'); window.scrollTo(0, 0); }}
            className={`flex-1 min-w-0 py-1.5 px-1 rounded-lg font-medium transition text-[9px] sm:text-xs leading-tight ${
              currentView === 'myPlaces' || currentView === 'search' ? 'bg-teal-500 text-white' : 'text-gray-600 hover:bg-gray-100'
            }`}
          >
            <div className="text-center">üìç</div>
            <div className="truncate text-center text-[8px]">{t("nav.myPlaces")} {cityCustomLocations.filter(l => l.status !== 'blacklist').length > 0 ? `(${cityCustomLocations.filter(l => l.status !== 'blacklist').length})` : ''}</div>
          </button>
          <button
            onClick={() => { setCurrentView('myInterests'); window.scrollTo(0, 0); }}
            className={`flex-1 min-w-0 py-1.5 px-1 rounded-lg font-medium transition text-[9px] sm:text-xs leading-tight ${
              currentView === 'myInterests' ? 'bg-purple-500 text-white' : 'text-gray-600 hover:bg-gray-100'
            }`}
          >
            <div className="text-center">üè∑Ô∏è</div>
            <div className="truncate text-center text-[8px]">{t("nav.myInterests")} {(() => {
              const builtIn = (window.BKK.interestOptions || []).filter(i => isInterestValid(i.id) && interestStatus[i.id] !== false);
              const uncov = (window.BKK.uncoveredInterests || []).filter(i => isInterestValid(i.id) && interestStatus[i.id] === true);
              const cust = (cityCustomInterests || []).filter(i => isInterestValid(i.id) && interestStatus[i.id] !== false);
              const total = builtIn.length + uncov.length + cust.length;
              return total > 0 ? `(${total})` : '';
            })()}</div>
          </button>
          <button
            onClick={() => {
              if (isUnlocked || !adminPassword) {
                setCurrentView('settings');
              } else {
                setShowPasswordDialog(true);
              }
              window.scrollTo(0, 0);
            }}
            className={`hidden sm:flex flex-1 min-w-0 py-1.5 px-1 rounded-lg font-medium transition text-[9px] sm:text-xs leading-tight ${
              currentView === 'settings' ? 'bg-slate-500 text-white' : 'text-gray-600 hover:bg-gray-100'
            }`}
            style={{ flexDirection: 'column', alignItems: 'center' }}
          >
            <div className="text-center relative inline-flex items-center justify-center w-full">
              {(isUnlocked || !adminPassword) ? 'üîì' : 'üîí'}
              {hasNewFeedback && isCurrentUserAdmin && (
                <span className="absolute -top-1 left-1 w-2.5 h-2.5 bg-red-500 rounded-full border border-white"></span>
              )}
            </div>
            <div className="truncate text-center text-[8px]">{t("settings.title")}</div>
          </button>
        </div>
        )}

        {/* Wizard Step 3: Back/restart buttons */}
        {wizardMode && wizardStep === 3 && (
          <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
            <button
              onClick={() => { setWizardStep(2); setRoute(null); setCurrentView('form'); window.scrollTo(0, 0); }}
              style={{ padding: '8px 16px', borderRadius: '10px', border: '2px solid #e5e7eb', background: 'white', cursor: 'pointer', fontSize: '12px', fontWeight: 'bold', color: '#6b7280' }}
            >{t("general.back")}</button>
            <button
              onClick={() => { setWizardStep(1); setRoute(null); setCurrentView('form'); setFormData(prev => ({...prev, interests: []})); window.scrollTo(0, 0); }}
              style={{ padding: '8px 16px', borderRadius: '10px', border: '2px solid #e5e7eb', background: 'white', cursor: 'pointer', fontSize: '12px', fontWeight: 'bold', color: '#6b7280' }}
            >{t("general.startOver")}</button>
          </div>
        )}

        {/* Wizard Step 3: Loading spinner while generating */}
        {wizardMode && wizardStep === 3 && isGenerating && (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '40px 20px' }}>
            <svg className="animate-spin" style={{ width: '40px', height: '40px', color: '#2563eb', marginBottom: '12px' }} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle style={{ opacity: 0.25 }} cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path style={{ opacity: 0.75 }} fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
            </svg>
            <p style={{ fontSize: '14px', fontWeight: 'bold', color: '#374151' }}>{`üîç ${t("general.searching")}...`}</p>
            <p style={{ fontSize: '11px', color: '#6b7280', marginTop: '4px' }}>{t("general.mayTakeSeconds")}</p>
          </div>
        )}

        {/* Form View */}

        {/* === VIEWS (from views.js) === */}
        {currentView === 'form' && (!wizardMode || wizardStep === 3) && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-3 space-y-3">
            {/* Form inputs - hidden in wizard step 3 */}
            {!wizardMode && (<>
            {/* City selector for advanced mode */}
            {Object.values(window.BKK.cities || {}).filter(c => c.active !== false).length > 1 && (
              <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '2px' }}>
                <select
                  value={selectedCityId}
                  onChange={(e) => switchCity(e.target.value)}
                  style={{ padding: '3px 8px', borderRadius: '12px', border: '1.5px solid #e5e7eb', fontSize: '12px', fontWeight: 'bold', color: '#374151', background: 'white', cursor: 'pointer' }}
                >
                  {Object.values(window.BKK.cities || {}).filter(c => c.active !== false).map(city => (
                    <option key={city.id} value={city.id}>{city.icon} {tLabel(city)}</option>
                  ))}
                </select>
              </div>
            )}
            <div className="flex items-center justify-center gap-2">
              <h2 className="text-base font-bold text-center">{t("wizard.step1Title")}</h2>
              <button
                onClick={() => showHelpFor('main')}
                className="text-gray-400 hover:text-blue-500 text-sm"
                title={t("general.help")}
              >
                {t("general.help")}
              </button>
              <button
                onClick={() => { setWizardMode(true); setWizardStep(1); localStorage.setItem('bangkok_wizard_mode', 'true'); setRoute(null); }}
                style={{ background: 'none', border: 'none', color: '#9ca3af', fontSize: '10px', cursor: 'pointer', textDecoration: 'underline' }}
                title={t("nav.switchToQuick")}
              >
                {`üöÄ ${t('nav.quickMode')}`}
              </button>
              <button onClick={() => switchLanguage(currentLang === 'he' ? 'en' : 'he')} style={{ background: 'none', border: '1px solid #e5e7eb', borderRadius: '12px', padding: '2px 8px', color: '#6b7280', fontSize: '10px', cursor: 'pointer' }}>
                {currentLang === 'he' ? 'üá¨üáß EN' : 'üáÆüá± ◊¢◊ë'}
              </button>
            </div>

            {/* Split Layout: Mode selector + content (right) | Interests (left) */}
            <div className="flex gap-0 items-start" style={{ paddingBottom: '60px' }}>
              
              {/* Right Column: Search Mode */}
              <div className="flex-shrink-0 flex flex-col" style={{ width: rightColWidth + 'px' }}>
                {/* Map button - prominent */}
                <button
                  onClick={() => { 
                    setMapMode(formData.searchMode === 'radius' && formData.currentLat ? 'radius' : 'areas'); 
                    setShowMapModal(true); 
                  }}
                  className="w-full mb-2 py-1.5 rounded-lg text-[10px] font-bold"
                  style={{ background: 'linear-gradient(135deg, #10b981, #059669)', color: 'white', boxShadow: '0 2px 4px rgba(5,150,105,0.3)' }}
                >{t("wizard.showMap")}</button>

                {/* 3-way mode toggle: ◊î◊õ◊ú / ◊ê◊ô◊ñ◊ï◊® / ◊®◊ì◊ô◊ï◊° */}
                <div className="flex bg-gray-200 rounded-lg p-0.5 mb-2">
                  <button
                    onClick={() => setFormData({...formData, searchMode: 'all'})}
                    className={`flex-1 py-1 rounded text-[9px] font-bold transition ${
                      formData.searchMode === 'all' ? 'bg-white shadow text-purple-600' : 'text-gray-500'
                    }`}
                  >{`üåè ${t("form.allMode")}`}</button>
                  <button
                    onClick={() => setFormData({...formData, searchMode: 'area'})}
                    className={`flex-1 py-1 rounded text-[9px] font-bold transition ${
                      formData.searchMode === 'area' ? 'bg-white shadow text-blue-600' : 'text-gray-500'
                    }`}
                  >{t("form.areaMode")}</button>
                  <button
                    onClick={() => setFormData({...formData, searchMode: 'radius'})}
                    className={`flex-1 py-1 rounded text-[9px] font-bold transition ${
                      formData.searchMode === 'radius' ? 'bg-white shadow text-blue-600' : 'text-gray-500'
                    }`}
                  >{t("form.radiusMode")}</button>
                </div>
                
                {formData.searchMode === 'all' ? (
                  <div style={{ padding: '8px', textAlign: 'center', color: '#7c3aed', fontSize: '11px', fontWeight: 'bold' }}>
                    {`üåè ${t("general.all")} ${tLabel(window.BKK.selectedCity) || t('general.city')}`}
                  </div>
                ) : formData.searchMode === 'area' ? (
                  /* Area Mode - GRID layout */
                  <div>
                    <button
                      onClick={detectArea}
                      disabled={isLocating}
                      className={`w-full mb-1.5 py-1 rounded-lg text-[9px] font-bold border transition ${
                        isLocating 
                          ? 'bg-gray-100 text-gray-400 border-gray-200' 
                          : 'bg-blue-50 text-blue-600 border-blue-200 hover:bg-blue-100'
                      }`}
                    >
                      {isLocating ? t('form.locating') : t('form.locateMe')}
                    </button>
                    <div className="border border-gray-200 rounded-lg p-1">
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' }}>
                        {areaOptions.map(area => (
                          <button
                            key={area.id}
                            onClick={() => setFormData({...formData, area: area.id})}
                            style={{
                              border: formData.area === area.id ? '2px solid #3b82f6' : '1.5px solid #e5e7eb',
                              backgroundColor: formData.area === area.id ? '#dbeafe' : '#ffffff',
                              padding: '4px 2px',
                              borderRadius: '6px',
                              textAlign: 'center',
                              lineHeight: '1.1'
                            }}
                          >
                            <div style={{
                              fontWeight: '700',
                              fontSize: '10px',
                              color: formData.area === area.id ? '#1e40af' : '#374151',
                              wordBreak: 'break-word'
                            }}>{tLabel(area)}</div>
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>
                ) : (
                  /* Radius Mode */
                  <div className="border border-blue-100 rounded-lg p-2 bg-blue-50/30 space-y-2">
                    {/* Radius slider */}
                    <div className="text-center">
                      <label className="font-medium text-[10px] block text-center mb-0.5">{t("form.searchRadius")}</label>
                      <div className="text-lg font-bold text-blue-600">{formData.radiusMeters}m</div>
                      <input
                        type="range"
                        min="100"
                        max="2000"
                        step="100"
                        value={formData.radiusMeters}
                        onChange={(e) => setFormData({...formData, radiusMeters: parseInt(e.target.value)})}
                        className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                        style={{ accentColor: '#ea580c' }}
                      />
                      <div className="flex justify-between text-[8px] text-gray-400 mt-0.5">
                        <span>100m</span>
                        <span>2km</span>
                      </div>
                    </div>

                    {/* Source toggle: GPS vs My Place - NO coord clearing */}
                    <div className="flex bg-white rounded p-0.5 border border-blue-200">
                      <button
                        onClick={() => {
                          // Restore GPS coords if available
                          setFormData(prev => ({ 
                            ...prev, 
                            radiusSource: 'gps',
                            currentLat: prev.gpsLat || prev.currentLat,
                            currentLng: prev.gpsLng || prev.currentLng
                          }));
                        }}
                        className={`flex-1 py-1 rounded text-[9px] font-bold transition ${
                          formData.radiusSource === 'gps' ? 'bg-blue-500 text-white' : 'text-gray-500'
                        }`}
                      >üìç GPS</button>
                      <button
                        onClick={() => {
                          // Restore place coords if available
                          const savedPlace = formData.radiusPlaceId 
                            ? customLocations.find(l => l.id === formData.radiusPlaceId)
                            : null;
                          setFormData(prev => ({ 
                            ...prev, 
                            radiusSource: 'myplace',
                            currentLat: savedPlace?.lat || prev.currentLat,
                            currentLng: savedPlace?.lng || prev.currentLng
                          }));
                          if (formData.radiusPlaceName) {
                            setPlaceSearchQuery(formData.radiusPlaceName);
                          }
                        }}
                        className={`flex-1 py-1 rounded text-[9px] font-bold transition ${
                          formData.radiusSource === 'myplace' ? 'bg-blue-500 text-white' : 'text-gray-500'
                        }`}
                      >{t("general.myPlace")}</button>
                    </div>
                    
                    {formData.radiusSource === 'gps' ? (
                      /* GPS Mode */
                      <button
                        onClick={() => {
                          if (!navigator.geolocation) {
                            showToast(t('toast.browserNoLocation'), 'error');
                            return;
                          }
                          setIsLocating(true);
                          navigator.geolocation.getCurrentPosition(
                            (position) => {
                              const { latitude, longitude } = position.coords;
                              const lat = parseFloat(latitude.toFixed(6));
                              const lng = parseFloat(longitude.toFixed(6));
                              setFormData(prev => ({ 
                                ...prev, 
                                currentLat: lat, 
                                currentLng: lng,
                                gpsLat: lat,
                                gpsLng: lng
                              }));
                              showToast(t('form.locationDetectedShort'), 'success');
                              setIsLocating(false);
                            },
                            (error) => {
                              setIsLocating(false);
                              showToast(error.code === 1 ? t('places.noLocationPermission') : t('toast.locationUnavailable'), 'error');
                            },
                            { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                          );
                        }}
                        disabled={isLocating}
                        className={`w-full py-1.5 rounded-lg text-[10px] font-bold transition ${
                          isLocating ? 'bg-gray-300 text-gray-500' 
                          : formData.currentLat ? 'bg-green-500 text-white hover:bg-green-600' 
                          : 'bg-blue-500 text-white hover:bg-blue-600'
                        }`}
                      >
                        {isLocating ? t('form.locating') : formData.currentLat ? t('places.updateLocation') : t('places.findLocation')}
                      </button>
                    ) : (
                      /* My Place Mode */
                      <div className="space-y-1">
                        <div style={{ position: 'relative' }}>
                          <input
                            type="text"
                            value={placeSearchQuery}
                            onChange={(e) => setPlaceSearchQuery(e.target.value)}
                            placeholder={t("form.searchMyPlace")}
                            className="w-full p-1.5 border border-blue-200 rounded-lg text-[10px] focus:border-blue-400 focus:outline-none"
                            dir={window.BKK.i18n.isRTL() ? "rtl" : "ltr"}
                            style={{ paddingLeft: '24px' }}
                          />
                          {(placeSearchQuery || formData.radiusPlaceId) && (
                            <button
                              onClick={() => {
                                setPlaceSearchQuery('');
                                setFormData(prev => ({ ...prev, radiusPlaceId: null, radiusPlaceName: '', currentLat: null, currentLng: null }));
                              }}
                              style={{ position: 'absolute', left: '4px', top: '50%', transform: 'translateY(-50%)', background: '#9ca3af', color: 'white', border: 'none', borderRadius: '50%', width: '16px', height: '16px', fontSize: '9px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                              title={t("general.clearSelection")}
                            >‚úï</button>
                          )}
                        </div>
                        <div className="max-h-48 overflow-y-auto bg-white rounded border border-gray-200">
                          {cityCustomLocations
                            .filter(loc => loc.lat && loc.lng && loc.status !== 'blacklist')
                            .filter(loc => !placeSearchQuery || loc.name.toLowerCase().includes(placeSearchQuery.toLowerCase()))
                            .slice(0, 30)
                            .map(loc => (
                              <button
                                key={loc.id}
                                onClick={() => {
                                  setFormData(prev => ({
                                    ...prev,
                                    currentLat: loc.lat,
                                    currentLng: loc.lng,
                                    radiusPlaceId: loc.id,
                                    radiusPlaceName: loc.name
                                  }));
                                  setPlaceSearchQuery(loc.name);
                                }}
                                className={`w-full text-right p-1.5 text-[10px] border-b border-gray-100 hover:bg-blue-50 transition ${
                                  formData.radiusPlaceId === loc.id ? 'bg-blue-100 font-bold' : ''
                                }`}
                              >
                                <div className="flex items-center gap-1">
                                  <span className="truncate">{loc.name}</span>
                                </div>
                              </button>
                            ))
                          }
                          {cityCustomLocations.filter(loc => loc.lat && loc.lng && loc.status !== 'blacklist').length === 0 && (
                            <div className="p-2 text-center text-[10px] text-gray-400">{t("places.noPlacesWithCoords")}</div>
                          )}
                        </div>
                      </div>
                    )}
                    
                    {/* Coordinates display - compact, no overflow */}
                    {formData.currentLat && (
                      <div className="bg-white rounded p-1 text-[8px] font-mono text-gray-500 text-center leading-relaxed" style={{ wordBreak: 'break-all' }}>
                        {formData.currentLat}, {formData.currentLng}
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Drag Handle */}
              <div
                className="flex-shrink-0 cursor-col-resize flex items-center justify-center hover:bg-gray-200 transition mx-1 rounded"
                style={{ width: '10px', minHeight: '200px', touchAction: 'none' }}
                onMouseDown={(e) => {
                  e.preventDefault();
                  const startX = e.clientX;
                  const startWidth = rightColWidth;
                  const isRtl = true;
                  const onMove = (ev) => {
                    const diff = isRtl ? (startX - ev.clientX) : (ev.clientX - startX);
                    const newWidth = Math.min(250, Math.max(100, startWidth + diff));
                    setRightColWidth(newWidth);
                  };
                  const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                  };
                  document.addEventListener('mousemove', onMove);
                  document.addEventListener('mouseup', onUp);
                }}
                onTouchStart={(e) => {
                  const startX = e.touches[0].clientX;
                  const startWidth = rightColWidth;
                  const isRtl = true;
                  const onMove = (ev) => {
                    ev.preventDefault();
                    const diff = isRtl ? (startX - ev.touches[0].clientX) : (ev.touches[0].clientX - startX);
                    const newWidth = Math.min(250, Math.max(100, startWidth + diff));
                    setRightColWidth(newWidth);
                  };
                  const onUp = () => {
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onUp);
                  };
                  document.addEventListener('touchmove', onMove, { passive: false });
                  document.addEventListener('touchend', onUp);
                }}
              >
                <div className="w-1 h-8 bg-gray-300 rounded-full"></div>
              </div>

              {/* Left Column: Interests */}
              <div className="flex-1 min-w-0 flex flex-col">
                <label className="font-medium text-xs mb-1.5 block">{t("form.whatInterests")}</label>
                <div className="grid grid-cols-3 gap-2 border border-gray-200 rounded-lg p-2">
                {allInterestOptions.filter(option => {
                  if (!option || !option.id) return false;
                  // Must be valid (have search config)
                  if (!isInterestValid(option.id)) return false;
                  // Custom interests also check status (respect disabled)
                  const isCustom = cityCustomInterests.some(ci => ci.id === option.id);
                  if (isCustom) return interestStatus[option.id] !== false;
                  // Built-in/uncovered shown only if active
                  return interestStatus[option.id] !== false;
                }).map(option => {
                  const tooltip = interestTooltips[option.id] || tLabel(option);
                  const customInterest = cityCustomInterests.find(ci => ci.id === option.id);
                  const isCustom = !!customInterest;
                  
                  return (
                    <button
                      key={option.id}
                      onClick={() => toggleInterest(option.id)}
                      title={tooltip}
                      style={{
                        border: formData.interests.includes(option.id) ? '2px solid #3b82f6' : '1.5px solid #e5e7eb',
                        backgroundColor: formData.interests.includes(option.id) ? '#eff6ff' : '#ffffff',
                        boxShadow: formData.interests.includes(option.id) ? '0 2px 4px rgba(59, 130, 246, 0.15)' : 'none',
                        position: 'relative',
                        overflow: 'hidden'
                      }}
                      className="p-1.5 rounded-lg text-xs"
                    >
                      <div className="text-lg mb-1">{option.icon?.startsWith?.('data:') ? <img src={option.icon} alt="" className="w-6 h-6 object-contain mx-auto" /> : option.icon}</div>
                      <div style={{
                        fontWeight: '600',
                        fontSize: '10px',
                        color: formData.interests.includes(option.id) ? '#1e40af' : '#374151',
                        wordBreak: 'break-word',
                        lineHeight: '1.2',
                        maxHeight: '2.4em',
                        overflow: 'hidden'
                      }}>{tLabel(option)}</div>
                    </button>
                  );
                })}
              </div>
              </div>
              {/* End of Left Column */}
              
            </div>
            {/* End of Split Layout */}

            {/* Generate Button - sticky at bottom for mobile */}
            <div style={{
              position: 'sticky',
              bottom: '20px',
              zIndex: 100,
              marginTop: '20px'
            }}>
              <button
                onClick={generateRoute}
                disabled={formData.interests.length === 0 || (formData.searchMode === 'radius' && !formData.currentLat)}
                style={{
                  width: '100%',
                  backgroundColor: '#2563eb',
                  color: 'white',
                  padding: '10px',
                  borderRadius: '12px',
                  fontWeight: 'bold',
                  fontSize: '14px',
                  border: 'none',
                  boxShadow: '0 4px 6px rgba(0, 0, 0, 0.2)',
                  opacity: (formData.interests.length === 0 || (formData.searchMode === 'radius' && !formData.currentLat)) ? 0.5 : 1
                }}
              >
                {isGenerating ? t('general.searching') : `üîç ${t('wizard.findPlaces')} (${formData.maxStops})`}
              </button>
              <button
                onClick={() => showHelpFor('searchLogic')}
                className="bg-white text-blue-600 hover:bg-blue-50 rounded-full w-7 h-7 flex items-center justify-center text-sm font-bold shadow border border-blue-200"
                title={t("help.searchLogic.title")}
              >
                ?
              </button>
            </div>
            
            {formData.interests.length === 0 && (
              <p className="text-center text-gray-500 text-xs">{t("form.selectAtLeastOneInterest")}</p>
            )}
            {formData.searchMode === 'radius' && !formData.currentLat && formData.interests.length > 0 && (
              <p className="text-center text-blue-500 text-xs font-medium">{t("form.useGpsForRadius")}</p>
            )}

            </>)}

            {/* Show stops list ONLY after route is calculated */}
            {route && (
              <div id="route-results" className="bg-blue-50 border-2 border-blue-200 rounded-lg p-3 mt-4" dir={window.BKK.i18n.isRTL() ? "rtl" : "ltr"}>
                <div className="flex items-center gap-2 mb-2">
                  <h3 className="font-bold text-blue-900 text-sm">{`${t("route.places")} - ${route.areaName}`} ({route.stops.length}):</h3>
                  <button
                    onClick={() => showHelpFor('placesListing')}
                    style={{ background: 'none', border: 'none', color: '#3b82f6', fontSize: '11px', cursor: 'pointer', textDecoration: 'underline' }}
                  >{t("general.help")}</button>
                </div>
                {/* Help link instead of inline legend */}
                {showRoutePreview ? (
                  /* FLAT ROUTE PREVIEW - Drag to reorder */
                  <div className="max-h-96 overflow-y-auto" style={{ contain: 'content' }}>
                    <div className="bg-purple-50 rounded-lg p-2 mb-2 text-center">
                      <span className="text-xs text-purple-700 font-bold">{"‚ò∞ " + t('route.reorderStops') + " ‚Äî " + t('route.dragToReorder')}</span>
                    </div>
                    {(() => {
                      const activeStops = route.stops.filter(s => 
                        !disabledStops.includes((s.name || '').toLowerCase().trim())
                      );
                      return activeStops.map((stop, idx) => {
                        const hasValidCoords = stop.lat && stop.lng && stop.lat !== 0 && stop.lng !== 0;
                        const originalIdx = route.stops.indexOf(stop);
                        return (
                          <div key={originalIdx} 
                            draggable="true"
                            onDragStart={(e) => {
                              e.dataTransfer.setData('text/plain', String(idx));
                              e.dataTransfer.effectAllowed = 'move';
                              e.currentTarget.style.opacity = '0.4';
                            }}
                            onDragEnd={(e) => { e.currentTarget.style.opacity = '1'; }}
                            onDragOver={(e) => { e.preventDefault(); e.currentTarget.style.borderColor = '#8b5cf6'; }}
                            onDragLeave={(e) => { e.currentTarget.style.borderColor = '#e5e7eb'; }}
                            onDrop={(e) => {
                              e.preventDefault();
                              e.currentTarget.style.borderColor = '#e5e7eb';
                              const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                              const toIdx = idx;
                              if (fromIdx === toIdx) return;
                              const activeIndices = route.stops.map((s, i) => ({ s, i })).filter(x => !disabledStops.includes((x.s.name || '').toLowerCase().trim()));
                              const newStops = [...route.stops];
                              const fromOrig = activeIndices[fromIdx].i;
                              const [moved] = newStops.splice(fromOrig, 1);
                              const updatedActiveIndices = newStops.map((s, i) => ({ s, i })).filter(x => !disabledStops.includes((x.s.name || '').toLowerCase().trim()));
                              const targetPos = toIdx < updatedActiveIndices.length ? updatedActiveIndices[toIdx].i : newStops.length;
                              newStops.splice(targetPos, 0, moved);
                              setRoute(prev => ({ ...prev, stops: newStops }));
                            }}
                            className="flex items-center gap-2 p-2 mb-1 bg-white rounded-lg border-2 border-gray-200 cursor-grab active:cursor-grabbing transition-colors" 
                            style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                          >
                            {/* Drag handle + Stop number */}
                            <div style={{ 
                              width: '32px', height: '32px', borderRadius: '50%', 
                              background: idx === 0 ? '#22c55e' : idx === activeStops.length - 1 ? '#ef4444' : '#8b5cf6',
                              color: 'white', display: 'flex', alignItems: 'center', justifyContent: 'center',
                              fontSize: '13px', fontWeight: 'bold', flexShrink: 0, cursor: 'grab'
                            }}>
                              {String.fromCharCode(65 + idx)}
                            </div>
                            
                            {/* Stop name as hyperlink to Google Maps */}
                            <div className="flex-1 min-w-0">
                              {hasValidCoords ? (
                                <a href={window.BKK.getGoogleMapsUrl(stop)} target="_blank" rel="noopener noreferrer"
                                  className="text-sm font-bold text-blue-700 hover:text-blue-900 hover:underline truncate block"
                                  onClick={(e) => e.stopPropagation()}
                                >{stop.name}</a>
                              ) : (
                                <div className="text-sm font-bold text-gray-800 truncate">{stop.name}</div>
                              )}
                              {stop.description && <div className="text-[10px] text-gray-500 truncate">{stop.description}</div>}
                            </div>
                            
                            {/* Drag indicator */}
                            <span style={{ color: '#9ca3af', fontSize: '16px', flexShrink: 0, cursor: 'grab' }}>‚ò∞</span>
                          </div>
                        );
                      });
                    })()}
                  </div>
                ) : (
                <div className="max-h-96 overflow-y-auto" style={{ contain: 'content' }}>
                  {(() => {
                    // Group stops by interest
                    const groupedStops = {};
                    let stopCounter = 0;
                    
                    route.stops.forEach((stop, i) => {
                      const interests = stop.interests || [];
                      interests.forEach(interest => {
                        if (!groupedStops[interest]) {
                          groupedStops[interest] = [];
                        }
                        groupedStops[interest].push({ ...stop, originalIndex: i, displayNumber: stopCounter + 1 });
                      });
                      stopCounter++;
                    });
                    
                    return Object.entries(groupedStops).map(([interest, stops]) => {
                      const isManualGroup = interest === '_manual';
                      const interestObj = isManualGroup ? { id: '_manual', label: t('general.addedManually'), icon: 'üìç' } : interestMap[interest];
                      if (!interestObj) return null;
                      
                      // For manual group, filter out stops that now have real interests
                      const filteredStops = isManualGroup 
                        ? stops.filter(s => !s.interests || s.interests.length === 0 || (s.interests.length === 1 && s.interests[0] === '_manual'))
                        : stops;
                      if (filteredStops.length === 0) return null;
                      
                      return (
                        <div key={interest} className="bg-white rounded-lg p-2 border border-gray-200">
                          {/* Interest header with fetch-more button */}
                          <div className="flex items-center justify-between mb-1.5">
                            <div className="font-bold text-xs text-gray-700 flex items-center gap-1">
                              <span style={{ fontSize: '14px' }}>{interestObj.icon?.startsWith?.('data:') ? <img src={interestObj.icon} alt="" style={{ width: '16px', height: '16px', objectFit: 'contain', display: 'inline' }} /> : interestObj.icon}</span>
                              <span>{tLabel(interestObj)} ({filteredStops.length})</span>
                            </div>
                            {!isManualGroup && (
                            <button
                              onClick={async () => {
                                // Fetch more for this specific interest
                                await fetchMoreForInterest(interest);
                              }}
                              className="text-[10px] px-2 py-0.5 rounded bg-blue-500 text-white hover:bg-blue-600"
                              title={`${t("route.moreFromCategory")} ${tLabel(interestObj)}`}
                            >
                              {t("general.more")}
                            </button>
                            )}
                          </div>
                          
                          {/* Stops in this interest */}
                          <div className="space-y-1.5">
                            {filteredStops.map((stop) => {
                              const hasValidCoords = stop.lat && stop.lng && stop.lat !== 0 && stop.lng !== 0;
                              const stopId = (stop.name || '').toLowerCase().trim();
                              const isDisabled = disabledStops.includes(stopId);
                              const isCustom = stop.custom;
                              const isAddedLater = stop.addedLater;
                              const isStartPoint = hasValidCoords && startPointCoords?.lat === stop.lat && startPointCoords?.lng === stop.lng;
                              
                              return (
                                <div key={stop.originalIndex} className="p-1.5 rounded border relative" style={{ 
                                  borderColor: isStartPoint ? '#e5e7eb' : !hasValidCoords ? '#ef4444' : isAddedLater ? '#60a5fa' : '#e5e7eb',
                                  borderWidth: isAddedLater ? '2px' : '1px',
                                  borderStyle: isAddedLater ? 'dashed' : 'solid',
                                  backgroundColor: !hasValidCoords ? '#fef2f2' : isAddedLater ? '#eff6ff' : '#fafafa'
                                }}>
                                  {/* Action buttons - positioned based on language direction */}
                                  <div style={{ position: 'absolute', top: '2px', display: 'flex', gap: '2px', ...(window.BKK.i18n.isRTL() ? { left: '2px' } : { right: '2px' }) }}>
                                    {/* Set as start point */}
                                    {hasValidCoords && !isDisabled && (
                                      <button
                                        onClick={() => {
                                          const displayText = stop.name || stop.description || `${stop.lat.toFixed(5)}, ${stop.lng.toFixed(5)}`;
                                          setStartPointCoords({ lat: stop.lat, lng: stop.lng, address: stop.name });
                                          setFormData(prev => ({...prev, startPoint: displayText}));
                                          if (route?.optimized) {
                                            setRoute(prev => prev ? {...prev, optimized: false} : prev);
                                          }
                                          showToast(`üìå ${stop.name} ‚Äî ${t("route.startPoint")}`, 'success');
                                        }}
                                        className={`text-[9px] px-1 py-0.5 rounded ${
                                          startPointCoords?.lat === stop.lat && startPointCoords?.lng === stop.lng
                                            ? 'bg-green-600 text-white ring-1 ring-green-400'
                                            : 'bg-green-100 text-green-700 hover:bg-green-200'
                                        }`}
                                        title={t("form.setStartPoint")}
                                      >
                                        üìå
                                      </button>
                                    )}
                                    {/* Pause/Resume button */}
                                    {!(hasValidCoords && startPointCoords?.lat === stop.lat && startPointCoords?.lng === stop.lng) && (
                                    <button
                                      onClick={() => toggleStopActive(stop.originalIndex)}
                                      className={`text-[9px] px-1 py-0.5 rounded ${isDisabled ? 'bg-green-500 text-white' : 'bg-gray-400 text-white'}`}
                                      title={isDisabled ? t('route.returnPlace') : t('route.skipPlace')}
                                    >
                                      {isDisabled ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}
                                    </button>
                                    )}
                                    {/* Remove button for manually added stops */}
                                    {stop.manuallyAdded && (
                                      <button
                                        onClick={() => {
                                          setManualStops(prev => prev.filter(ms => ms.name !== stop.name));
                                          setRoute(prev => prev ? {
                                            ...prev,
                                            stops: prev.stops.filter((_, idx) => idx !== stop.originalIndex)
                                          } : prev);
                                          showToast(`üóëÔ∏è ${stop.name} ${t("toast.removedFromRoute")}`, 'info');
                                        }}
                                        className="text-[9px] px-1 py-0.5 rounded bg-red-500 text-white hover:bg-red-600"
                                        title={t("route.removeFromRoute")}
                                      >
                                        üóëÔ∏è
                                      </button>
                                    )}
                                    
                                    {!isCustom && !wizardMode && (
                                      (() => {
                                        const placeId = stop.id || stop.name;
                                        const isAdding = addingPlaceIds.includes(placeId);
                                        const existingLoc = customLocations.find(loc => 
                                          loc.name.toLowerCase().trim() === stop.name.toLowerCase().trim()
                                        );
                                        
                                        if (existingLoc) {
                                          // Place was added - show edit/view button
                                          return (
                                            <button
                                              onClick={() => handleEditLocation(existingLoc)}
                                              className="text-[9px] px-1 py-0.5 rounded bg-blue-500 text-white hover:bg-blue-600"
                                              title={existingLoc.locked && !isUnlocked ? t("general.viewOnly") : t("places.editAddedToList")}
                                            >
                                              {existingLoc.locked && !isUnlocked ? 'üëÅÔ∏è' : '‚úèÔ∏è'}
                                            </button>
                                          );
                                        }
                                        
                                        return (
                                          <button
                                            onClick={() => addGooglePlaceToCustom(stop)}
                                            disabled={isAdding}
                                            className={`text-[9px] px-1 py-0.5 rounded ${
                                              isAdding 
                                                ? 'bg-gray-300 text-gray-500 cursor-wait' 
                                                : 'bg-purple-500 text-white hover:bg-purple-600'
                                            }`}
                                            title={t("route.addToMyList")}
                                          >
                                            {isAdding ? '...' : '+'}
                                          </button>
                                        );
                                      })()
                                    )}
                                    
                                    {isCustom && !wizardMode && (
                                      <button
                                        onClick={() => {
                                          const customLoc = customLocations.find(loc => loc.name === stop.name);
                                          if (customLoc) {
                                            handleEditLocation(customLoc);
                                          }
                                        }}
                                        className="text-[9px] px-1 py-0.5 rounded bg-blue-500 text-white hover:bg-blue-600"
                                        title={(() => { const cl = customLocations.find(loc => loc.name === stop.name); return cl?.locked && !isUnlocked ? t("general.viewOnly") : t("general.edit"); })()}
                                      >
                                        {(() => { const cl = customLocations.find(loc => loc.name === stop.name); return cl?.locked && !isUnlocked ? 'üëÅÔ∏è' : '‚úèÔ∏è'; })()}
                                      </button>
                                    )}
                                  </div>
                                  
                                  <a
                                    href={window.BKK.getGoogleMapsUrl(stop)}
                                    target={hasValidCoords ? "_blank" : undefined}
                                    rel={hasValidCoords ? "noopener noreferrer" : undefined}
                                    className={`block hover:bg-gray-100 transition ${window.BKK.i18n.isRTL() ? 'pr-2' : 'pl-2'}`}
                                    onClick={(e) => {
                                      if (!hasValidCoords) {
                                        e.preventDefault();
                                        showToast(t('places.editNoCoordsHint'), 'warning');
                                      }
                                    }}
                                  >
                                    <div className="font-bold text-[11px] flex items-center gap-1" style={{
                                      color: isDisabled ? '#9ca3af' : hasValidCoords ? '#2563eb' : '#dc2626',
                                      textDecoration: isDisabled ? 'line-through' : 'none',
                                      flexWrap: 'wrap'
                                    }}>
                                      {route?.optimized && !isDisabled && hasValidCoords && (
                                        <span className="bg-purple-600 text-white rounded-full w-4 h-4 flex items-center justify-center text-[8px] font-bold flex-shrink-0">
                                          {stop.originalIndex + 1}
                                        </span>
                                      )}
                                      {!hasValidCoords && (
                                        <span title={t("places.noCoordinates")} style={{ fontSize: '11px' }}>
                                          ‚ùó
                                        </span>
                                      )}
                                      <span>{stop.name}</span>
                                      {isStartPoint && (
                                        <span className="text-[8px] bg-green-600 text-white px-1 py-0.5 rounded font-bold">{t("general.start")}</span>
                                      )}
                                      {stop.detectedArea && formData.searchMode === 'radius' && (
                                        <span className="text-[8px] bg-blue-100 text-blue-700 px-1 py-0.5 rounded font-bold">
                                          {tLabel(areaMap[stop.detectedArea]) || stop.detectedArea}
                                        </span>
                                      )}
                                      {stop.distFromCenter != null && formData.searchMode === 'radius' && (
                                        <span className="text-[8px] bg-green-100 text-green-700 px-1 py-0.5 rounded font-bold">
                                          {stop.distFromCenter}m
                                        </span>
                                      )}
                                      {stop.outsideArea && (
                                        <span className="text-orange-500" title={t("places.outsideArea")} style={{ fontSize: '10px' }}>
                                          üî∫
                                        </span>
                                      )}
                                      {isCustom && !wizardMode && (
                                        <span title={t("form.myPlace")} style={{ fontSize: '11px' }}>üéñÔ∏è</span>
                                      )}
                                      {isAddedLater && !wizardMode && (
                                        <span className="text-blue-500 font-bold" title={t("general.addedViaMore")} style={{ fontSize: '9px' }}>{`+${t('general.more')}`}</span>
                                      )}
                                      {/* Camera icon for custom locations with image */}
                                      {isCustom && stop.uploadedImage && (
                                        <button
                                          onClick={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setModalImage(stop.uploadedImage);
                                            setShowImageModal(true);
                                          }}
                                          className="hover:scale-110 transition bg-blue-100 hover:bg-blue-200 rounded px-0.5"
                                          title={t("general.clickForImage")}
                                          style={{ fontSize: '11px', cursor: 'pointer' }}
                                        >
                                          üñºÔ∏è
                                        </button>
                                      )}
                                    </div>
                                    <div className="text-[10px]" style={{
                                      color: hasValidCoords ? '#6b7280' : '#991b1b'
                                    }}>
                                      {hasValidCoords ? stop.description : t('places.noCoordinatesWarning')}
                                    </div>
                                    {stop.todayHours && (
                                      <div className="text-[9px]" style={{ color: stop.openNow ? '#059669' : '#dc2626' }}>
                                        üïê {stop.openNow ? t('general.openStatus') : t('general.closedStatus')} ¬∑ {stop.todayHours}
                                      </div>
                                    )}
                                  </a>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      );
                    });
                  })()}
                </div>
                )}
                
                <div className="mt-3 space-y-2">
                  {/* Add manual stop button */}
                  <button
                    onClick={() => setShowManualAddDialog(true)}
                    style={{
                      width: '100%',
                      background: 'linear-gradient(135deg, #14b8a6, #0d9488)',
                      color: 'white',
                      display: 'block',
                      textAlign: 'center',
                      padding: '8px',
                      borderRadius: '12px',
                      fontWeight: 'bold',
                      fontSize: '13px',
                      border: 'none',
                      boxShadow: '0 4px 6px -1px rgba(20, 184, 166, 0.3)',
                      marginBottom: '4px',
                      cursor: 'pointer'
                    }}
                  >
                    {t("route.addManualStop")}
                  </button>
                  
                  <a
                    href={(() => {
                      // Filter active stops with valid coordinates
                      const activeStops = route.stops.filter((s, i) => {
                        const isActive = !disabledStops.includes((s.name || '').toLowerCase().trim());
                        const hasValidCoords = s.lat && s.lng && s.lat !== 0 && s.lng !== 0;
                        return isActive && hasValidCoords;
                      });
                      
                      if (activeStops.length === 0) {
                        return '#';
                      }
                      
                      // Calculate center
                      const avgLat = activeStops.reduce((sum, s) => sum + s.lat, 0) / activeStops.length;
                      const avgLng = activeStops.reduce((sum, s) => sum + s.lng, 0) / activeStops.length;
                      
                      // Create search query with all active place names
                      const query = activeStops.map(s => s.name).join(' OR ');
                      
                      // Return search URL with active places
                      return `https://www.google.com/maps/search/${encodeURIComponent(query)}/@${avgLat},${avgLng},13z`;
                    })()}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={(e) => {
                      const activeStops = route.stops.filter((s, i) => {
                        const isActive = !disabledStops.includes((s.name || '').toLowerCase().trim());
                        const hasValidCoords = s.lat && s.lng && s.lat !== 0 && s.lng !== 0;
                        return isActive && hasValidCoords;
                      });
                      if (activeStops.length === 0) {
                        e.preventDefault();
                        showToast(t('places.noPlacesWithCoords'), 'warning');
                        return;
                      }
                      if (activeStops.length > googleMaxMapPoints) {
                        showToast(t('route.mapPointsWarning').replace('{count}', activeStops.length), 'info', 'sticky');
                      }
                      const url = e.currentTarget.href;
                      if (url.length > 2000) {
                        showToast(`${t('toast.urlTooLong')} (${url.length})`, 'warning');
                      }
                    }}
                    style={{
                      display: 'block',
                      width: '100%',
                      backgroundColor: '#f59e0b',
                      color: 'white',
                      textAlign: 'center',
                      padding: '8px',
                      borderRadius: '12px',
                      fontWeight: 'bold',
                      textDecoration: 'none',
                      fontSize: '13px',
                      boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3)',
                      marginBottom: '4px'
                    }}
                  >
                    {`${t("route.showStopsOnMap")} (${route.stops.filter(s => !disabledStops.includes((s.name || '').toLowerCase().trim()) && s.lat && s.lng).length})`}
                  </a>
                  
                  
                  {/* URL limit note */}
                  
                  {/* Route Type + Button */}
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                    {/* Route Type Radio Buttons - Small and Simple */}
                    <div style={{
                      display: 'flex',
                      gap: '16px',
                      fontSize: '13px',
                      paddingRight: '4px'
                    }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                        <input
                          type="radio"
                          name="routeType"
                          checked={routeType === 'circular'}
                          onChange={() => {
                            setRouteType('circular');
                            if (route?.optimized) setRoute(prev => prev ? {...prev, optimized: false} : prev);
                          }}
                          style={{ cursor: 'pointer' }}
                        />
                        <span>{t("route.circular")}</span>
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                        <input
                          type="radio"
                          name="routeType"
                          checked={routeType === 'linear'}
                          onChange={() => {
                            setRouteType('linear');
                            if (route?.optimized) setRoute(prev => prev ? {...prev, optimized: false} : prev);
                          }}
                          style={{ cursor: 'pointer' }}
                        />
                        <span>{t("general.linear")}</span>
                      </label>
                    </div>
                    
                    {/* Start Point Input with GPS + validate buttons */}
                    <div>
                      <label className="text-xs font-bold text-gray-700 mb-1 block">{`üìç ${t("route.startPoint")}`}</label>
                      <div className="flex gap-1 items-center">
                        <div className="flex-1 relative">
                          <input
                            type="text"
                            value={formData.startPoint}
                            readOnly
                            onClick={() => setShowAddressDialog(true)}
                            placeholder={t("form.selectStartPoint")}
                            className="w-full p-1.5 border border-gray-300 rounded-lg text-xs cursor-pointer hover:border-blue-400"
                            style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr', paddingLeft: '8px', paddingRight: '8px', backgroundColor: startPointCoords ? '#f0fdf4' : '#fff' }}
                          />
                        </div>
                        {(formData.startPoint?.trim() || startPointCoords) && (
                          <button
                            onClick={() => {
                              setFormData({...formData, startPoint: ''});
                              setStartPointCoords(null);
                              if (route?.optimized) setRoute(prev => prev ? {...prev, optimized: false} : prev);
                            }}
                            className="w-6 h-6 flex items-center justify-center rounded-full bg-gray-400 text-white hover:bg-red-500 text-[10px] font-bold flex-shrink-0"
                            title={t("general.clear")}
                          >
                            ‚úï
                          </button>
                        )}
                        <button
                          onClick={() => setShowAddressDialog(true)}
                          className="px-1.5 py-1.5 rounded-lg text-xs font-bold whitespace-nowrap flex-shrink-0 bg-green-500 text-white hover:bg-green-600"
                          title={t("form.searchAddress")}
                        >
                          üîç
                        </button>
                        <button
                          onClick={getMyLocation}
                          disabled={isLocating}
                          className={`px-1.5 py-1.5 rounded-lg text-[10px] font-bold whitespace-nowrap flex-shrink-0 ${isLocating ? 'bg-gray-300 text-gray-500' : 'bg-blue-500 text-white hover:bg-blue-600'}`}
                          title={t("form.findCurrentLocation")}
                        >
                          {isLocating ? '‚è≥' : 'üìç'}
                        </button>
                      </div>
                      {!startPointCoords && !formData.startPoint?.trim() && (
                        <p style={{ fontSize: '10px', color: '#6b7280', marginTop: '3px' }}>
                          üí° Click üîç to search address, üìç for current location, or üìå from your places
                        </p>
                      )}
                    </div>
                    
                    {/* Compute Route Button */}
                    <button
                      onClick={computeRoute}
                      disabled={!startPointCoords}
                      style={{
                        width: '100%',
                        backgroundColor: startPointCoords ? '#7c3aed' : '#d1d5db',
                        color: startPointCoords ? 'white' : '#9ca3af',
                        padding: '8px',
                        borderRadius: '12px',
                        fontWeight: 'bold',
                        fontSize: '13px',
                        border: 'none',
                        boxShadow: startPointCoords ? '0 4px 6px rgba(124, 58, 237, 0.3)' : 'none',
                        cursor: startPointCoords ? 'pointer' : 'not-allowed'
                      }}
                    >
                      {route?.optimized ? t('route.recalcRoute') : t('route.calcRoute')}
                    </button>
                    {!startPointCoords && (
                      <p style={{ fontSize: '10px', color: '#ef4444', textAlign: 'center', marginBottom: '2px' }}>
                        {`‚¨ÜÔ∏è ${t("form.chooseStartBeforeCalc")}`}
                      </p>
                    )}
                    {route?.optimized && (
                      <p style={{ fontSize: '10px', color: '#16a34a', textAlign: 'center', marginBottom: '2px', fontWeight: 'bold' }}>
                        {`‚úÖ ${t("route.routeCalculated")} ‚¨áÔ∏è`}
                      </p>
                    )}
                    
                    {/* Buttons row: Open in Google + Save */}
                    <div style={{ display: 'flex', gap: '6px', marginBottom: '4px', marginTop: '4px', flexWrap: 'wrap' }}>
                      {/* Open in Google Maps Button(s) */}
                      {(() => {
                        // Pre-compute URLs for split detection
                        const activeStops = route?.optimized ? route.stops.filter((stop) => {
                          const isActive = !disabledStops.includes((stop.name || '').toLowerCase().trim());
                          const hasValidCoords = stop.lat && stop.lng && stop.lat !== 0 && stop.lng !== 0;
                          return isActive && hasValidCoords;
                        }) : [];
                        const hasStartPoint = startPointCoords && startPointCoords.lat && startPointCoords.lng;
                        const origin = hasStartPoint
                          ? `${startPointCoords.lat},${startPointCoords.lng}`
                          : activeStops.length > 0 ? `${activeStops[0].lat},${activeStops[0].lng}` : '';
                        const stopsForUrls = hasStartPoint ? activeStops : activeStops.slice(1);
                        const isCircular = routeType === 'circular';
                        const urls = route?.optimized && activeStops.length > 0
                          ? window.BKK.buildGoogleMapsUrls(stopsForUrls, origin, isCircular, googleMaxWaypoints)
                          : [];
                        const isSplit = urls.length > 1;

                        return urls.length <= 1 ? (
                          <button
                            id="open-google-maps-btn"
                            disabled={!route?.optimized}
                            onClick={() => {
                              if (!route?.optimized) { showToast(t('route.calcRoutePrevious'), 'warning'); return; }
                              if (activeStops.length === 0) { showToast(t('places.noPlacesWithCoords'), 'warning'); return; }
                              const mapUrl = urls.length === 1 ? urls[0].url : (activeStops.length === 1 && !hasStartPoint ? window.BKK.getGoogleMapsUrl(activeStops[0]) : '#');
                              if (mapUrl.length > 2000) showToast(`${t('toast.urlTooLong')} (${mapUrl.length})`, 'warning');
                              else if (isCircular) showToast(t('route.circularDesc'), 'info');
                              window.open(mapUrl, '_blank');
                            }}
                            style={{
                              flex: 1, backgroundColor: route?.optimized ? '#22c55e' : '#d1d5db',
                              color: route?.optimized ? 'white' : '#9ca3af', textAlign: 'center',
                              padding: '8px', borderRadius: '12px', fontWeight: 'bold', fontSize: '13px',
                              border: 'none', boxShadow: route?.optimized ? '0 4px 6px -1px rgba(0, 0, 0, 0.3)' : 'none',
                              cursor: route?.optimized ? 'pointer' : 'not-allowed'
                            }}
                          >
                            {`üó∫Ô∏è ${t('route.openRouteInGoogle')}`}
                          </button>
                        ) : (
                          urls.map((urlInfo, idx) => (
                            <button
                              key={idx}
                              id={idx === 0 ? "open-google-maps-btn" : undefined}
                              onClick={() => {
                                if (urlInfo.url.length > 2000) showToast(`${t('toast.urlTooLong')} (${urlInfo.url.length})`, 'warning');
                                window.open(urlInfo.url, '_blank');
                              }}
                              style={{
                                flex: 1, minWidth: '120px',
                                backgroundColor: idx === 0 ? '#22c55e' : '#16a34a',
                                color: 'white', textAlign: 'center',
                                padding: '8px', borderRadius: '12px', fontWeight: 'bold', fontSize: '12px',
                                border: 'none', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3)',
                                cursor: 'pointer'
                              }}
                            >
                              {`üó∫Ô∏è ${t('route.openRoutePartN').replace('{n}', urlInfo.part).replace('{total}', urlInfo.total)}`}
                            </button>
                          ))
                        );
                      })()}
                      
                      {/* Route Preview / Reorder button */}
                      <button
                        onClick={() => setShowRoutePreview(!showRoutePreview)}
                        disabled={!route?.optimized}
                        style={{
                          backgroundColor: showRoutePreview ? '#7c3aed' : route?.optimized ? '#8b5cf6' : '#d1d5db',
                          color: route?.optimized ? 'white' : '#9ca3af',
                          padding: '8px 12px',
                          borderRadius: '12px',
                          fontWeight: 'bold',
                          fontSize: '13px',
                          border: 'none',
                          cursor: route?.optimized ? 'pointer' : 'not-allowed',
                          whiteSpace: 'nowrap',
                          flexShrink: 0
                        }}
                      >
                        {showRoutePreview ? `‚úì ${t('route.backToList')}` : `üìã ${t('route.reorderStops')}`}
                      </button>
                      
                      {/* Save Route Button - styled - hidden in wizard */}
                      {!wizardMode && (route.name ? (
                        <button
                          disabled
                          style={{
                            backgroundColor: '#dcfce7',
                            border: '2px solid #16a34a',
                            padding: '8px 10px',
                            borderRadius: '12px',
                            fontSize: '16px',
                            cursor: 'default',
                            flexShrink: 0
                          }}
                          title={`${t("route.savedAs")} ${route.name}`}
                        >
                          ‚úÖ
                        </button>
                      ) : (
                        <button
                          onClick={() => quickSaveRoute()}
                          style={{
                            background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
                            border: 'none',
                            padding: '8px 10px',
                            borderRadius: '12px',
                            fontSize: '16px',
                            color: 'white',
                            cursor: 'pointer',
                            boxShadow: '0 4px 6px rgba(124, 58, 237, 0.3)',
                            flexShrink: 0
                          }}
                          title={t("route.saveRoute")}
                        >
                          üíæ
                        </button>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {currentView === 'route' && route && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-4">
            {!wizardMode && (
            <button
              onClick={() => setCurrentView('form')}
              style={getButtonStyle(false)}
              className="mb-4"
            >
              ‚Üê Back to form
            </button>
            )}

            {/* Save Route Button - hidden in wizard */}
            {!route.name && !wizardMode && (
              <button
                onClick={() => quickSaveRoute()}
                className="w-full bg-purple-500 text-white py-3 rounded-lg font-bold hover:bg-purple-600 mb-4"
              >
                {`üíæ ${t("route.saveRoute")}`}
              </button>
            )}

            {route.name && !wizardMode && (
              <div className="bg-green-50 border-2 border-green-500 p-3 rounded-lg mb-4">
                <p className="text-green-800 font-medium">üìå {route.name}</p>
                {route.notes && (
                  <p className="text-xs text-green-700 mt-1">üìù {route.notes}</p>
                )}
                <p className="text-xs text-green-600">Saved on {new Date(route.savedAt).toLocaleDateString()}</p>
              </div>
            )}

            <div className="flex items-center gap-2 mb-2">
              <h2 className="text-2xl font-bold">{route.areaName} - {route.interestsText || t('general.general')}</h2>
              <button
                onClick={() => showHelpFor('route')}
                className="text-gray-400 hover:text-blue-500 text-sm"
                title={t("general.help")}
              >
                {t("general.help")}
              </button>
            </div>
            <p className="text-sm text-gray-600 mb-2">
              {`${t("route.startPoint")}: ${route.startPoint}`}
            </p>
            
            {/* Stats - show breakdown of place sources */}
            {!wizardMode && route.stats && (route.stats.custom > 0 || route.stats.fetched > 0) && (
              <div className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200 rounded-lg p-3 mb-4">
                <div className="text-xs font-bold text-gray-700 mb-2">{`üìä Sources:`}</div>
                <div className="flex gap-2 flex-wrap">
                  {route.stats.custom > 0 && (
                    <span className="bg-purple-500 text-white text-xs px-2 py-1 rounded-full font-bold">
                      {`‚≠ê ${route.stats.custom} custom`}
                    </span>
                  )}
                  {route.stats.fetched > 0 && (
                    <span className={`text-white text-xs px-2 py-1 rounded-full font-bold ${
                      route.stats.source === 'static' ? 'bg-purple-600' : 'bg-green-600'
                    }`}>
                      {route.stats.source === 'static' ? 'üìö' : 'üåê'} {route.stats.fetched} {route.stats.source === 'static' ? t('general.static') : t('general.fromGoogleApi')}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Errors display if any */}
            {route.errors && route.errors.length > 0 && (
              <div className="bg-red-50 border-2 border-red-400 rounded-lg p-3 mb-4">
                <div className="flex items-start gap-2">
                  <span className="text-xl">‚ùå</span>
                  <div className="flex-1">
                    <p className="text-sm font-bold text-red-800 mb-1">{t("toast.errorsGettingPlaces")}</p>
                    <div className="text-xs text-red-700 space-y-1">
                      {route.errors.map((err, i) => (
                        <div key={i}>‚Ä¢ {err.interest}: {err.error}</div>
                      ))}
                    </div>
                    <p className="text-xs text-red-600 mt-2">
                      Full details in Console (F12) - copy and send for fix
                    </p>
                  </div>
                </div>
              </div>
            )}

            {/* Warning if didn't reach requested max stops */}
            {route.incomplete && (
              <div className="bg-yellow-50 border-2 border-yellow-400 rounded-lg p-3 mb-4">
                <div className="flex items-start gap-2">
                  <span className="text-xl">‚ö†Ô∏è</span>
                  <div className="flex-1">
                    <p className="text-sm font-bold text-yellow-800 mb-1">
                      {`Found ${route.incomplete.found} of ${route.incomplete.requested} requested places`}
                    </p>
                    <p className="text-xs text-yellow-700">
                      {formData.interests.length === 1 
                        ? t('places.notEnoughInArea')
                        : t('places.notEnoughPartial')}
                    </p>
                  </div>
                </div>
              </div>
            )}

            <div className="space-y-3 mb-6">
              <div className="flex justify-between items-center mb-3">
                <h3 className="font-bold">{`Stops (${route.stops.length}):`}</h3>
                {!wizardMode && (
                <button
                  onClick={() => {
                    setNewLocation(prev => ({...prev, area: formData.area}));
                    setShowAddLocationDialog(true);
                  }}
                  className="bg-teal-500 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-teal-600"
                >
                  {t("places.addPlace")}
                </button>
                )}
              </div>
              {route.stops.map((stop, i) => {
                const stopId = (stop.name || '').toLowerCase().trim();
                const isDisabled = disabledStops.includes(stopId);
                const isCustom = stop.custom;
                const hasValidCoords = stop.lat && stop.lng && stop.lat !== 0 && stop.lng !== 0;
                
                // Determine source badge
                let sourceBadge = null;
                if (stop.custom) {
                  sourceBadge = { text: t('general.mine'), color: 'bg-purple-500', title: t('general.customPlace') };
                } else {
                  // Everything else is from Google Places
                  sourceBadge = { text: 'üîç Google', color: 'bg-blue-500', title: t('places.googlePlaces') };
                }
                
                return (
                  <div key={i} className={`border-r-4 pr-3 py-2 ${isDisabled ? 'border-gray-300 opacity-50' : hasValidCoords ? 'border-slate-400' : 'border-red-500'}`}
                    style={{ backgroundColor: hasValidCoords ? 'transparent' : '#fef2f2' }}
                  >
                    <div className="flex justify-between items-start gap-2">
                      <div className="flex gap-2 flex-1">
                        <div className={`rounded-full w-6 h-6 flex items-center justify-center font-bold text-sm flex-shrink-0 ${isDisabled ? 'bg-gray-400 text-white' : hasValidCoords ? 'bg-slate-600 text-white' : 'bg-red-500 text-white'}`}>
                          {isDisabled ? '‚úï' : hasValidCoords ? i + 1 : '‚ùó'}
                        </div>
                        <div className="flex-1">
                          <div className="flex items-center gap-2 flex-wrap">
                            {!hasValidCoords && (
                              <span 
                                title={t("places.noCoordinates")}
                                style={{ fontSize: '14px', color: '#dc2626' }}
                              >
                                ‚ùó
                              </span>
                            )}
                            <a
                              href={window.BKK.getGoogleMapsUrl(stop)}
                              target={hasValidCoords ? "_blank" : undefined}
                              rel={hasValidCoords ? "noopener noreferrer" : undefined}
                              className={`font-bold text-sm ${isDisabled ? 'line-through text-gray-500' : hasValidCoords ? 'text-blue-600 hover:text-blue-800' : 'text-red-600'}`}
                              onClick={(e) => {
                                if (!hasValidCoords) {
                                  e.preventDefault();
                                  showToast(t('places.editNoCoordsHint2'), 'warning');
                                }
                              }}
                            >
                              {stop.name}
                            </a>
                            {stop.detectedArea && route.preferences?.searchMode === 'radius' && (
                              <span className="text-[9px] bg-blue-100 text-blue-700 px-1.5 py-0.5 rounded font-bold mr-1">
                                {tLabel(areaMap[stop.detectedArea]) || stop.detectedArea}
                              </span>
                            )}
                            {stop.distFromCenter != null && route.preferences?.searchMode === 'radius' && (
                              <span className="text-[9px] bg-green-100 text-green-700 px-1.5 py-0.5 rounded font-bold mr-1">
                                {stop.distFromCenter}m
                              </span>
                            )}
                            {stop.outsideArea && (
                              <span 
                                className="text-orange-500" 
                                title={t("places.outsideArea")}
                                style={{ fontSize: '14px' }}
                              >
                                üî∫
                              </span>
                            )}
                            {stop.interests && stop.interests.length > 0 && (
                              <>
                                {stop.interests.map((interest, idx) => {
                                  const interestObj = interestMap[interest];
                                  return interestObj?.icon ? (
                                    <span 
                                      key={idx}
                                      title={tLabel(interestObj)}
                                      style={{ fontSize: '16px' }}
                                    >
                                      {interestObj.icon?.startsWith?.('data:') ? <img src={interestObj.icon} alt="" style={{ width: '16px', height: '16px', objectFit: 'contain', display: 'inline' }} /> : interestObj.icon}
                                    </span>
                                  ) : null;
                                })}
                              </>
                            )}
                            {stop.custom ? (
                              <div className="relative group">
                                <button
                                  onClick={() => {
                                    const customLoc = customLocations.find(loc => loc.name === stop.name);
                                    if (customLoc) {
                                      handleEditLocation(customLoc);
                                    }
                                  }}
                                  className={`${sourceBadge.color} text-white text-[10px] px-2 py-0.5 rounded-full font-bold cursor-pointer hover:opacity-80 transition`}
                                  title={t("general.clickForDetails")}
                                >
                                  {sourceBadge.text}
                                </button>
                                
                                {/* Hover Tooltip */}
                                <div className="absolute bottom-full left-0 mb-2 hidden group-hover:block z-50 w-64">
                                  <div className="bg-gray-900 text-white p-3 rounded-lg shadow-2xl text-xs">
                                    {stop.uploadedImage && (
                                      <img 
                                        src={stop.uploadedImage} 
                                        alt={stop.name}
                                        className="w-full h-24 object-cover rounded mb-2"
                                      />
                                    )}
                                    <div className="font-bold mb-1">{stop.name}</div>
                                    {stop.description && (
                                      <div className="text-gray-300 mb-1">{stop.description}</div>
                                    )}
                                    {stop.todayHours && (
                                      <div className="mb-1" style={{ color: stop.openNow ? '#34d399' : '#f87171' }}>
                                        üïê {stop.openNow ? t('general.openStatus') : t('general.closedStatus')} ¬∑ {stop.todayHours}
                                      </div>
                                    )}
                                    {stop.notes && (
                                      <div className="text-gray-400 italic">üí≠ {stop.notes}</div>
                                    )}
                                    <div className="text-gray-400 mt-2 text-[9px]">{`üëÜ ${t("general.clickForDetails")}`}</div>
                                  </div>
                                </div>
                              </div>
                            ) : (
                              <span 
                                className={`${sourceBadge.color} text-white text-[10px] px-2 py-0.5 rounded-full font-bold`}
                                title={sourceBadge.title}
                              >
                                {sourceBadge.text}
                              </span>
                            )}
                          </div>
                          <p className="text-xs" style={{
                            color: hasValidCoords ? '#4b5563' : '#991b1b'
                          }}>
                            {hasValidCoords ? stop.description : t('places.noCoordinatesWarnLong')}
                          </p>
                          {stop.todayHours && (
                            <p className="text-[10px]" style={{ color: stop.openNow ? '#059669' : '#dc2626' }}>
                              üïê {stop.openNow ? t('general.openStatus') : t('general.closedStatus')} ¬∑ {stop.todayHours}
                            </p>
                          )}
                        </div>
                      </div>
                      <div className="flex gap-1 flex-shrink-0">
                        {/* Temporary skip button */}
                        <button
                          onClick={() => toggleStopActive(i)}
                          className={`text-xs px-2 py-1 rounded ${isDisabled ? 'bg-yellow-500 text-white' : 'bg-gray-400 text-white'}`}
                          title={isDisabled ? t('route.returnToRoute') : t('route.skipTemporarily')}
                        >
                          {isDisabled ? '‚è∏Ô∏è' : '‚úï'}
                        </button>
                        
                        {(() => {
                          // Check if this place is in blacklist
                          const blacklisted = customLocations.find(loc => 
                            loc.name.toLowerCase() === stop.name.toLowerCase() && 
                            loc.status === 'blacklist'
                          );
                          
                          if (blacklisted) {
                            // Show GREEN undo button - removes from blacklist
                            return (
                              <button
                                onClick={() => {
                                  deleteCustomLocation(blacklisted.id);
                                  showToast(`"${stop.name}" restored to regular list`, 'success');
                                }}
                                className="text-xs px-2 py-1 rounded bg-green-500 text-white hover:bg-green-600"
                                title={t("route.cancelPermanentSkip")}
                              >
                                ‚úÖ
                              </button>
                            );
                          }
                          
                          // Show permanent skip button (for non-custom places) - hidden in wizard
                          if (!isCustom && !wizardMode) {
                            return (
                              <button
                                onClick={() => skipPlacePermanently(stop)}
                                className="text-xs px-2 py-1 rounded bg-red-500 text-white hover:bg-red-600"
                                title={t("general.skipPermanently")}
                              >
                                üö´
                              </button>
                            );
                          }
                          
                          return null;
                        })()}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>

            <div className="space-y-3 mb-4">
              <a
                href={(() => {
                  // Filter active stops with valid coordinates
                  const activeStops = route.stops.filter((s, i) => {
                    const isActive = !disabledStops.includes((s.name || '').toLowerCase().trim());
                    const hasValidCoords = s.lat && s.lng && s.lat !== 0 && s.lng !== 0;
                    return isActive && hasValidCoords;
                  });
                  
                  if (activeStops.length === 0) {
                    return '#';
                  }
                  
                  // Calculate center
                  const avgLat = activeStops.reduce((sum, s) => sum + s.lat, 0) / activeStops.length;
                  const avgLng = activeStops.reduce((sum, s) => sum + s.lng, 0) / activeStops.length;
                  
                  // Create search query with all active place names
                  const query = activeStops.map(s => s.name).join(' OR ');
                  
                  // Return search URL with active places
                  return `https://www.google.com/maps/search/${encodeURIComponent(query)}/@${avgLat},${avgLng},13z`;
                })()}
                target="_blank"
                rel="noopener noreferrer"
                onClick={(e) => {
                  const activeStops = route.stops.filter((s, i) => {
                    const isActive = !disabledStops.includes((s.name || '').toLowerCase().trim());
                    const hasValidCoords = s.lat && s.lng && s.lat !== 0 && s.lng !== 0;
                    return isActive && hasValidCoords;
                  });
                  if (activeStops.length === 0) {
                    e.preventDefault();
                    showToast(t('places.noPlacesWithCoords'), 'warning');
                    return;
                  }
                  const url = e.currentTarget.href;
                  if (url.length > 2000) {
                    showToast(`${t('toast.urlTooLong')} (${url.length})`, 'warning');
                  }
                }}
                style={{
                  display: 'block',
                  width: '100%',
                  backgroundColor: '#f59e0b',
                  color: 'white',
                  textAlign: 'center',
                  padding: '10px',
                  borderRadius: '12px',
                  fontWeight: 'bold',
                  textDecoration: 'none',
                  fontSize: '14px',
                  boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3)',
                  marginBottom: '4px'
                }}
              >
                {`${t("wizard.showMap")}`}
              </a>
              
              {/* URL limit note */}

              {/* Route Type + Button */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {/* Route Type Radio Buttons - Small and Simple */}
                <div style={{
                  display: 'flex',
                  gap: '16px',
                  fontSize: '13px',
                  paddingRight: '4px'
                }}>
                  <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                    <input
                      type="radio"
                      name="routeTypeExpanded"
                      checked={routeType === 'circular'}
                      onChange={() => setRouteType('circular')}
                      style={{ cursor: 'pointer' }}
                    />
                    <span>{t("route.circular")}</span>
                  </label>
                  <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                    <input
                      type="radio"
                      name="routeTypeExpanded"
                      checked={routeType === 'linear'}
                      onChange={() => setRouteType('linear')}
                      style={{ cursor: 'pointer' }}
                    />
                    <span>{t("general.linear")}</span>
                  </label>
                </div>
                
                {/* Calculate Route Button - with split support */}
                {(() => {
                  const activeStops = route.stops.filter((stop) => {
                    const isActive = !disabledStops.includes((stop.name || '').toLowerCase().trim());
                    const hasValidCoords = stop.lat && stop.lng && stop.lat !== 0 && stop.lng !== 0;
                    return isActive && hasValidCoords;
                  });
                  const hasStartPoint = startPointCoords && startPointCoords.lat && startPointCoords.lng;
                  const origin = hasStartPoint
                    ? `${startPointCoords.lat},${startPointCoords.lng}`
                    : activeStops.length > 0 ? `${activeStops[0].lat},${activeStops[0].lng}` : '';
                  const stopsForUrls = hasStartPoint ? activeStops : activeStops.slice(1);
                  const isCircular = routeType === 'circular';
                  const urls = activeStops.length > 0
                    ? window.BKK.buildGoogleMapsUrls(stopsForUrls, origin, isCircular, googleMaxWaypoints)
                    : [];
                  
                  if (urls.length <= 1) {
                    const mapUrl = urls.length === 1 ? urls[0].url : (activeStops.length === 1 && !hasStartPoint ? window.BKK.getGoogleMapsUrl(activeStops[0]) : '#');
                    return (
                      <a href={mapUrl} target="_blank" rel="noopener noreferrer"
                        onClick={(e) => { if (mapUrl.length > 2000) showToast(`${t('toast.urlTooLong')} (${mapUrl.length})`, 'warning'); }}
                        style={{ width: '100%', backgroundColor: '#22c55e', color: 'white', textAlign: 'center',
                          padding: '10px', borderRadius: '12px', fontWeight: 'bold', textDecoration: 'none',
                          fontSize: '14px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3)', display: 'block', marginBottom: '4px' }}
                      >{`üó∫Ô∏è ${t('route.openRouteInGoogle')}`}</a>
                    );
                  } else {
                    return (
                      <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', marginBottom: '4px' }}>
                        {urls.map((urlInfo, idx) => (
                          <a key={idx} href={urlInfo.url} target="_blank" rel="noopener noreferrer"
                            onClick={(e) => { if (urlInfo.url.length > 2000) showToast(`${t('toast.urlTooLong')} (${urlInfo.url.length})`, 'warning'); }}
                            style={{ flex: 1, minWidth: '120px', backgroundColor: idx === 0 ? '#22c55e' : '#16a34a',
                              color: 'white', textAlign: 'center', padding: '10px', borderRadius: '12px',
                              fontWeight: 'bold', textDecoration: 'none', fontSize: '12px',
                              boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3)', display: 'block' }}
                          >{`üó∫Ô∏è ${t('route.openRoutePartN').replace('{n}', urlInfo.part).replace('{total}', urlInfo.total)}`}</a>
                        ))}
                      </div>
                    );
                  }
                })()}
                
              </div>
            </div>
          </div>
        )}

        {/* Saved Routes View */}
        {/* Search View */}
        {currentView === 'search' && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-4">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-2xl font-bold">{`üîç ${t("places.searchResults")}`}</h2>
              <button
                onClick={() => setCurrentView('myPlaces')}
                className="bg-gray-200 text-gray-700 px-3 py-1.5 rounded-lg text-sm font-bold hover:bg-gray-300 flex items-center gap-1"
              >
                ‚Üê Back
              </button>
            </div>
            
            <div className="mb-4">
              <input
                type="text"
                placeholder={t("places.searchByNameHint")}
                value={searchQuery}
                className="w-full p-3 border-3 border-gray-300 rounded-xl text-base focus:border-teal-500 focus:ring-2 focus:ring-teal-200"
                style={{ textAlign: window.BKK.i18n.isRTL() ? 'right' : 'left', direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                onChange={(e) => {
                  const query = e.target.value;
                  setSearchQuery(query);
                  
                  if (!query.trim()) {
                    setSearchResults([]);
                    return;
                  }
                  
                  const queryLower = query.toLowerCase();
                  const results = customLocations.filter(loc => 
                    loc.name.toLowerCase().includes(queryLower) ||
                    (loc.description && loc.description.toLowerCase().includes(queryLower)) ||
                    (loc.notes && loc.notes.toLowerCase().includes(queryLower))
                  );
                  setSearchResults(results);
                }}
              />
            </div>
            
            {/* Search Results */}
            {searchQuery && searchResults.length > 0 ? (
              <div className="space-y-3">
                <p className="text-sm text-gray-600 font-bold">{`${searchResults.length} results found:`}</p>
                {searchResults.map(loc => (
                  <div
                    key={loc.id}
                    className="bg-gradient-to-r from-green-50 to-teal-50 border-3 border-green-400 rounded-xl p-4"
                  >
                    <div className="flex justify-between items-start mb-2">
                      <div className="flex-1">
                        <h3 className="text-lg font-bold text-green-900 flex items-center gap-2">
                          <span>{loc.name}</span>
                          {loc.outsideArea && (
                            <span 
                              className="text-orange-500" 
                              title={t("places.outsideArea")}
                              style={{ fontSize: '16px' }}
                            >
                              üî∫
                            </span>
                          )}
                        </h3>
                        <p className="text-sm text-green-700 mt-1">{loc.description || t('general.noDescription')}</p>
                        {loc.notes && (
                          <p className="text-xs text-green-600 mt-1 italic">üí≠ {loc.notes}</p>
                        )}
                      </div>
                      <button
                        onClick={() => handleEditLocation(loc)}
                        className="bg-blue-500 text-white px-3 py-2 rounded-lg text-sm font-bold"
                      >
                        ‚úèÔ∏è Edit
                      </button>
                    </div>
                    
                    {/* Image Preview */}
                    {loc.uploadedImage && (
                      <img 
                        src={loc.uploadedImage} 
                        alt={loc.name}
                        className="w-full max-max-h-32 object-contain rounded-lg mt-2 cursor-pointer border-2 border-green-300"
                        onClick={() => {
                          setModalImage(loc.uploadedImage);
                          setShowImageModal(true);
                        }}
                      />
                    )}
                    
                    {/* Interests Tags */}
                    {loc.interests && loc.interests.length > 0 && (
                      <div className="flex flex-wrap gap-1 mt-2">
                        {loc.interests.map(intId => {
                          const interest = interestMap[intId];
                          return interest ? (
                            <span key={intId} className="bg-green-600 text-white text-xs px-2 py-1 rounded-full">
                              {interest.icon?.startsWith?.('data:') ? <img src={interest.icon} alt="" className="w-3.5 h-3.5 object-contain inline" /> : interest.icon} {tLabel(interest)}
                            </span>
                          ) : null;
                        })}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ) : searchQuery && searchResults.length === 0 ? (
              <div className="text-center py-12 text-gray-500">
                <div className="text-6xl mb-4">üîç</div>
                <p className="font-bold">{t("places.noResultsFor")} "{searchQuery}"</p>
                <p className="text-sm mt-2">{t("general.tryDifferentSearch")}</p>/p>
              </div>
            ) : cityCustomLocations.length === 0 ? (
              <div className="text-center py-12 text-gray-500">
                <div className="text-6xl mb-4">üìç</div>
                <p className="font-bold">{t("places.noPlacesInCity", {cityName: tLabel(window.BKK.selectedCity) || t('places.thisCity')})}</p>
                <p className="text-sm mt-2">{t("places.addPlace")}</p>
              </div>
            ) : (
              <div className="text-center py-12 text-gray-500">
                <div className="text-6xl mb-4">üîç</div>
                <p className="font-bold">{t("general.startTypingToSearch")}</p>
                <p className="text-sm mt-2">{`${cityCustomLocations.length} ${t("route.places")} - ${tLabel(window.BKK.selectedCity) || t('places.thisCity')}`}</p>
              </div>
            )}
          </div>
        )}

        {currentView === 'saved' && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-3">
            <div className="flex items-center justify-between mb-3">
              <div className="flex items-center gap-2">
                <h2 className="text-lg font-bold">{`üó∫Ô∏è ${t("nav.saved")}`}</h2>
                <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full">
                  {citySavedRoutes.length}
                </span>
                <button
                  onClick={() => showHelpFor('saved')}
                  className="text-gray-400 hover:text-blue-500 text-sm"
                  title={t("general.help")}
                style={{ background: "none", border: "none", color: "#3b82f6", fontSize: "11px", cursor: "pointer", textDecoration: "underline" }}>{t("general.help")}</button>
              </div>
              <div className="flex items-center gap-2">
                {/* Sort toggle */}
                <div className="flex bg-gray-200 rounded-lg p-0.5">
                  <button
                    onClick={() => setRoutesSortBy('area')}
                    className={`px-2 py-0.5 rounded text-[10px] font-bold ${routesSortBy === 'area' ? 'bg-white shadow text-blue-700' : 'text-gray-500'}`}
                  >{t("places.byArea")}</button>
                  <button
                    onClick={() => setRoutesSortBy('name')}
                    className={`px-2 py-0.5 rounded text-[10px] font-bold ${routesSortBy === 'name' ? 'bg-white shadow text-blue-700' : 'text-gray-500'}`}
                  >{t("places.byName")}</button>
                </div>
              </div>
            </div>
            
            {citySavedRoutes.length === 0 ? (
              <div className="text-center py-8">
                <div className="text-4xl mb-2">üó∫Ô∏è</div>
                <p className="text-gray-600 mb-3 text-sm">{t("places.noSavedRoutesInCity", {cityName: tLabel(window.BKK.selectedCity) || t('places.thisCity')})}</p>
                <button
                  onClick={() => setCurrentView('form')}
                  className="bg-slate-600 text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-slate-700"
                >{t("route.newRoute")}</button>
              </div>
            ) : (
              <div className="space-y-1">
                {(() => {
                  const sorted = [...citySavedRoutes].sort((a, b) => {
                    if (routesSortBy === 'name') return (a.name || '').localeCompare(b.name || '', 'he');
                    return (a.areaName || '').localeCompare(b.areaName || '', 'he');
                  });
                  
                  let lastGroup = null;
                  return sorted.map(savedRoute => {
                    const groupKey = routesSortBy === 'area' ? (savedRoute.areaName || t('general.noArea')) : null;
                    const showGroupHeader = routesSortBy === 'area' && groupKey !== lastGroup;
                    if (showGroupHeader) lastGroup = groupKey;
                    
                    // Collect interest icons from route stops
                    const routeInterestIds = [...new Set((savedRoute.stops || []).flatMap(s => s.interests || []))];
                    
                    return (
                      <React.Fragment key={savedRoute.id}>
                        {showGroupHeader && (
                          <div className="text-xs font-bold text-blue-700 bg-blue-50 px-2 py-1 rounded mt-2 mb-1">
                            üìç {groupKey}
                          </div>
                        )}
                        <div
                          className={`flex items-center justify-between gap-2 rounded-lg p-2 border ${
                            savedRoute.inProgress ? 'border-orange-300 bg-orange-50' : 'border-gray-200 bg-white'
                          } hover:bg-blue-50 cursor-pointer`}
                          onClick={() => loadSavedRoute(savedRoute)}
                        >
                          <div className="flex-1 min-w-0">
                            <div className="flex items-center gap-1 flex-wrap">
                              <span className="font-medium text-sm truncate">{savedRoute.name}</span>
                              {savedRoute.locked && isUnlocked && <span title={t("general.locked")} style={{ fontSize: '11px' }}>üîí</span>}
                              {savedRoute.inProgress && <span title={t("general.inProgress")} style={{ fontSize: '12px' }}>üõ†Ô∏è</span>}
                              {routeInterestIds.slice(0, 5).map((intId, idx) => {
                                const obj = interestMap[intId];
                                return obj?.icon ? <span key={idx} title={obj.label} style={{ fontSize: '12px' }}>{obj.icon}</span> : null;
                              })}
                              <span className="text-[10px] text-gray-400 flex-shrink-0">{savedRoute.stops?.length || 0} stops</span>
                            </div>
                            {savedRoute.notes && (
                              <div className="text-[10px] text-gray-500 truncate mt-0.5">üìù {savedRoute.notes}</div>
                            )}
                          </div>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setEditingRoute({...savedRoute});
                              setRouteDialogMode('edit');
                              setShowRouteDialog(true);
                            }}
                            className="text-xs px-1 py-0.5 rounded hover:bg-blue-100 flex-shrink-0"
                            title={savedRoute.locked && !isUnlocked ? t("general.viewOnly") : t("places.detailsEdit")}
                          >{savedRoute.locked && !isUnlocked ? 'üëÅÔ∏è' : '‚úèÔ∏è'}</button>
                        </div>
                      </React.Fragment>
                    );
                  });
                })()}
              </div>
            )}
          </div>
        )}

                {/* My Content View */}
        {/* My Content View - Compact Design */}
        {currentView === 'myPlaces' && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-3">
            <div className="flex items-center gap-2 mb-3">
              <h2 className="text-lg font-bold">{`üìç ${t("nav.myPlaces")}`}</h2>
              <button
                onClick={() => showHelpFor('myPlaces')}
                className="text-gray-400 hover:text-blue-500 text-sm"
                title={t("general.help")}
              >
                {t("general.help")}
              </button>
            </div>
            
            {/* Custom Locations Section - Split by status */}
            <div className="mb-4">
              <div className="flex justify-between items-center mb-2">
                <h3 className="text-base font-bold">{`${t("nav.myPlaces")} (${cityCustomLocations.filter(l => l.status !== 'blacklist').length})`}</h3>
                <div className="flex items-center gap-2">
                  {/* Group by toggle */}
                  <div className="flex bg-gray-200 rounded-lg p-0.5">
                    <button
                      onClick={() => setPlacesGroupBy('interest')}
                      className={`px-2 py-0.5 rounded text-[10px] font-bold ${placesGroupBy === 'interest' ? 'bg-white shadow text-purple-700' : 'text-gray-500'}`}
                    >
                      {t("places.byInterest")}
                    </button>
                    <button
                      onClick={() => setPlacesGroupBy('area')}
                      className={`px-2 py-0.5 rounded text-[10px] font-bold ${placesGroupBy === 'area' ? 'bg-white shadow text-purple-700' : 'text-gray-500'}`}
                    >
                      {t("places.byArea")}
                    </button>
                  </div>
                  <button
                    onClick={() => setCurrentView('search')}
                    className="text-blue-500 hover:text-blue-700 text-xl"
                    title={t("places.searchResults")}
                  >
                    üîç
                  </button>
                  <button
                    onClick={() => setShowAddLocationDialog(true)}
                    className="bg-teal-500 text-white px-3 py-1.5 rounded-lg text-sm font-bold hover:bg-teal-600"
                  >
                    {t("places.addPlace")}
                  </button>
                </div>
              </div>
              
              {cityCustomLocations.length === 0 ? (
                <div className="text-center py-6 bg-gray-50 rounded-lg">
                  <div className="text-3xl mb-2">üìç</div>
                  <p className="text-gray-600 text-sm">{t("places.noPlacesInCity", {cityName: tLabel(window.BKK.selectedCity) || t('places.thisCity')})}</p>
                  <p className="text-xs text-gray-500 mt-1">{t("places.addPlace")}</p>
                </div>
              ) : (
                <>
                  {/* Active Locations - Grouped (using memoized groupedPlaces) */}
                  {groupedPlaces.activeCount > 0 && (
                    <div className="mb-3">
                      <h4 className="text-sm font-bold text-green-700 mb-2">
                        {t("places.includedPlaces")} ({groupedPlaces.activeCount})
                      </h4>
                      <div className="max-h-[55vh] overflow-y-auto" style={{ contain: 'content' }}>
                        {groupedPlaces.sortedKeys.map(key => {
                          const locs = groupedPlaces.groups[key];
                          const obj = placesGroupBy === 'interest' 
                            ? (interestMap[key] || customInterests?.find(ci => ci.id === key))
                            : areaMap[key];
                          const groupLabel = obj ? tLabel(obj) : key;
                          const groupIcon = placesGroupBy === 'interest' ? (obj?.icon || 'üè∑Ô∏è') : 'üìç';
                          return (
                            <div key={key} className="border border-gray-200 rounded-lg overflow-hidden mb-1.5">
                              <div className="bg-gray-100 px-2 py-1 flex items-center gap-1 text-xs font-bold text-gray-700">
                                <span>{groupIcon?.startsWith?.('data:') ? <img src={groupIcon} alt="" className="w-4 h-4 object-contain inline" /> : groupIcon}</span>
                                <span>{groupLabel}</span>
                                <span className="text-gray-400 font-normal">({locs.length})</span>
                              </div>
                              <div className="p-1">
                                {locs.map(loc => {
                                  const mapUrl = (() => { const u = window.BKK.getGoogleMapsUrl(loc); return u === '#' ? null : u; })();
                                  return (
                                    <div key={loc.id}
                                      className={`flex items-center justify-between gap-2 border-2 rounded p-1.5 mb-0.5 ${isLocationValid(loc) ? "border-gray-200 bg-white" : "border-red-400 bg-red-50"}`}
                                      style={{ contain: 'layout style' }}
                                    >
                                      <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-1 flex-wrap">
                                          {mapUrl ? (
                                            <a href={mapUrl} target="_blank" rel="noopener noreferrer"
                                              className="font-medium text-sm text-blue-600 truncate"
                                            >{loc.name}</a>
                                          ) : (
                                            <span className="font-medium text-sm truncate">{loc.name}</span>
                                          )}
                                          {loc.locked && isUnlocked && <span title={t("general.locked")} style={{ fontSize: '12px' }}>üîí</span>}
                                          {loc.inProgress && <span className="text-orange-600" title={t("general.inProgress")} style={{ fontSize: '14px' }}>üõ†Ô∏è</span>}
                                          {loc.outsideArea && <span className="text-orange-500 text-xs" title={t("general.outsideBoundary")}>üî∫</span>}
                                          {loc.missingCoordinates && <span className="text-red-500 text-xs" title={t("general.noLocation")}>‚ö†Ô∏è</span>}
                                          {!isLocationValid(loc) && <span className="text-red-500 text-[9px]" title={t("places.missingDetailsLong")}>‚ùå</span>}
                                          {placesGroupBy === 'area' && loc.interests?.map((int, idx) => {
                                            const obj2 = interestMap[int];
                                            return obj2?.icon ? <span key={idx} title={obj2.label} style={{ fontSize: '13px' }}>{obj2.icon}</span> : null;
                                          })}
                                          {placesGroupBy === 'interest' && (loc.areas || [loc.area]).filter(Boolean).map((aId, idx) => (
                                            <span key={idx} className="text-[9px] bg-gray-200 text-gray-600 px-1 rounded">{(areaMap[aId] || {}).label || aId}</span>
                                          ))}
                                        </div>
                                      </div>
                                      <button onClick={() => handleEditLocation(loc)}
                                        className="text-xs px-1 py-0.5 rounded"
                                        title={loc.locked && !isUnlocked ? t("general.viewOnly") : t("places.detailsEdit")}>{loc.locked && !isUnlocked ? "üëÅÔ∏è" : "‚úèÔ∏è"}</button>
                                    </div>
                                  );
                                })}
                              </div>
                            </div>
                          );
                        })}
                        {groupedPlaces.ungrouped.length > 0 && (
                          <div className="border border-gray-200 rounded-lg overflow-hidden mb-1.5">
                            <div className="bg-gray-100 px-2 py-1 text-xs font-bold text-gray-500">
                              No interest / manually added ({groupedPlaces.ungrouped.length})
                            </div>
                            <div className="p-1">
                              {groupedPlaces.ungrouped.map(loc => {
                                const mapUrl = (() => { const u = window.BKK.getGoogleMapsUrl(loc); return u === '#' ? null : u; })();
                                return (
                                  <div key={loc.id}
                                    className={`flex items-center justify-between gap-2 border-2 rounded p-1.5 mb-0.5 ${isLocationValid(loc) ? "border-gray-200 bg-white" : "border-red-400 bg-red-50"}`}
                                    style={{ contain: 'layout style' }}
                                  >
                                    <div className="flex-1 min-w-0">
                                      <div className="flex items-center gap-1 flex-wrap">
                                        {mapUrl ? (
                                          <a href={mapUrl} target="_blank" rel="noopener noreferrer"
                                            className="font-medium text-sm text-blue-600 truncate"
                                          >{loc.name}</a>
                                        ) : (
                                          <span className="font-medium text-sm truncate">{loc.name}</span>
                                        )}
                                        {loc.locked && isUnlocked && <span title={t("general.locked")} style={{ fontSize: '12px' }}>üîí</span>}
                                        {loc.inProgress && <span className="text-orange-600" title={t("general.inProgress")} style={{ fontSize: '14px' }}>üõ†Ô∏è</span>}
                                        {!isLocationValid(loc) && <span className="text-red-500 text-[9px]" title={t("places.missingDetails")}>‚ùå</span>}
                                      </div>
                                    </div>
                                    <button onClick={() => handleEditLocation(loc)}
                                      className="text-xs px-1 py-0.5 rounded"
                                      title={loc.locked && !isUnlocked ? t("general.viewOnly") : t("places.detailsEdit")}>{loc.locked && !isUnlocked ? "üëÅÔ∏è" : "‚úèÔ∏è"}</button>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                  
                  {/* Blacklisted Locations - Collapsible */}
                  {groupedPlaces.blacklistedLocations.length > 0 && (
                      <div className="border-2 border-red-300 rounded-lg p-2 bg-red-50">
                        <button
                          onClick={() => setShowBlacklistLocations(!showBlacklistLocations)}
                          className="w-full flex items-center justify-between text-sm font-bold text-red-700"
                        >
                          <span className="flex items-center gap-1">
                            <span>{showBlacklistLocations ? '‚ñº' : '‚óÄ'}</span>
                            <span>{`üö´ ${t("places.skippedPlaces")} (`}{groupedPlaces.blacklistedLocations.length})</span>
                          </span>
                          <span className="text-[10px] text-red-600">
                            {showBlacklistLocations ? t('general.hide') : t('general.show')}
                          </span>
                        </button>
                        
                        {showBlacklistLocations && (
                          <div className="mt-2 max-h-40 overflow-y-auto">
                            {groupedPlaces.blacklistedLocations.map(loc => {
                              const mapUrl = (() => { const u = window.BKK.getGoogleMapsUrl(loc); return u === '#' ? null : u; })();
                              return (
                              <div
                                key={loc.id}
                                className="flex items-center justify-between gap-2 border border-red-300 rounded p-1.5 bg-white mb-0.5"
                                style={{ contain: 'layout style' }}
                              >
                                <div className="flex-1 min-w-0">
                                  <div className="flex items-center gap-1 flex-wrap">
                                    {mapUrl ? (
                                      <a href={mapUrl} target="_blank" rel="noopener noreferrer"
                                        className="font-medium text-sm text-blue-600 truncate"
                                      >{loc.name}</a>
                                    ) : (
                                      <span className="font-medium text-sm truncate">{loc.name}</span>
                                    )}
                                    {loc.locked && isUnlocked && <span title={t("general.locked")} style={{ fontSize: '12px' }}>üîí</span>}
                                    {loc.interests?.map((int, idx) => {
                                      const obj = interestMap[int];
                                      return obj?.icon ? <span key={idx} title={obj.label} style={{ fontSize: '13px' }}>{obj.icon}</span> : null;
                                    })}
                                  </div>
                                </div>
                                <button onClick={() => handleEditLocation(loc)}
                                  className="text-xs px-1 py-0.5 rounded"
                                  title={loc.locked && !isUnlocked ? t("general.viewOnly") : t("places.detailsEdit")}>{loc.locked && !isUnlocked ? "üëÅÔ∏è" : "‚úèÔ∏è"}</button>
                              </div>
                              );
                            })}
                          </div>
                        )}
                      </div>
                  )}
                </>
              )}
            </div>

          </div>
        )}

        {/* My Interests View */}
        {currentView === 'myInterests' && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-3">
            <div className="flex items-center justify-between mb-3">
              <div className="flex items-center gap-2">
                <h2 className="text-lg font-bold">üè∑Ô∏è {t("nav.myInterests")}</h2>
                <button onClick={() => showHelpFor('myInterests')} className="text-blue-400 hover:text-blue-600 text-sm" title={t("general.help")}style={{ background: "none", border: "none", color: "#3b82f6", fontSize: "11px", cursor: "pointer", textDecoration: "underline" }}>{t("general.help")}</button>
                <span className="text-xs bg-gray-200 text-gray-700 px-2 py-0.5 rounded-full">
                  {(window.BKK.interestOptions || []).length + (window.BKK.uncoveredInterests || []).length + (cityCustomInterests || []).length} {t("general.total")}
                </span>
              </div>
              <div className="flex gap-1">
                <button
                  onClick={resetInterestStatusToDefault}
                  className="bg-gray-200 text-gray-700 px-2 py-1.5 rounded-lg text-[10px] font-bold hover:bg-gray-300"
                  title={t("interests.resetToDefault")}
                >
                  {t("interests.resetToDefault")}
                </button>
                <button
                  onClick={() => {
                    setEditingCustomInterest(null);
                    setNewInterest({ label: '', icon: 'üìç', searchMode: 'types', types: '', textSearch: '', blacklist: '', privateOnly: false, inProgress: true, locked: false, builtIn: false });
                    setShowAddInterestDialog(true);
                  }}
                  className="bg-purple-500 text-white px-3 py-1.5 rounded-lg text-sm font-bold hover:bg-purple-600"
                >
                  {t("interests.addInterest")}
                </button>
              </div>
            </div>
            
            {/* Unified Interest List */}
            {(() => {
              // Helper to open interest dialog for editing
              const openInterestDialog = (interest, isCustom = false) => {
                const config = interestConfig[interest.id] || {};
                setEditingCustomInterest(isCustom ? interest : { ...interest, builtIn: true });
                setNewInterest({
                  id: interest.id,
                  label: tLabel(interest) || interest.name || '',
                  icon: interest.icon || 'üìç',
                  searchMode: config.textSearch ? 'text' : 'types',
                  types: (config.types || []).join(', '),
                  textSearch: config.textSearch || '',
                  blacklist: (config.blacklist || []).join(', '),
                  privateOnly: interest.privateOnly || false,
                  inProgress: interest.inProgress || false,
                  locked: interest.locked || false,
                  builtIn: !isCustom
                });
                setShowAddInterestDialog(true);
              };
              
              // Render a single interest row with toggle button
              const renderInterestRow = (interest, isCustom = false, isActive = true) => {
                const isValid = isInterestValid(interest.id);
                const effectiveActive = isValid ? isActive : false; // Invalid always inactive
                const borderClass = !effectiveActive ? 'border border-gray-300 bg-gray-50 opacity-60'
                  : isCustom ? (isValid ? 'border border-gray-200 bg-white' : 'border-2 border-red-400 bg-red-50')
                  : (isValid ? 'border border-gray-200 bg-white' : 'border-2 border-red-400 bg-red-50');
                
                return (
                  <div key={interest.id} className={`flex items-center justify-between gap-2 rounded-lg p-2 ${borderClass}`}>
                    <div className="flex items-center gap-2 flex-1 min-w-0">
                      <span className="text-lg flex-shrink-0">{interest.icon?.startsWith?.('data:') ? <img src={interest.icon} alt="" className="w-5 h-5 object-contain" /> : interest.icon}</span>
                      <span className={`font-medium text-sm truncate ${!effectiveActive ? 'text-gray-500' : ''}`}>{tLabel(interest)}</span>
                      {isCustom && <span className="text-[10px] bg-purple-200 text-purple-800 px-1 py-0.5 rounded flex-shrink-0">{t("general.custom")}</span>}
                      {!isValid && <span className="text-red-500 text-xs flex-shrink-0" title={t("interests.missingSearchConfig")}>‚ö†Ô∏è</span>}
                      {interest.inProgress && <span className="text-orange-600 flex-shrink-0" title={t("general.inProgress")} style={{ fontSize: '12px' }}>üõ†Ô∏è</span>}
                      {interest.locked && isUnlocked && <span title={t("general.locked")} style={{ fontSize: '11px' }} className="flex-shrink-0">üîí</span>}
                    </div>
                    <div className="flex gap-1 flex-shrink-0">
                      {/* Toggle button */}
                      <button
                        onClick={() => toggleInterestStatus(interest.id)}
                        disabled={!isValid}
                        className={`text-[10px] px-2 py-1 rounded font-bold transition ${
                          !isValid ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                          : effectiveActive ? 'bg-red-100 text-red-600 hover:bg-red-200' 
                          : 'bg-green-100 text-green-600 hover:bg-green-200'
                        }`}
                        title={!isValid ? t('interests.interestInvalid') : effectiveActive ? t('general.disable') : t('general.enable')}
                      >
                        {effectiveActive ? t('general.disable') : t('general.enableAlt')}
                      </button>
                      <button
                        onClick={() => openInterestDialog(interest, isCustom)}
                        className="text-xs px-1 py-0.5 rounded flex-shrink-0"
                        title={interest.locked && !isUnlocked ? t("general.viewOnly") : t("places.detailsEdit")}
                      >{interest.locked && !isUnlocked ? 'üëÅÔ∏è' : '‚úèÔ∏è'}</button>
                    </div>
                  </div>
                );
              };
              
              // Collect active and inactive - apply config overrides to built-in
              const overriddenBuiltIn = interestOptions.map(i => {
                const cfg = interestConfig[i.id];
                if (!cfg) return i;
                return { ...i, label: cfg.labelOverride || i.label, icon: cfg.iconOverride || i.icon, inProgress: cfg.inProgress !== undefined ? cfg.inProgress : i.inProgress, locked: cfg.locked !== undefined ? cfg.locked : i.locked };
              });
              const overriddenUncovered = uncoveredInterests.map(i => {
                const cfg = interestConfig[i.id];
                if (!cfg) return i;
                return { ...i, label: cfg.labelOverride || i.label, icon: cfg.iconOverride || i.icon, inProgress: cfg.inProgress !== undefined ? cfg.inProgress : i.inProgress, locked: cfg.locked !== undefined ? cfg.locked : i.locked };
              });
              const activeBuiltIn = overriddenBuiltIn.filter(i => isInterestValid(i.id) && interestStatus[i.id] !== false);
              const activeUncovered = overriddenUncovered.filter(i => isInterestValid(i.id) && interestStatus[i.id] === true);
              const activeCustom = cityCustomInterests.filter(i => isInterestValid(i.id) && interestStatus[i.id] !== false);
              const inactiveBuiltIn = overriddenBuiltIn.filter(i => !isInterestValid(i.id) || interestStatus[i.id] === false);
              const inactiveUncovered = overriddenUncovered.filter(i => !isInterestValid(i.id) || interestStatus[i.id] !== true);
              const inactiveCustom = cityCustomInterests.filter(i => !isInterestValid(i.id) || interestStatus[i.id] === false);
              
              return (
                <>
                  {/* Active Interests */}
                  <div className="mb-4">
                    <h3 className="text-sm font-bold text-green-700 mb-2">
                      {t("interests.activeInterests")} ({activeBuiltIn.length + activeUncovered.length + activeCustom.length})
                    </h3>
                    <div className="space-y-1">
                      {activeBuiltIn.map(i => renderInterestRow(i, false, true))}
                      {activeUncovered.map(i => renderInterestRow(i, false, true))}
                      {activeCustom.map(i => renderInterestRow(i, true, true))}
                    </div>
                  </div>
                  
                  {/* Inactive Interests */}
                  {(inactiveBuiltIn.length + inactiveUncovered.length + inactiveCustom.length) > 0 && (
                    <div className="mb-2">
                      <h3 className="text-sm font-bold text-gray-500 mb-2">
                        ‚è∏Ô∏è Disabled interests ({inactiveBuiltIn.length + inactiveUncovered.length + inactiveCustom.length})
                      </h3>
                      <div className="space-y-1">
                        {inactiveBuiltIn.map(i => renderInterestRow(i, false, false))}
                        {inactiveUncovered.map(i => renderInterestRow(i, false, false))}
                        {inactiveCustom.map(i => renderInterestRow(i, true, false))}
                      </div>
                    </div>
                  )}
                </>
              );
            })()}
          </div>
        )}

        {/* Settings View - Compact Design */}
        {currentView === 'settings' && (
          <div className="view-fade-in bg-white rounded-xl shadow-lg p-3">
            <div className="flex items-center gap-2 mb-3">
              <h2 className="text-lg font-bold">{t("settings.title")}</h2>
              <button
                onClick={() => showHelpFor('settings')}
                className="text-gray-400 hover:text-blue-500 text-sm"
                title={t("general.help")}
              >
                {t("general.help")}
              </button>
            </div>
            
            {/* Settings Sub-Tabs */}
            <div className="flex gap-2 mb-3">
              <button
                onClick={() => setSettingsTab('cities')}
                className={`flex-1 py-2 rounded-lg font-bold text-sm transition ${
                  settingsTab === 'cities' ? 'bg-rose-500 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                }`}
              >{`üåç ${t('settings.citiesAndAreas')}`}</button>
              <button
                onClick={() => setSettingsTab('general')}
                className={`flex-1 py-2 rounded-lg font-bold text-sm transition ${
                  settingsTab === 'general' ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                }`}
              >{`‚öôÔ∏è ${t('settings.generalSettings')}`}</button>
            </div>

            {/* ===== CITIES & AREAS TAB ===== */}
            {settingsTab === 'cities' && (<div>

            {/* City & Area Management */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-rose-50 to-orange-50 border-2 border-rose-400 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-2">{`üåç ${t("settings.title")}`}</h3>
                
                {/* City selector dropdown + selected city details */}
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px', flexWrap: 'wrap' }}>
                  <select
                    value={selectedCityId}
                    onChange={(e) => switchCity(e.target.value, true)}
                    style={{ padding: '6px 10px', borderRadius: '8px', border: '2px solid #e11d48', fontSize: '13px', fontWeight: 'bold', color: '#e11d48', background: '#fef2f2', cursor: 'pointer', minWidth: '140px' }}
                  >
                    {Object.values(window.BKK.cities || {}).map(city => (
                      <option key={city.id} value={city.id}>{city.icon} {tLabel(city)}</option>
                    ))}
                  </select>
                  <button onClick={() => setShowAddCityDialog(true)}
                    style={{ padding: '5px 10px', borderRadius: '8px', border: '1.5px dashed #d1d5db', background: 'white', cursor: 'pointer', fontSize: '11px', color: '#6b7280' }}
                  >‚ûï {t('settings.addCity')}</button>
                </div>
                
                {/* Selected city info bar */}
                {(() => {
                  const city = window.BKK.selectedCity;
                  if (!city) return null;
                  const isActive = city.active !== false;
                  return (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px', padding: '6px 10px', background: isActive ? '#ecfdf5' : '#fef2f2', borderRadius: '8px', border: `1px solid ${isActive ? '#a7f3d0' : '#fecaca'}`, flexWrap: 'wrap' }}>
                      {isUnlocked ? (
                        <React.Fragment>
                          <input type="text" value={city.icon || 'üìç'}
                            onChange={(e) => { city.icon = e.target.value; if (window.BKK.cityRegistry[city.id]) window.BKK.cityRegistry[city.id].icon = e.target.value; setCityModified(true); setCityEditCounter(c => c + 1); }}
                            style={{ width: '42px', fontSize: '18px', textAlign: 'center', padding: '2px', border: '1px solid #d1d5db', borderRadius: '6px', background: '#fff' }}
                          />
                          <input type="text" value={city.name || ''}
                            onChange={(e) => { city.name = e.target.value; if (window.BKK.cityRegistry[city.id]) window.BKK.cityRegistry[city.id].name = e.target.value; setCityModified(true); setCityEditCounter(c => c + 1); }}
                            style={{ width: '70px', fontSize: '12px', padding: '2px 4px', border: '1px solid #d1d5db', borderRadius: '6px', fontWeight: 'bold' }}
                            placeholder="HE"
                          />
                          <input type="text" value={city.nameEn || ''}
                            onChange={(e) => { city.nameEn = e.target.value; if (window.BKK.cityRegistry[city.id]) window.BKK.cityRegistry[city.id].nameEn = e.target.value; setCityModified(true); setCityEditCounter(c => c + 1); }}
                            style={{ width: '70px', fontSize: '12px', padding: '2px 4px', border: '1px solid #d1d5db', borderRadius: '6px' }}
                            placeholder="EN"
                          />
                        </React.Fragment>
                      ) : (
                        <span style={{ fontSize: '13px', fontWeight: 'bold' }}>{city.icon} {tLabel(city)}</span>
                      )}
                      <span style={{ fontSize: '10px', color: '#6b7280' }}>{city.areas?.length || 0} {t('general.areas')} ¬∑ {city.interests?.length || 0} {t('nav.myInterests')}</span>
                          <button onClick={() => {
                            city.active = !isActive;
                            try { const s = JSON.parse(localStorage.getItem('city_active_states') || '{}'); s[city.id] = city.active; localStorage.setItem('city_active_states', JSON.stringify(s)); } catch(e) {}
                            showToast(tLabel(city) + (city.active ? ' ‚úì' : ' ‚úó'), 'info');
                            setFormData(prev => ({...prev}));
                          }} style={{ fontSize: '10px', padding: '2px 8px', borderRadius: '6px', border: 'none', cursor: 'pointer', background: isActive ? '#dcfce7' : '#fee2e2', color: isActive ? '#16a34a' : '#ef4444', fontWeight: 'bold' }}
                          >{isActive ? `‚ñ∂Ô∏è ${t('general.active')}` : `‚è∏Ô∏è ${t('general.inactive')}`}</button>
                          <button onClick={() => { window.BKK.exportCityFile(city); showToast(`üì• city-${city.id}.js`, 'success'); setCityModified(false); }}
                            style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '6px', border: '1px solid #d1d5db', cursor: 'pointer', background: 'white', color: '#6b7280' }}
                          >üì• {t('settings.exportCity')}</button>
                          {Object.keys(window.BKK.cities || {}).length > 1 && (
                            <button onClick={async () => {
                              const pw = prompt(t('settings.enterPasswordToRemove'));
                              if (pw === null) return;
                              if (adminPassword) {
                                const hashedInput = await window.BKK.hashPassword(pw);
                                if (hashedInput !== adminPassword && pw !== adminPassword) { showToast(t('settings.wrongPassword'), 'error'); return; }
                              }
                              if (!confirm(`‚ö†Ô∏è ${t('general.remove')} ${tLabel(city)}?`)) return;
                              const otherCity = Object.keys(window.BKK.cities || {}).find(id => id !== city.id);
                              if (otherCity) switchCity(otherCity, true);
                              window.BKK.unloadCity(city.id);
                              try { const s = JSON.parse(localStorage.getItem('city_active_states') || '{}'); delete s[city.id]; localStorage.setItem('city_active_states', JSON.stringify(s)); } catch(e) {}
                              showToast(`${tLabel(city)} ${t('general.removed')}`, 'info');
                              setCityModified(false);
                              setFormData(prev => ({...prev}));
                            }} style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '6px', border: '1px solid #fecaca', cursor: 'pointer', background: '#fef2f2', color: '#ef4444' }}
                            >üóëÔ∏è {t('general.remove')}</button>
                          )}
                    </div>
                  );
                })()}

                {/* Theme Editor - Color + Icons */}
                {isUnlocked && window.BKK.selectedCity && (() => {
                  const city = window.BKK.selectedCity;
                  if (!city.theme) city.theme = { color: '#e11d48', iconLeft: 'üèôÔ∏è', iconRight: 'üó∫Ô∏è' };
                  const theme = city.theme;
                  return (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '6px', padding: '6px 10px', background: '#f8fafc', borderRadius: '8px', border: '1px solid #e2e8f0', flexWrap: 'wrap' }}>
                      <span style={{ fontSize: '11px', fontWeight: 'bold', color: '#475569' }}>üé®</span>
                      <input type="color" value={theme.color || '#e11d48'}
                        onChange={(e) => { 
                          city.theme.color = e.target.value;
                          setCityModified(true); setCityEditCounter(c => c + 1);
                        }}
                        style={{ width: '28px', height: '22px', border: 'none', cursor: 'pointer', borderRadius: '4px', padding: 0 }}
                      />
                      <input type="text" value={theme.iconLeft || ''} placeholder="‚óÄ"
                        onChange={(e) => {
                          city.theme.iconLeft = e.target.value;
                          setCityModified(true); setCityEditCounter(c => c + 1);
                        }}
                        style={{ width: '36px', fontSize: '14px', textAlign: 'center', padding: '2px', border: '1px solid #d1d5db', borderRadius: '6px' }}
                      />
                      <div style={{ width: '60px', height: '22px', borderRadius: '6px', background: theme.color || '#e11d48', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <span style={{ color: 'white', fontSize: '9px', fontWeight: 'bold' }}>{tLabel(city)}</span>
                      </div>
                      <input type="text" value={theme.iconRight || ''} placeholder="‚ñ∂"
                        onChange={(e) => {
                          city.theme.iconRight = e.target.value;
                          setCityModified(true); setCityEditCounter(c => c + 1);
                        }}
                        style={{ width: '36px', fontSize: '14px', textAlign: 'center', padding: '2px', border: '1px solid #d1d5db', borderRadius: '6px' }}
                      />
                    </div>
                  );
                })()}

                {/* Modified indicator + actions */}
                {cityModified && (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px', padding: '6px 10px', background: '#fef3c7', borderRadius: '8px', border: '1px solid #fcd34d' }}>
                    <span style={{ fontSize: '11px', color: '#92400e', fontWeight: 'bold' }}>‚ö†Ô∏è {t('settings.unsavedChanges')}</span>
                    <button onClick={() => { 
                      const city = window.BKK.selectedCity;
                      if (city) { window.BKK.exportCityFile(city); showToast(`üì• city-${city.id}.js`, 'success'); setCityModified(false); }
                    }} style={{ fontSize: '10px', padding: '3px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', background: '#f59e0b', color: 'white', fontWeight: 'bold' }}
                    >üì• {t('settings.exportCity')}</button>
                  </div>
                )}

                {/* Add Area + Show Map buttons */}
                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '6px', marginBottom: '4px' }}>
                  <button onClick={() => {
                    setShowSettingsMap(!showSettingsMap);
                    if (!showSettingsMap) {
                      setTimeout(() => {
                        const container = document.getElementById('settings-all-areas-map');
                        if (!container || !window.L) return;
                        container.innerHTML = '';
                        container._leaflet_id = null;
                        const city = window.BKK.selectedCity;
                        if (!city) return;
                        const coords = window.BKK.areaCoordinates || {};
                        const areas = city.areas || [];
                        const cityCenter = city.center || { lat: 13.75, lng: 100.53 };
                        const map = L.map(container).setView([cityCenter.lat, cityCenter.lng], 12);
                        L.tileLayer(window.BKK.getTileUrl(), { attribution: '¬© OpenStreetMap contributors', maxZoom: 18 }).addTo(map);
                        const colorPalette = ['#3b82f6', '#f59e0b', '#ef4444', '#10b981', '#ec4899', '#6366f1', '#8b5cf6', '#06b6d4', '#f97316', '#a855f7', '#14b8a6', '#e11d48', '#84cc16', '#0ea5e9', '#d946ef', '#f43f5e'];
                        const allCircles = [];
                        areas.forEach((area, i) => {
                          const c = coords[area.id];
                          if (!c) return;
                          const color = colorPalette[i % colorPalette.length];
                          const circle = L.circle([c.lat, c.lng], { radius: c.radius, color, fillColor: color, fillOpacity: 0.15, weight: 2 }).addTo(map);
                          allCircles.push(circle);
                          const marker = L.marker([c.lat, c.lng], { draggable: true, title: tLabel(area) }).addTo(map);
                          marker.bindTooltip(tLabel(area), { permanent: true, direction: 'top', className: 'area-label-tooltip', offset: [0, -10] });
                          marker.on('dragend', () => {
                            const pos = marker.getLatLng();
                            const newLat = Math.round(pos.lat * 10000) / 10000;
                            const newLng = Math.round(pos.lng * 10000) / 10000;
                            area.lat = newLat; area.lng = newLng;
                            c.lat = newLat; c.lng = newLng;
                            circle.setLatLng(pos);
                            setCityModified(true); setCityEditCounter(c => c + 1);
                            setFormData(prev => ({...prev}));
                          });
                        });
                        if (allCircles.length > 0) {
                          const group = L.featureGroup(allCircles);
                          map.fitBounds(group.getBounds().pad(0.1));
                        }
                        window._settingsMap = map;
                        setTimeout(() => map.invalidateSize(), 200);
                      }, 300);
                    } else {
                      try { if (window._settingsMap) { window._settingsMap.off(); window._settingsMap.remove(); } } catch(e) {}
                      window._settingsMap = null;
                    }
                  }} style={{ fontSize: '10px', padding: '3px 10px', borderRadius: '6px', border: '1.5px solid #3b82f6', cursor: 'pointer', background: showSettingsMap ? '#3b82f6' : '#eff6ff', color: showSettingsMap ? 'white' : '#2563eb', fontWeight: 'bold' }}
                  >{showSettingsMap ? '‚úï' : 'üó∫Ô∏è'} {t('wizard.allAreasMap')}</button>
                  <button onClick={() => {
                    const city = window.BKK.selectedCity;
                    if (!city) return;
                    const name = prompt(t('settings.newAreaName'));
                    if (!name || !name.trim()) return;
                    const id = name.trim().toLowerCase().replace(/[^a-z0-9]/g, '_');
                    if (city.areas.some(a => a.id === id)) { showToast(t('settings.areaExists'), 'warning'); return; }
                    const newArea = { id, label: name.trim(), labelEn: name.trim(), desc: '', descEn: '', lat: city.center?.lat || 0, lng: city.center?.lng || 0, radius: 2000, size: 'medium', safety: 'safe' };
                    city.areas.push(newArea);
                    window.BKK.areaCoordinates[id] = { lat: newArea.lat, lng: newArea.lng, radius: newArea.radius, distanceMultiplier: city.distanceMultiplier || 1.2, size: 'medium', safety: 'safe' };
                    window.BKK.areaOptions.push({ id, label: newArea.label, labelEn: newArea.labelEn, desc: '', descEn: '' });
                    setCityModified(true); setCityEditCounter(c => c + 1);
                    showToast(`‚ûï ${name.trim()}`, 'success');
                    setFormData(prev => ({...prev}));
                  }} style={{ fontSize: '10px', padding: '3px 10px', borderRadius: '6px', border: '1.5px dashed #d1d5db', cursor: 'pointer', background: 'white', color: '#6b7280' }}
                  >‚ûï {t('settings.addArea')}</button>
                </div>

                {/* All areas map */}
                {showSettingsMap && (
                  <div id="settings-all-areas-map" style={{ height: '450px', borderRadius: '8px', border: '2px solid #3b82f6', marginBottom: '8px' }}></div>
                )}

                {/* Areas list for selected city */}
                <div style={{ overflowY: 'auto', maxHeight: editingArea ? 'none' : '350px', border: '1px solid #e5e7eb', borderRadius: '8px', padding: '4px' }}>
                  {/* Build combined list: whole city + areas */}
                  {(() => {
                    const city = window.BKK.selectedCity;
                    if (!city) return null;
                    const wholeCityItem = { id: '__whole_city__', label: t('general.allCity'), labelEn: 'Whole City', desc: '', descEn: '', lat: city.center?.lat || 0, lng: city.center?.lng || 0, radius: city.allCityRadius || 15000, safety: 'safe', isWholeCity: true };
                    const allItems = [wholeCityItem, ...(city.areas || [])];
                    
                    return allItems.map((area, i) => {
                      const isEditing = editingArea?.id === area.id;
                      const safetyColors = { safe: '#22c55e', caution: '#f59e0b', danger: '#ef4444' };
                      const safetyLabels = { safe: t('general.safeArea'), caution: t('general.caution'), danger: t('general.dangerArea') };
                      const areaCoord = window.BKK.areaCoordinates?.[area.id] || {};
                      
                      return (
                        <div key={area.id} style={{ padding: '5px 6px', borderBottom: i < allItems.length - 1 ? '1px solid #f3f4f6' : 'none', fontSize: '11px', background: area.isWholeCity ? '#fefce8' : 'transparent' }}>
                          {/* Area header row */}
                          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <span style={{ fontWeight: 'bold', flex: 1, color: '#1f2937' }}>{area.isWholeCity ? 'üåê ' : ''}{tLabel(area)}</span>
                            <span style={{ fontSize: '9px', color: '#6b7280' }}>{area.radius}m</span>
                            {!area.isWholeCity && (
                              <span style={{ fontSize: '9px', padding: '1px 4px', borderRadius: '4px', background: safetyColors[area.safety || 'safe'] + '20', color: safetyColors[area.safety || 'safe'], fontWeight: 'bold' }}>
                                {safetyLabels[area.safety || 'safe']}
                              </span>
                            )}
                            {!area.isWholeCity && !isEditing && (
                              <button onClick={() => {
                                const newName = prompt(t('settings.renameArea'), tLabel(area));
                                if (!newName || !newName.trim() || newName.trim() === tLabel(area)) return;
                                area.label = newName.trim();
                                area.labelEn = newName.trim();
                                const ao = window.BKK.areaOptions?.find(a => a.id === area.id);
                                if (ao) { ao.label = area.label; ao.labelEn = area.labelEn; }
                                setCityModified(true); setCityEditCounter(c => c + 1);
                                showToast(`‚úèÔ∏è ${newName.trim()}`, 'success');
                                setFormData(prev => ({...prev}));
                              }} style={{ fontSize: '8px', color: '#6b7280', background: 'none', border: 'none', cursor: 'pointer', padding: '0 2px' }}
                              title={t('settings.renameArea')}>‚úèÔ∏è</button>
                            )}
                            {!area.isWholeCity && !isEditing && (
                              <button onClick={() => {
                                if (!confirm(`${t('general.remove')} ${tLabel(area)}?`)) return;
                                const city = window.BKK.selectedCity;
                                if (!city) return;
                                city.areas = city.areas.filter(a => a.id !== area.id);
                                delete window.BKK.areaCoordinates[area.id];
                                window.BKK.areaOptions = window.BKK.areaOptions.filter(a => a.id !== area.id);
                                setCityModified(true); setCityEditCounter(c => c + 1);
                                showToast(`üóëÔ∏è ${tLabel(area)}`, 'info');
                                setFormData(prev => ({...prev}));
                              }} style={{ fontSize: '8px', color: '#d1d5db', background: 'none', border: 'none', cursor: 'pointer', padding: '0 2px' }}
                              title={t('general.remove')}>üóëÔ∏è</button>
                            )}
                            {!isEditing && (
                              <button
                                onClick={() => {
                                  try { if (window._editMap) { window._editMap.off(); window._editMap.remove(); } } catch(e) {}
                                  window._editMap = null; window._editCircle = null; window._editMarker = null;
                                  // Store original values for cancel
                                  window._editOriginal = { lat: area.lat, lng: area.lng, radius: area.radius, safety: area.safety, distanceMultiplier: area.distanceMultiplier };
                                  setEditingArea(area);
                                  setTimeout(() => {
                                    const container = document.getElementById(`area-edit-map-${area.id}`);
                                    if (!container || !window.L) return;
                                    container.innerHTML = '';
                                    container._leaflet_id = null;
                                    const zoom = area.isWholeCity ? 11 : 13;
                                    const map = L.map(container).setView([area.lat, area.lng], zoom);
                                    L.tileLayer(window.BKK.getTileUrl(), { attribution: '¬© OpenStreetMap contributors', maxZoom: 18 }).addTo(map);
                                    const color = area.isWholeCity ? '#eab308' : '#10b981';
                                    const circle = L.circle([area.lat, area.lng], { radius: area.radius, color: color, fillOpacity: 0.15, weight: 2 }).addTo(map);
                                    const marker = L.marker([area.lat, area.lng], { draggable: true }).addTo(map);
                                    marker.on('dragend', () => {
                                      const pos = marker.getLatLng();
                                      area.lat = Math.round(pos.lat * 10000) / 10000;
                                      area.lng = Math.round(pos.lng * 10000) / 10000;
                                      if (area.isWholeCity) { city.center = { lat: area.lat, lng: area.lng }; }
                                      else { const ac = window.BKK.areaCoordinates?.[area.id]; if (ac) { ac.lat = area.lat; ac.lng = area.lng; } }
                                      circle.setLatLng(pos);
                                      setFormData(prev => ({...prev}));
                                    });
                                    window._editMap = map; window._editCircle = circle; window._editMarker = marker;
                                    map.fitBounds(circle.getBounds().pad(0.3));
                                    setTimeout(() => { map.invalidateSize(); map.fitBounds(circle.getBounds().pad(0.3)); }, 100);
                                    setTimeout(() => { map.invalidateSize(); map.fitBounds(circle.getBounds().pad(0.3)); }, 400);
                                    setTimeout(() => { map.invalidateSize(); }, 800);
                                    setTimeout(() => { const el = document.getElementById(`area-edit-map-${area.id}`); if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 500);
                                  }, 300);
                                }}
                                style={{ fontSize: '9px', padding: '1px 5px', borderRadius: '4px', border: '1px solid #3b82f6', background: '#eff6ff', color: '#2563eb', cursor: 'pointer' }}
                              >‚úèÔ∏è {t('general.edit')}</button>
                            )}
                          </div>
                          {/* Read-only desc */}
                          {!isEditing && <div style={{ fontSize: '9px', color: '#9ca3af', marginTop: '1px' }}>{tDesc(area)}</div>}
                          
                          {/* Edit mode */}
                          {isEditing && (
                            <div style={{ marginTop: '8px', border: '2px solid #3b82f6', borderRadius: '8px', padding: '8px', background: '#f0f9ff' }}>
                              <div id={`area-edit-map-${area.id}`} style={{ height: '400px', borderRadius: '8px', border: '1px solid #d1d5db', marginBottom: '8px' }}></div>
                              <div className="flex items-center gap-3 flex-wrap mb-2">
                                <label className="text-[9px] text-gray-600 flex items-center gap-1">
                                  {t('settings.radius')}:
                                  <input type="range" min={area.isWholeCity ? '5000' : '500'} max={area.isWholeCity ? '30000' : '10000'} step="100" value={area.radius}
                                    onChange={(e) => {
                                      const v = parseInt(e.target.value);
                                      area.radius = v;
                                      if (area.isWholeCity) { city.allCityRadius = v; }
                                      else { const ac = window.BKK.areaCoordinates?.[area.id]; if (ac) ac.radius = v; }
                                      if (window._editCircle) window._editCircle.setRadius(v);
                                      setFormData(prev => ({...prev}));
                                    }}
                                    style={{ width: '100px' }}
                                  />
                                  <span className="font-bold">{area.radius}m</span>
                                </label>
                                {!area.isWholeCity && (
                                  <label className="text-[9px] text-gray-600 flex items-center gap-1">
                                    {t('general.multiplier')}:
                                    <input type="number" step="0.1" value={area.distanceMultiplier || city.distanceMultiplier || 1.2}
                                      style={{ width: '40px', fontSize: '9px', padding: '1px 3px', border: '1px solid #d1d5db', borderRadius: '4px' }}
                                      onChange={(e) => { area.distanceMultiplier = parseFloat(e.target.value) || 1.2; const ac = window.BKK.areaCoordinates?.[area.id]; if (ac) ac.distanceMultiplier = area.distanceMultiplier; setFormData(prev => ({...prev})); }}
                                    />
                                  </label>
                                )}
                                {!area.isWholeCity && (
                                  <select value={area.safety || 'safe'} style={{ fontSize: '9px', padding: '1px 2px', border: '1px solid #d1d5db', borderRadius: '4px', color: safetyColors[area.safety || 'safe'] }}
                                    onChange={(e) => { area.safety = e.target.value; const ac = window.BKK.areaCoordinates?.[area.id]; if (ac) ac.safety = area.safety; setFormData(prev => ({...prev})); }}
                                  >
                                    {['safe','caution','danger'].map(s => <option key={s} value={s}>{safetyLabels[s]}</option>)}
                                  </select>
                                )}
                              </div>
                              <div className="flex gap-2">
                                <button
                                  onClick={() => {
                                    try { if (window._editMap) { window._editMap.off(); window._editMap.remove(); } } catch(e) {}
                                    window._editMap = null;
                                    setEditingArea(null);
                                    setCityModified(true); setCityEditCounter(c => c + 1);
                                    showToast(`‚úì ${tLabel(area)}`, 'success');
                                  }}
                                  className="px-3 py-1 bg-emerald-500 text-white rounded-lg text-xs font-bold hover:bg-emerald-600"
                                >‚úì {t('general.save')}</button>
                                <button
                                  onClick={() => {
                                    // Restore original values
                                    const orig = window._editOriginal;
                                    if (orig) {
                                      area.lat = orig.lat; area.lng = orig.lng; area.radius = orig.radius; area.safety = orig.safety; area.distanceMultiplier = orig.distanceMultiplier;
                                      if (area.isWholeCity) { city.center = { lat: orig.lat, lng: orig.lng }; city.allCityRadius = orig.radius; }
                                      else { const ac = window.BKK.areaCoordinates?.[area.id]; if (ac) { ac.lat = orig.lat; ac.lng = orig.lng; ac.radius = orig.radius; ac.safety = orig.safety; ac.distanceMultiplier = orig.distanceMultiplier; } }
                                    }
                                    try { if (window._editMap) { window._editMap.off(); window._editMap.remove(); } } catch(e) {}
                                    window._editMap = null;
                                    setEditingArea(null);
                                    setFormData(prev => ({...prev}));
                                  }}
                                  className="px-3 py-1 bg-gray-200 text-gray-700 rounded-lg text-xs font-bold hover:bg-gray-300"
                                >‚úï {t('general.cancel')}</button>
                              </div>
                            </div>
                          )}
                        </div>
                      );
                    });
                  })()}
                </div>
              </div>
            </div>


            </div>)}

            {/* ===== GENERAL SETTINGS TAB ===== */}
            {settingsTab === 'general' && (<div>

            {/* Language */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-2">üåê {t('settings.language')}</h3>
                <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                  {Object.entries((window.BKK.i18n && window.BKK.i18n.languages) || {}).map(([langId, langInfo]) => (
                    <button
                      key={langId}
                      onClick={() => switchLanguage(langId)}
                      style={{
                        padding: '5px 14px', borderRadius: '16px', cursor: 'pointer', fontSize: '12px', fontWeight: 'bold',
                        border: currentLang === langId ? '2px solid #3b82f6' : '1.5px solid #e5e7eb',
                        background: currentLang === langId ? '#eff6ff' : 'white',
                        color: currentLang === langId ? '#2563eb' : '#6b7280',
                        transition: 'all 0.2s'
                      }}
                    >{langInfo.flag} {langInfo.name}</button>
                  ))}
                </div>
              </div>
            </div>

            {/* Max Stops Setting */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-400 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-1">{`üìç ${t("settings.maxStops")}`}</h3>
                <input
                  type="number"
                  min="1"
                  max="100"
                  value={formData.maxStops}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 12;
                    const clamped = Math.min(100, Math.max(1, val));
                    setFormData({...formData, maxStops: clamped});
                    try {
                      const database = window.BKK.database;
                      if (database && isUnlocked) database.ref('settings/maxStops').set(clamped);
                    } catch (err) { console.error('[SETTINGS] Error saving maxStops:', err); }
                  }}
                  className="w-20 p-1 border-2 border-blue-300 rounded text-center font-bold text-sm"
                  placeholder="10"
                />
                <span className="text-[10px] text-gray-500 mr-2">(1-100)</span>
              </div>
            </div>
            
            {/* Fetch More Count Setting - NEW */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-400 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-1">{`‚ûï ${t("route.moreFromCategory")}`}</h3>
                <input
                  type="number"
                  min="1"
                  max="100"
                  value={formData.fetchMoreCount || 3}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 3;
                    const clamped = Math.min(100, Math.max(1, val));
                    setFormData({...formData, fetchMoreCount: clamped});
                    try {
                      const database = window.BKK.database;
                      if (database && isUnlocked) database.ref('settings/fetchMoreCount').set(clamped);
                    } catch (err) { console.error('[SETTINGS] Error saving fetchMoreCount:', err); }
                  }}
                  className="w-20 p-1 border-2 border-green-300 rounded text-center font-bold text-sm"
                  placeholder="5"
                />
                <span className="text-[10px] text-gray-500 mr-2">(1-100)</span>
              </div>
            </div>
            
            {/* Google Max Waypoints Setting (admin only) */}
            {isUnlocked && (
            <div className="mb-3">
              <div className="bg-gradient-to-r from-orange-50 to-amber-50 border-2 border-orange-400 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-1">{`üó∫Ô∏è ${t("settings.googleMaxWaypoints")}`}</h3>
                <p className="text-[10px] text-gray-600 mb-1">{t("settings.googleMaxWaypointsDesc")}</p>
                <input
                  type="number"
                  min="4"
                  max="50"
                  value={googleMaxWaypoints}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 12;
                    const clamped = Math.min(50, Math.max(4, val));
                    setGoogleMaxWaypoints(clamped);
                    try {
                      const database = window.BKK.database;
                      if (database) database.ref('settings/googleMaxWaypoints').set(clamped);
                    } catch (err) { console.error('[SETTINGS] Error saving googleMaxWaypoints:', err); }
                  }}
                  className="w-20 p-1 border-2 border-orange-300 rounded text-center font-bold text-sm"
                  placeholder="12"
                />
                <span className="text-[10px] text-gray-500 mr-2">(4-50)</span>
              </div>
            </div>
            )}
            
            {/* Google Max Map Points Setting (admin only) */}
            {isUnlocked && (
            <div className="mb-3">
              <div className="bg-gradient-to-r from-orange-50 to-amber-50 border-2 border-orange-400 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-1">{`üìç ${t("settings.googleMaxMapPoints")}`}</h3>
                <p className="text-[10px] text-gray-600 mb-1">{t("settings.googleMaxMapPointsDesc")}</p>
                <input
                  type="number"
                  min="3"
                  max="50"
                  value={googleMaxMapPoints}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 10;
                    const clamped = Math.min(50, Math.max(3, val));
                    setGoogleMaxMapPoints(clamped);
                    try {
                      const database = window.BKK.database;
                      if (database) database.ref('settings/googleMaxMapPoints').set(clamped);
                    } catch (err) { console.error('[SETTINGS] Error saving googleMaxMapPoints:', err); }
                  }}
                  className="w-20 p-1 border-2 border-orange-300 rounded text-center font-bold text-sm"
                  placeholder="10"
                />
                <span className="text-[10px] text-gray-500 mr-2">(3-50)</span>
              </div>
            </div>
            )}
            
            {/* Default Radius Setting */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-300 rounded-lg p-2">
                <h3 className="text-sm font-bold text-gray-800 mb-1">{`üìç ${t("settings.defaultRadius")}`}</h3>
                <p className="text-[10px] text-gray-600 mb-1">{t("settings.radiusDescription")}</p>
                <input
                  type="range"
                  min="100"
                  max="2000"
                  step="100"
                  value={formData.radiusMeters}
                  onChange={(e) => {
                    const val = parseInt(e.target.value);
                    setFormData({...formData, radiusMeters: val});
                    try {
                      const database = window.BKK.database;
                      if (database && isUnlocked) database.ref('settings/defaultRadius').set(val);
                    } catch (err) { console.error('[SETTINGS] Error saving defaultRadius:', err); }
                  }}
                  className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                  style={{ accentColor: '#ea580c' }}
                />
                <div className="flex justify-between items-center mt-1">
                  <span className="text-[10px] text-gray-400">100m</span>
                  <span className="text-sm font-bold text-blue-600">{formData.radiusMeters}m</span>
                  <span className="text-[10px] text-gray-400">2000m</span>
                </div>
              </div>
            </div>
            
            {/* Refresh Data Button */}
            <div className="mb-3">
              <div className="bg-gradient-to-r from-cyan-50 to-teal-50 border-2 border-cyan-400 rounded-xl p-3">
                <h3 className="text-base font-bold text-gray-800 mb-1">{`üîÑ ${t("settings.refreshData")}`}</h3>
                <p className="text-xs text-gray-600 mb-2">
                  {t("settings.refreshDescription")}
                </p>
                <button
                  onClick={refreshAllData}
                  disabled={isRefreshing}
                  className={`w-full py-2 px-3 rounded-lg font-bold text-sm flex items-center justify-center gap-2 transition ${
                    isRefreshing 
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                      : 'bg-cyan-500 text-white hover:bg-cyan-600 active:bg-cyan-700'
                  }`}
                >
                  <span className={isRefreshing ? 'animate-spin' : ''}>üîÑ</span>
                  <span>{isRefreshing ? t('general.refreshing') : t('settings.refreshData')}</span>
                </button>
                <div className="mt-2 text-[10px] text-gray-500 flex flex-wrap gap-1">
                  <span className="bg-cyan-100 px-1.5 py-0.5 rounded">{`üìç ${t("nav.myPlaces")}`}</span>
                  <span className="bg-cyan-100 px-1.5 py-0.5 rounded">{`üè∑Ô∏è ${t("general.interestsHeader")}`}</span>
                  <span className="bg-cyan-100 px-1.5 py-0.5 rounded">{`üíæ ${t("nav.saved")}`}</span>
                  <span className="bg-cyan-100 px-1.5 py-0.5 rounded">{`‚öôÔ∏è ${t("general.searchSettings")}`}</span>
                  <span className="bg-cyan-100 px-1.5 py-0.5 rounded">{`üëë ${t("general.permissions")}`}</span>
                </div>
              </div>
            </div>
            
            {/* Debug Mode Toggle */}
            <div className="mb-4">
              <div className="bg-gradient-to-r from-gray-50 to-slate-50 border-2 border-gray-400 rounded-xl p-3">
                <h3 className="text-base font-bold text-gray-800 mb-1">{t("general.debugMode")}</h3>
                <p className="text-xs text-gray-600 mb-2">
                  Show activity log for debugging
                </p>
                
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={debugMode}
                    onChange={(e) => setDebugMode(e.target.checked)}
                    className="w-5 h-5 rounded border-2 border-gray-400"
                  />
                  <span className="text-sm font-bold">
                    {debugMode ? t('toast.debugOn') : t('toast.debugOff')}
                  </span>
                </label>
                
                {debugMode && (
                  <div className="mt-2 text-xs text-gray-600">
                    Debug messages will appear in console (F12)
                  </div>
                )}
              </div>
            </div>
            
            {/* Import/Export Section */}
            
            {/* Admin Management - Password Based (Admin Only) */}
            {isCurrentUserAdmin && (
            <div className="mb-4">
              <div className="bg-gradient-to-r from-red-50 to-orange-50 border-2 border-red-400 rounded-xl p-3">
                <h3 className="text-base font-bold text-gray-800 mb-1">{t("general.adminManagement")}</h3>
                
                {/* Current Device Info */}
                <div className="text-xs bg-white rounded-lg p-2 border border-red-200 mb-3">
                  <strong>{t("general.currentDevice")}:</strong> {localStorage.getItem('bangkok_user_id')?.slice(-12) || 'N/A'}
                  <br />
                  <strong>{t("general.status")}:</strong> 
                  <span className="text-green-600 font-bold"> üîì {t("general.open")}</span>
                </div>
                
                {/* Password Section - Secure */}
                <div className="mb-3">
                  <label className="text-xs font-bold text-gray-700 block mb-1">üîë {adminPassword ? t('settings.changePassword') : t('settings.setNewPassword')}</label>
                  <div className="flex gap-2">
                    <input
                      type="password"
                      value={newAdminPassword}
                      onChange={(e) => setNewAdminPassword(e.target.value)}
                      placeholder={adminPassword ? t('settings.newPasswordPlaceholder') : t('settings.setPassword')}
                      className="flex-1 p-2 border rounded text-sm"
                    />
                    <button
                      onClick={async () => {
                        if (isFirebaseAvailable && database) {
                          try {
                            if (newAdminPassword.trim()) {
                              const hashed = await window.BKK.hashPassword(newAdminPassword.trim());
                              await database.ref('settings/adminPassword').set(hashed);
                              setAdminPassword(hashed);
                              showToast(t('toast.passwordSaved'), 'success');
                            } else {
                              await database.ref('settings/adminPassword').set('');
                              setAdminPassword('');
                              showToast(t('toast.passwordRemoved'), 'warning');
                            }
                            setNewAdminPassword('');
                          } catch (err) {
                            showToast(t('toast.saveError'), 'error');
                          }
                        }
                      }}
                      className="px-3 py-2 bg-green-500 text-white rounded text-sm font-bold"
                    >
                      {t("general.save")}
                    </button>
                  </div>
                  <p className="text-[10px] text-gray-500 mt-1">
                    {adminPassword ? t('settings.systemProtected') : t('settings.noPassword')}
                  </p>
                </div>
                
                {/* Admin Users List */}
                <div className="mb-3">
                  <label className="text-xs font-bold text-gray-700 block mb-1">{t("general.adminUsers")} ({adminUsers.length}):</label>
                  <div className="bg-white border rounded-lg max-h-32 overflow-y-auto">
                    {adminUsers.length === 0 ? (
                      <div className="p-2 text-xs text-gray-500 text-center">{t("general.noRegisteredUsers")}</div>
                    ) : (
                      adminUsers.map((user, idx) => (
                        <div key={user.userId} className="flex justify-between items-center p-2 border-b last:border-b-0 text-xs">
                          <div>
                            <span className="font-mono">{user.oderId?.slice(-12) || 'Unknown'}</span>
                            {user.oderId === localStorage.getItem('bangkok_user_id') && (
                              <span className="text-green-600 mr-1">({t("general.you")})</span>
                            )}
                            <br />
                            <span className="text-gray-500">{user.addedAt ? new Date(user.addedAt).toLocaleDateString('he-IL') : ''}</span>
                          </div>
                          <button
                            onClick={() => {
                              if (isFirebaseAvailable && database) {
                                database.ref(`settings/adminUsers/${user.oderId}`).remove()
                                  .then(() => showToast(t('toast.userRemoved'), 'success'))
                                  .catch(() => showToast(t('general.error'), 'error'));
                              }
                            }}
                            className="px-2 py-1 bg-red-500 text-white rounded text-[10px]"
                          >
                            {t("general.remove")}
                          </button>
                        </div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Access Log Button */}
                <button
                  onClick={() => {
                    markLogsAsSeen();
                    setShowAccessLog(true);
                  }}
                  className="w-full bg-blue-500 text-white py-2 rounded-lg font-bold text-sm hover:bg-blue-600 flex items-center justify-center gap-2"
                >
                  üìã View access log
                  {hasNewEntries && <span className="bg-red-600 text-white text-[10px] px-2 py-0.5 rounded-full">{t("general.new")}</span>}
                </button>
                
                {/* Feedback Viewer Button */}
                <button
                  onClick={() => {
                    markFeedbackAsSeen();
                    setShowFeedbackList(true);
                  }}
                  className="w-full bg-purple-500 text-white py-2 rounded-lg font-bold text-sm hover:bg-purple-600 flex items-center justify-center gap-2 mt-2"
                >
                  üí¨ Feedback ({feedbackList.length})
                  {hasNewFeedback && <span className="bg-red-600 text-white text-[10px] px-2 py-0.5 rounded-full">{t("general.new")}</span>}
                </button>
              </div>
            </div>
            )}
            
            <div className="mb-4">
              <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-400 rounded-xl p-3">
                <h3 className="text-base font-bold text-gray-800 mb-1">{t("general.importExport")}</h3>
                <p className="text-xs text-gray-600 mb-2">
                  Save and transfer data between devices
                </p>
                
                <div className="space-y-2">
                  {/* Export Button */}
                  <button
                    onClick={() => {
                      try {
                        // Count active interests
                        const activeCount = Object.values(interestStatus).filter(Boolean).length;
                        
                        const data = {
                          // Custom interests created by user
                          customInterests: customInterests,
                          // Custom locations
                          customLocations: customLocations,
                          // Saved routes
                          savedRoutes: savedRoutes,
                          // Interest search configurations (types, textSearch, blacklist)
                          interestConfig: interestConfig,
                          // Interest active/inactive status
                          interestStatus: interestStatus,
                          // Metadata
                          exportDate: new Date().toISOString(),
                          version: window.BKK.VERSION || '2.8'
                        };
                        
                        const dataStr = JSON.stringify(data, null, 2);
                        const dataBlob = new Blob([dataStr], { type: 'application/json' });
                        const url = URL.createObjectURL(dataBlob);
                        const link = document.createElement('a');
                        link.href = url;
                        const dateStr = new Date().toISOString().split('T')[0];
                        link.download = `bangkok-data-${dateStr}.json`;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        showToast(`${t("toast.fileDownloaded")} (${customInterests.length} ${t("interests.customCount")}, ${activeCount} ${t("interests.activeCount")}, ${customLocations.length} ${t("route.places")}◊™, ${savedRoutes.length} ◊û◊°◊ú◊ï◊ú◊ô◊ù)`, 'success');
                      } catch (error) {
                        console.error('[EXPORT] Error:', error);
                        showToast(t('toast.exportError'), 'error');
                      }
                    }}
                    className="w-full bg-blue-500 text-white py-2 px-3 rounded-lg font-bold hover:bg-blue-600 transition text-sm flex items-center justify-center gap-2"
                  >
                    <span>{t("general.exportAll")}</span>
                    <span className="text-xs bg-blue-600 px-2 py-0.5 rounded">
                      {customInterests.length + customLocations.length + savedRoutes.length}
                    </span>
                  </button>
                  
                  {/* Import Button */}
                  <div>
                    <input
                      type="file"
                      accept=".json"
                      onChange={(e) => {
                        const file = e.target.files?.[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                          try {
                            const data = JSON.parse(event.target.result);
                            
                            if (!data.customInterests && !data.customLocations && !data.savedRoutes) {
                              showToast(t('toast.invalidFileNoData'), 'error');
                              return;
                            }
                            
                            setImportedData(data);
                            setShowImportDialog(true);
                          } catch (error) {
                            console.error('[IMPORT] Error:', error);
                            showToast(t('toast.fileReadError'), 'error');
                          }
                        };
                        reader.readAsText(file);
                        e.target.value = '';
                      }}
                      id="importData"
                      className="hidden"
                    />
                    <label
                      htmlFor="importData"
                      className="block w-full bg-green-500 text-white py-2 px-3 rounded-lg font-bold hover:bg-green-600 transition text-sm text-center cursor-pointer"
                    >
                      üì• Import from file
                    </label>
                  </div>
                  
                  {/* Info Box */}
                  <div className="bg-blue-100 border border-blue-300 rounded-lg p-2 text-[10px]">
                    <p className="text-blue-900 font-bold mb-1">{`üí° ${t('general.uses')}:`}</p>
                    <ul className="text-blue-800 space-y-0.5 mr-3">
                      <li>{t("general.transferDevices")}</li>
                      <li>{t("general.dataBackup")}</li>
                      <li>{t("general.shareWithFriends")}</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
            
            </div>)}
            
          </div>
        )}

        {/* Footer */}
        <div className="text-center py-3 mt-4 border-t border-gray-200">
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', flexWrap: 'wrap' }}>
            <button
              onClick={() => {
                const shareData = { title: 'City Explorer', text: t('settings.appDescription'), url: window.location.href };
                if (navigator.share) { navigator.share(shareData).catch(() => {}); }
                else { try { navigator.clipboard.writeText(window.location.href); showToast(t('route.linkCopied'), 'success'); } catch(e) { showToast(window.location.href, 'info'); } }
              }}
              style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '10px', color: '#9ca3af' }}
            >{`üì§ ${t("general.share")}`}</button>
            <span style={{ color: '#d1d5db', fontSize: '9px' }}>¬∑</span>
            <span 
              style={{ fontSize: '9px', color: '#9ca3af', cursor: 'default', userSelect: 'none' }}
              onTouchStart={(e) => { e.currentTarget._lp = setTimeout(() => { if (isUnlocked) { setCurrentView('settings'); } else { setShowVersionPasswordDialog(true); } }, 2000); }}
              onTouchEnd={(e) => { clearTimeout(e.currentTarget._lp); }}
              onMouseDown={(e) => { e.currentTarget._lp = setTimeout(() => { if (isUnlocked) { setCurrentView('settings'); } else { setShowVersionPasswordDialog(true); } }, 2000); }}
              onMouseUp={(e) => { clearTimeout(e.currentTarget._lp); }}
              onMouseLeave={(e) => { clearTimeout(e.currentTarget._lp); }}
            >v{window.BKK.VERSION}</span>
            <span style={{ color: '#d1d5db', fontSize: '9px' }}>¬∑</span>
            <span style={{ fontSize: '9px', color: '#9ca3af' }}>¬© Eitan Fisher</span>
            <span style={{ color: '#d1d5db', fontSize: '9px' }}>¬∑</span>
            <button onClick={applyUpdate} style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '10px', color: '#9ca3af' }}>{`üîÑ ${t("general.refresh")}`}</button>
          </div>
        </div>

      {/* Floating Feedback Button */}
      {!showFeedbackDialog && (
        <button
          onClick={() => setShowFeedbackDialog(true)}
          className="fixed bottom-20 left-4 z-40 bg-white text-gray-400 hover:text-blue-500 hover:shadow-lg w-10 h-10 rounded-full shadow-md border border-gray-200 flex items-center justify-center transition-all duration-300 text-lg"
          title={t("settings.sendFeedback")}
        >
          üí¨
        </button>
      )}

      {/* Leaflet Map Modal */}
      {showMapModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-3" style={{ backgroundColor: 'rgba(0,0,0,0.5)' }}>
          <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl" style={{ maxHeight: '90vh', display: 'flex', flexDirection: 'column' }}>
            {/* Header */}
            <div className="flex items-center justify-between p-3 border-b">
              <button
                onClick={() => setShowMapModal(false)}
                className="text-gray-400 hover:text-gray-600 text-lg font-bold"
              >‚úï</button>
              <div className="flex items-center gap-2">
                <h3 className="font-bold text-sm">
                  {mapMode === 'areas' ? t('wizard.allAreasMap') : t('form.searchRadius')}
                </h3>
              </div>
              <div className="flex bg-gray-100 rounded-lg p-1 gap-1">
                <button
                  onClick={() => setMapMode('areas')}
                  className={`flex-1 px-3 py-1.5 rounded-lg text-xs font-bold transition ${
                    mapMode === 'areas' ? 'bg-blue-500 text-white shadow' : 'text-gray-500 hover:bg-gray-200'
                  }`}
                >{t("general.areas")}</button>
                <button
                  onClick={() => {
                    if (!formData.currentLat) {
                      showToast(t('form.useGpsForRadius'), 'warning');
                      return;
                    }
                    setMapMode('radius');
                  }}
                  className={`flex-1 px-3 py-1.5 rounded-lg text-xs font-bold transition ${
                    mapMode === 'radius' ? 'bg-rose-500 text-white shadow' : 'text-gray-500 hover:bg-gray-200'
                  } ${!formData.currentLat ? 'opacity-30' : ''}`}
                  title={!formData.currentLat ? t('form.needGpsFirst') : t('form.showSearchRadius')}
                >{`üìç ${t("form.radiusMode")}`}</button>
              </div>
            </div>
            {/* Map Container */}
            <div id="leaflet-map-container" style={{ flex: 1, minHeight: '350px', maxHeight: '70vh' }}></div>
            {/* Footer */}
            <div className="p-2 border-t text-center">
              <p className="text-[9px] text-gray-400">
                {mapMode === 'areas' 
                  ? `${(window.BKK.areaOptions || []).length} ${t('general.areas')}` 
                  : `${formData.radiusMeters}m - ${formData.radiusPlaceName || t('form.currentLocation')}`
                }
              </p>
            </div>
          </div>
        </div>
      )}

        {/* === DIALOGS (from dialogs.js) === */}


        {/* Add/Edit Location Dialog - REDESIGNED */}
        {(showAddLocationDialog || showEditLocationDialog) && (
          <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-2">
            <div className="bg-white rounded-xl w-full max-w-2xl max-h-[95vh] flex flex-col shadow-2xl">
              
              {/* Header - Compact */}
              <div className="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-4 py-2.5 rounded-t-xl flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <h3 className="text-base font-bold">
                    {showEditLocationDialog ? t('places.editPlace') : t('places.addPlace')}
                  </h3>
                  <button
                    onClick={() => showHelpFor('addLocation')}
                    className="bg-white text-purple-600 hover:bg-purple-100 rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold shadow"
                    title={t("general.help")}
                  >
                    ?
                  </button>
                </div>
                <button
                  onClick={() => {
                    setShowAddLocationDialog(false);
                    setShowEditLocationDialog(false);
                    setEditingLocation(null);
                    setNewLocation({ 
                      name: '', description: '', notes: '', area: formData.area, interests: [], 
                      lat: null, lng: null, mapsUrl: '', address: '', uploadedImage: null, imageUrls: [], inProgress: true
                    });
                  }}
                  className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
                >
                  ‚úï
                </button>
              </div>
              
              {/* Content - Scrollable - COMPACT */}
              <div className="flex-1 overflow-y-auto px-4 py-3 space-y-2.5">
                <div style={{ position: 'relative' }}>
                {showEditLocationDialog && editingLocation?.locked && !isUnlocked && (
                  <div style={{ position: 'absolute', inset: 0, zIndex: 10, backgroundColor: 'rgba(255,255,255,0.3)', pointerEvents: 'all' }} 
                    onClick={(e) => { e.preventDefault(); e.stopPropagation(); document.activeElement?.blur(); }}
                    onTouchStart={(e) => { e.preventDefault(); e.stopPropagation(); document.activeElement?.blur(); }}
                  />
                )}
                
                {/* Row 1: Name + Area */}
                <div className="space-y-2">
                  {/* Name - full width with search */}
                  <div>
                    <label className="block text-xs font-bold mb-1">
                      Name <span className="text-red-500">*</span>
                    </label>
                    <div style={{ display: 'flex', gap: '4px' }}>
                      <input
                        type="text"
                        value={newLocation.name}
                        readOnly={showEditLocationDialog && editingLocation?.locked && !isUnlocked}
                        onFocus={(e) => { if (showEditLocationDialog && editingLocation?.locked && !isUnlocked) e.target.blur(); }}
                        onChange={(e) => {
                          setNewLocation({...newLocation, name: e.target.value});
                          setLocationSearchResults(null);
                          if (e.target.value.trim()) {
                            const exists = customLocations.find(loc => 
                              loc.name.toLowerCase() === e.target.value.trim().toLowerCase() &&
                              (!editingLocation || loc.id !== editingLocation.id)
                            );
                            if (exists) showToast(t('places.nameExists'), 'warning');
                          }
                        }}
                        onKeyDown={(e) => { if (e.key === 'Enter' && newLocation.name?.trim()) { e.preventDefault(); searchPlacesByName(newLocation.name); } }}
                        placeholder={t("places.placeName")}
                        className="flex-1 p-2 text-sm border-2 border-purple-300 rounded-lg focus:border-purple-500"
                        style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                        autoFocus={!showEditLocationDialog}
                      />
                      <button
                        onClick={() => searchPlacesByName(newLocation.name)}
                        disabled={!newLocation.name?.trim()}
                        style={{
                          padding: '6px 10px', borderRadius: '8px', border: 'none', cursor: newLocation.name?.trim() ? 'pointer' : 'not-allowed',
                          background: newLocation.name?.trim() ? 'linear-gradient(135deg, #8b5cf6, #7c3aed)' : '#d1d5db', color: 'white', fontSize: '16px'
                        }}
                        title={t("form.searchPlaceGoogle")}
                      >üîç</button>
                    </div>
                    {/* Search Results Dropdown */}
                    {locationSearchResults !== null && (
                      <div style={{ marginTop: '4px', border: '1px solid #e5e7eb', borderRadius: '8px', maxHeight: '150px', overflowY: 'auto', background: 'white' }}>
                        {locationSearchResults.length === 0 ? (
                          <p style={{ textAlign: 'center', padding: '8px', color: '#9ca3af', fontSize: '11px' }}>{t("general.searching")}...</p>
                        ) : locationSearchResults.map((result, idx) => (
                          <button
                            key={idx}
                            onClick={() => {
                              setNewLocation({
                                ...newLocation,
                                name: result.name,
                                lat: result.lat, lng: result.lng,
                                address: result.address,
                                mapsUrl: `https://maps.google.com/?q=${result.lat},${result.lng}`,
                                googlePlaceId: result.googlePlaceId
                              });
                              setLocationSearchResults(null);
                              showToast(`‚úÖ ${result.name} ${t("toast.selectedPlace")}`, 'success');
                            }}
                            style={{ width: '100%', textAlign: window.BKK.i18n.isRTL() ? 'right' : 'left', padding: '6px 10px', borderBottom: '1px solid #f3f4f6', cursor: 'pointer', background: 'none', border: 'none', direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                            onMouseEnter={(e) => e.target.style.background = '#f3f4f6'}
                            onMouseLeave={(e) => e.target.style.background = 'none'}
                          >
                            <div style={{ fontSize: '12px', fontWeight: 'bold', color: '#1f2937' }}>{result.name}</div>
                            <div style={{ fontSize: '10px', color: '#6b7280' }}>{result.address}{result.rating ? ` ‚≠ê ${result.rating}` : ''}</div>
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                  
                  {/* Areas - full width multi-select */}
                  <div>
                    <div className="flex items-center justify-between mb-1">
                      <button
                        onClick={() => {
                          const lat = newLocation.lat;
                          const lng = newLocation.lng;
                          if (lat && lng) {
                            const detected = window.BKK.getAreasForCoordinates(lat, lng);
                            if (detected.length > 0) {
                              setNewLocation({...newLocation, areas: detected, area: detected[0]});
                              showToast(`${detected.length} ${t("toast.detectedAreas")}`, 'success');
                            } else {
                              showToast(t('places.locationNotInAnyArea'), 'warning');
                            }
                          } else {
                            showToast(t('places.needCoordsForAreas'), 'warning');
                          }
                        }}
                        className="text-[9px] px-2 py-0.5 bg-blue-100 text-blue-600 rounded hover:bg-blue-200 font-bold"
                      >{`üìç Auto-detect`}</button>
                      <label className="text-xs font-bold">{t("general.areas")}</label>
                    </div>
                    <div className="grid grid-cols-6 gap-1 p-1.5 bg-gray-50 rounded-lg overflow-y-auto border-2 border-gray-300" style={{ maxHeight: '120px' }}>
                      {areaOptions.map(area => {
                        const isSelected = (newLocation.areas || [newLocation.area]).includes(area.id);
                        return (
                          <button
                            key={area.id}
                            onClick={() => {
                              const current = newLocation.areas || (newLocation.area ? [newLocation.area] : []);
                              const updated = current.includes(area.id)
                                ? current.filter(a => a !== area.id)
                                : [...current, area.id];
                              if (updated.length === 0) return;
                              setNewLocation({...newLocation, areas: updated, area: updated[0]});
                            }}
                            className={`p-1 rounded text-[8px] font-bold transition-all text-center ${
                              isSelected
                                ? 'bg-purple-500 text-white shadow-md'
                                : 'bg-white text-gray-500 hover:bg-gray-100'
                            }`}
                            style={{ lineHeight: '1.1' }}
                          >
                            <div>{tLabel(area)}</div>
                          </button>
                        );
                      })}
                    </div>
                  </div>
                </div>

                {/* Interests - Compact Grid */}
                <div>
                  <label className="block text-xs font-bold mb-1">{t("general.interestsHeader")}</label>
                  <div className="grid grid-cols-6 gap-1.5 p-2 bg-gray-50 rounded-lg max-h-32 overflow-y-auto">
                    {allInterestOptions.map(option => (
                      <button
                        key={option.id}
                        onClick={() => {
                          const current = newLocation.interests || [];
                          setNewLocation({
                            ...newLocation,
                            interests: current.includes(option.id)
                              ? current.filter(i => i !== option.id)
                              : [...current, option.id]
                          });
                        }}
                        className={`p-1.5 rounded-lg text-[10px] font-bold transition-all ${
                          (newLocation.interests || []).includes(option.id)
                            ? 'bg-purple-500 text-white shadow-md'
                            : 'bg-white border border-gray-300 hover:border-purple-300'
                        }`}
                        title={tLabel(option)}
                      >
                        <span className="text-lg block">{option.icon?.startsWith?.('data:') ? <img src={option.icon} alt="" className="w-5 h-5 object-contain mx-auto" /> : option.icon}</span>
                        <span className="text-[7px] block truncate leading-tight mt-0.5">{tLabel(option)}</span>
                      </button>
                    ))}
                  </div>
                </div>

                {/* Description - NEW */}
                <div>
                  <label className="block text-xs font-bold mb-1">{`üìù ${t("places.description")}`}</label>
                  <input
                    type="text"
                    value={newLocation.description || ''}
                    onChange={(e) => setNewLocation({...newLocation, description: e.target.value})}
                    placeholder={t("places.description")}
                    className="w-full p-2 text-sm border-2 border-gray-300 rounded-lg focus:border-purple-500"
                    style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                  />
                </div>

                {/* Image - Compact */}
                <div>
                  <label className="block text-xs font-bold mb-1">{`üì∑ ${t("general.image")}`}</label>
                  {newLocation.uploadedImage ? (
                    <div className="relative">
                      <img 
                        src={newLocation.uploadedImage} 
                        alt="Preview"
                        className="w-full h-48 object-cover rounded-lg border-2 border-purple-300 cursor-pointer hover:opacity-90"
                        onClick={() => {
                          setModalImage(newLocation.uploadedImage);
                          setShowImageModal(true);
                        }}
                      />
                      {!(showEditLocationDialog && editingLocation?.locked && !isUnlocked) && (
                      <button
                        onClick={() => setNewLocation({...newLocation, uploadedImage: null})}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs font-bold hover:bg-red-600"
                      >
                        ‚úï
                      </button>
                      )}
                    </div>
                  ) : (
                    <label className="block w-full p-3 border-2 border-dashed border-purple-300 rounded-lg text-center cursor-pointer hover:bg-purple-50">
                      <span className="text-2xl">üì∏</span>
                      <div className="text-xs text-gray-600 mt-1">{t("general.clickToUpload")}</div>
                      <input
                        type="file"
                        accept="image/*"
                        onChange={(e) => {
                          const file = e.target.files?.[0];
                          if (file) {
                            const reader = new FileReader();
                            reader.onload = () => setNewLocation({...newLocation, uploadedImage: reader.result});
                            reader.readAsDataURL(file);
                          }
                        }}
                        className="hidden"
                      />
                    </label>
                  )}
                </div>

                {/* Links - Compact */}
                <div>
                  <label className="block text-xs font-bold mb-1">{`üîó ${t("general.links")}`}</label>
                  <div className="space-y-1">
                    {(newLocation.imageUrls || []).map((url, idx) => (
                      <div key={idx} className="flex gap-1">
                        <input
                          type="text"
                          value={url}
                          onChange={(e) => {
                            const updated = [...(newLocation.imageUrls || [])];
                            updated[idx] = e.target.value;
                            setNewLocation({...newLocation, imageUrls: updated});
                          }}
                          placeholder="https://..."
                          className="flex-1 p-1.5 text-xs border border-gray-300 rounded-lg"
                        />
                        <button
                          onClick={() => {
                            const updated = (newLocation.imageUrls || []).filter((_, i) => i !== idx);
                            setNewLocation({...newLocation, imageUrls: updated});
                          }}
                          className="px-2 py-1 bg-red-500 text-white rounded-lg text-xs font-bold hover:bg-red-600"
                        >
                          ‚úï
                        </button>
                      </div>
                    ))}
                    <button
                      onClick={() => setNewLocation({...newLocation, imageUrls: [...(newLocation.imageUrls || []), '']})}
                      className="w-full p-1.5 border border-dashed border-gray-300 rounded-lg text-xs text-gray-600 hover:bg-gray-50"
                    >
                      {`+ ${t("general.link")}`}
                    </button>
                  </div>
                </div>

                {/* Row 2: Address + Maps Link */}
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="block text-xs font-bold mb-1">{`üè† ${t("places.address")}`}</label>
                    <input
                      type="text"
                      value={newLocation.address || ''}
                      onChange={(e) => setNewLocation({...newLocation, address: e.target.value})}
                      placeholder={t("places.address")}
                      className="w-full p-1.5 text-xs border border-gray-300 rounded-lg focus:border-purple-500"
                      style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                    />
                  </div>
                  <div>
                    <label className="block text-xs font-bold mb-1">{`üîó ${t("general.mapsLink")}`}</label>
                    <input
                      type="text"
                      value={newLocation.mapsUrl || ''}
                      onChange={(e) => {
                        setNewLocation({...newLocation, mapsUrl: e.target.value});
                        parseMapsUrl(e.target.value);
                      }}
                      placeholder="Google Maps URL"
                      className="w-full p-1.5 text-xs border border-gray-300 rounded-lg focus:border-purple-500"
                    />
                  </div>
                </div>

                {/* Coordinates - SUPER COMPACT */}
                <div className="bg-blue-50 border border-blue-300 rounded-lg p-2">
                  <label className="block text-xs font-bold mb-1.5">{`üìç ${t("general.coordinates")}`}</label>
                  
                  {/* Lat/Lng Inputs */}
                  <div className="grid grid-cols-2 gap-1.5 mb-1.5">
                    <input
                      type="number"
                      step="0.000001"
                      value={newLocation.lat || ''}
                      onChange={(e) => setNewLocation({...newLocation, lat: parseFloat(e.target.value) || null})}
                      placeholder="Lat"
                      className="w-full p-1.5 text-xs border border-gray-300 rounded-lg"
                    />
                    <input
                      type="number"
                      step="0.000001"
                      value={newLocation.lng || ''}
                      onChange={(e) => setNewLocation({...newLocation, lng: parseFloat(e.target.value) || null})}
                      placeholder="Lng"
                      className="w-full p-1.5 text-xs border border-gray-300 rounded-lg"
                    />
                  </div>

                  {/* Calculate Buttons - Row with labels */}
                  <div className="grid grid-cols-5 gap-1">
                    <button
                      onClick={() => geocodeByName(newLocation.name)}
                      disabled={!newLocation.name?.trim()}
                      className={`p-1.5 rounded-lg text-[9px] font-bold flex flex-col items-center ${
                        newLocation.name?.trim()
                          ? 'bg-indigo-500 text-white hover:bg-indigo-600'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                      title={t("form.searchByName")}
                    >
                      <span className="text-sm">üî§</span>
                      <span>{t("general.name")}</span>
                    </button>
                    <button
                      onClick={() => geocodeAddress(newLocation.address)}
                      disabled={!newLocation.address?.trim()}
                      className={`p-1.5 rounded-lg text-[9px] font-bold flex flex-col items-center ${
                        newLocation.address?.trim()
                          ? 'bg-purple-500 text-white hover:bg-purple-600'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                      title={t("form.searchByAddress")}
                    >
                      <span className="text-sm">üè†</span>
                      <span>{t("places.address")}</span>
                    </button>
                    <button
                      onClick={() => parseMapsUrl(newLocation.mapsUrl)}
                      disabled={!newLocation.mapsUrl?.trim()}
                      className={`p-1.5 rounded-lg text-[9px] font-bold flex flex-col items-center ${
                        newLocation.mapsUrl?.trim()
                          ? 'bg-blue-500 text-white hover:bg-blue-600'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                      title={t("form.extractFromLink")}
                    >
                      <span className="text-sm">üîó</span>
                      <span>{t("general.link")}</span>
                    </button>
                    <button
                      onClick={getCurrentLocation}
                      className="p-1.5 rounded-lg text-[9px] font-bold bg-green-500 text-white hover:bg-green-600 flex flex-col items-center"
                      title={t("form.gps")}
                    >
                      <span className="text-sm">üìç</span>
                      <span>{t("general.location")}</span>
                    </button>
                  </div>
                </div>

                {/* Open in Google + Google Info */}
                <div className="bg-indigo-50 border border-indigo-200 rounded-lg p-2" style={{ position: 'relative', zIndex: 15 }}>
                  <div className="flex gap-2">
                    {newLocation.lat && newLocation.lng ? (
                      <a
                        href={window.BKK.getGoogleMapsUrl(newLocation)}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="flex-1 py-2 bg-green-500 text-white rounded-lg text-sm font-bold hover:bg-green-600 text-center"
                      >
                        {t("general.openInGoogle")}
                      </a>
                    ) : (
                      <button disabled className="flex-1 py-2 bg-gray-300 text-gray-500 rounded-lg text-sm font-bold cursor-not-allowed">
                        üó∫Ô∏è {t("general.openInGoogleNoCoords")}
                      </button>
                    )}
                    <button
                      onClick={() => {
                        setGooglePlaceInfo(null);
                        fetchGooglePlaceInfo(newLocation);
                      }}
                      disabled={!newLocation.name?.trim() || loadingGoogleInfo}
                      className={`flex-1 py-2 rounded-lg text-sm font-bold ${
                        newLocation.name?.trim() && !loadingGoogleInfo
                          ? 'bg-indigo-500 text-white hover:bg-indigo-600'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                    >
                      {loadingGoogleInfo ? t('general.loading') : t('places.googleInfo')}
                    </button>
                  </div>
                  
                  {/* Google Place Info Results */}
                  {googlePlaceInfo && !googlePlaceInfo.notFound && (
                    <div className="mt-2 text-xs space-y-1 bg-white rounded p-2 border border-indigo-200" style={{ direction: 'ltr' }}>
                      <div>
                        <span className="font-bold text-indigo-700">Found:</span>
                        <span className="ml-1">{googlePlaceInfo.name}</span>
                      </div>
                      <div>
                        <span className="font-bold text-indigo-700">Primary Type:</span>
                        <span className="ml-1 bg-indigo-200 px-2 py-0.5 rounded">
                          {googlePlaceInfo.primaryTypeDisplayName || googlePlaceInfo.primaryType || 'N/A'}
                        </span>
                      </div>
                      <div>
                        <span className="font-bold text-indigo-700">All Types:</span>
                        <div className="flex flex-wrap gap-1 mt-1">
                          {googlePlaceInfo.types.map((type, idx) => (
                            <span key={idx} className="bg-gray-200 px-2 py-0.5 rounded text-[10px]">{type}</span>
                          ))}
                        </div>
                      </div>
                      <div>
                        <span className="font-bold text-indigo-700">Rating:</span>
                        <span className="ml-1">‚≠ê {googlePlaceInfo.rating?.toFixed(1) || 'N/A'} ({googlePlaceInfo.ratingCount || 0})</span>
                      </div>
                    </div>
                  )}
                  
                  {googlePlaceInfo && googlePlaceInfo.notFound && (
                    <div className="mt-2 text-xs text-red-600 bg-white rounded p-2 border border-red-200">
                      ‚ùå Place not found on Google for: "{googlePlaceInfo.searchQuery}"
                    </div>
                  )}
                </div>

                {/* Notes - Compact */}
                <div>
                  <label className="block text-xs font-bold mb-1">{`üí≠ ${t("places.notes")}`}</label>
                  <textarea
                    value={newLocation.notes || ''}
                    onChange={(e) => setNewLocation({...newLocation, notes: e.target.value})}
                    placeholder={t("places.notes")}
                    className="w-full p-2 text-xs border border-gray-300 rounded-lg focus:border-purple-500"
                    style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr', minHeight: '50px' }}
                    rows="2"
                  />
                </div>
                </div>{/* close inner wrapper */}

                {/* Status toggles - only show if not locked for non-admin */}
                {!(showEditLocationDialog && editingLocation?.locked && !isUnlocked) && (
                <div className="flex gap-3 px-4 py-2 bg-gray-50 border-t border-gray-100">
                  <button type="button"
                    onClick={() => setNewLocation({...newLocation, inProgress: !newLocation.inProgress})}
                    className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${newLocation.inProgress ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                  >
                    {newLocation.inProgress ? '‚è≥' : '‚óã'} {t("general.inProgress")}
                  </button>
                  {isUnlocked && (
                    <button type="button"
                      onClick={() => setNewLocation({...newLocation, locked: !newLocation.locked})}
                      className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${newLocation.locked ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                    >
                      {newLocation.locked ? 'üîí' : '‚óã'} {t("general.locked")}
                    </button>
                  )}
                </div>
                )}

                {/* Actions: Skip permanently + Delete (edit mode only) - hidden for locked non-admin */}
                {showEditLocationDialog && editingLocation && !(editingLocation.locked && !isUnlocked) && (
                  <div className="border-t border-red-200 bg-red-50 px-4 py-2">
                    <div className="flex gap-2">
                      {editingLocation.status === 'blacklist' ? (
                        <button
                          onClick={() => {
                            const loc = customLocations.find(l => l.id === editingLocation.id);
                            if (loc && isFirebaseAvailable && database) {
                              database.ref(`customLocations/${loc.firebaseId || loc.id}`).update({ inProgress: true });
                            }
                            toggleLocationStatus(editingLocation.id);
                            setShowEditLocationDialog(false);
                            setEditingLocation(null);
                          }}
                          className="flex-1 py-2 bg-green-500 text-white rounded-lg text-sm font-bold hover:bg-green-600"
                        >
                          ‚úÖ {t("general.restoreActive")}
                        </button>
                      ) : (
                        <button
                          onClick={() => {
                            toggleLocationStatus(editingLocation.id);
                            setShowEditLocationDialog(false);
                            setEditingLocation(null);
                          }}
                          className="flex-1 py-2 bg-blue-500 text-white rounded-lg text-sm font-bold hover:bg-blue-600"
                        >
                          üö´ {t('route.skipPermanently')}
                        </button>
                      )}
                      <button
                        onClick={() => {
                          showConfirm(`Delete "${editingLocation.name}"?`, () => {
                            deleteCustomLocation(editingLocation.id);
                            setShowEditLocationDialog(false);
                            setEditingLocation(null);
                          });
                        }}
                        className="flex-1 py-2 bg-red-600 text-white rounded-lg text-sm font-bold hover:bg-red-700"
                      >
                        üóëÔ∏è {t("general.deletePlace")}
                      </button>
                    </div>
                  </div>
                )}

              </div>
              
              {/* Footer */}
              {(() => {
                const isLockedPlace = showEditLocationDialog && editingLocation?.locked && !isUnlocked;
                return (
              <div className="px-4 py-2.5 border-t border-gray-200 flex gap-2" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}>
                {isLockedPlace ? (
                  <>
                    <div className="flex-1 py-2.5 px-3 bg-yellow-100 text-yellow-800 rounded-lg text-xs font-bold text-center flex items-center justify-center gap-1">
                      üîí {t("general.readOnly")}
                    </div>
                  </>
                ) : (
                <button
                  onClick={() => {
                    if (!newLocation.name || !newLocation.name.trim()) {
                      showToast(t('places.enterPlaceName'), 'warning');
                      return;
                    }
                    if (!newLocation.interests || newLocation.interests.length === 0) {
                      showToast(t('form.selectAtLeastOneInterest'), 'warning');
                      return;
                    }
                    const exists = customLocations.find(loc => 
                      loc.name.toLowerCase() === newLocation.name.trim().toLowerCase() &&
                      (!editingLocation || loc.id !== editingLocation.id)
                    );
                    if (exists) {
                      showToast(t('places.placeExists'), 'error');
                      return;
                    }
                    if (showEditLocationDialog) {
                      updateCustomLocation(false);
                    } else {
                      addCustomLocation(false);
                    }
                  }}
                  disabled={!newLocation.name?.trim()}
                  className={`flex-1 py-2.5 rounded-lg text-sm font-bold transition-all ${
                    newLocation.name?.trim()
                      ? 'bg-purple-500 text-white hover:bg-purple-600'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  {showEditLocationDialog ? t('general.update') : t('general.add')}
                </button>
                )}
                <button
                  onClick={() => {
                    setShowAddLocationDialog(false);
                    setShowEditLocationDialog(false);
                    setEditingLocation(null);
                    setNewLocation({ 
                      name: '', description: '', notes: '', area: formData.area, areas: [formData.area], interests: [], 
                      lat: null, lng: null, mapsUrl: '', address: '', uploadedImage: null, imageUrls: [], inProgress: true
                    });
                  }}
                  className="px-5 py-2.5 rounded-lg bg-green-500 text-white text-sm font-bold hover:bg-green-600"
                >
                  {`‚úì ${t("general.close")}`}
                </button>
              </div>
                );
              })()}

            </div>
          </div>
        )}

        {/* Unified Interest Dialog - Add / Edit / Config */}
        {showAddInterestDialog && (
          <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-2">
            <div className="bg-white rounded-xl w-full max-w-md max-h-[90vh] flex flex-col shadow-2xl">
              
              {/* Header */}
              <div className="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-4 py-2.5 rounded-t-xl flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <h3 className="text-base font-bold">{editingCustomInterest ? `${newInterest.icon?.startsWith?.('data:') ? '' : newInterest.icon} ${newInterest.label}` : t('interests.addInterest')}</h3>
                  {editingCustomInterest && (
                    <span className={`text-[10px] px-2 py-0.5 rounded-full font-bold ${newInterest.builtIn ? 'bg-blue-200 text-blue-800' : 'bg-purple-200 text-purple-800'}`}>
                      {newInterest.builtIn ? t('general.system') : t('general.private')}
                    </span>
                  )}
                  {!editingCustomInterest && (
                    <span className="text-[10px] bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full font-bold">{t("general.private")}</span>
                  )}
                  <button
                    onClick={() => showHelpFor('addInterest')}
                    className="bg-white text-purple-600 hover:bg-purple-100 rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold shadow"
                    title={t("general.help")}
                  >?</button>
                </div>
                <button
                  onClick={() => {
                    setShowAddInterestDialog(false);
                    setNewInterest({ label: '', icon: 'üìç', searchMode: 'types', types: '', textSearch: '', blacklist: '', privateOnly: false, inProgress: false, locked: false });
                    setEditingCustomInterest(null);
                  }}
                  className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
                >‚úï</button>
              </div>
              
              {/* Content */}
              <div className="flex-1 overflow-y-auto px-4 py-3 space-y-3">
                <div style={{ position: 'relative' }}>
                {editingCustomInterest?.locked && !isUnlocked && (
                  <div style={{ position: 'absolute', inset: 0, zIndex: 10, backgroundColor: 'rgba(255,255,255,0.3)' }} />
                )}
                {/* Name + Icon row */}
                <div className="grid grid-cols-4 gap-2">
                  <div className="col-span-3">
                    <label className="block text-xs font-bold mb-1">{t("interests.interestName")} <span className="text-red-500">*</span></label>
                    <input
                      type="text"
                      value={newInterest.label}
                      onChange={(e) => setNewInterest({...newInterest, label: e.target.value})}
                      placeholder={t("interests.exampleTypes")}
                      className="w-full p-2 text-sm border-2 border-purple-300 rounded-lg focus:border-purple-500"
                      style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                      disabled={newInterest.builtIn && !isUnlocked}
                      autoFocus={!newInterest.builtIn}
                    />
                  </div>
                  <div>
                    <label className="block text-xs font-bold mb-1">{t("general.icon")}</label>
                    {newInterest.icon && newInterest.icon.startsWith('data:') ? (
                      <div className="relative">
                        <img src={newInterest.icon} alt="icon" className="w-full h-10 object-contain rounded-lg border-2 border-gray-300 bg-white" />
                        <button
                          onClick={() => setNewInterest({...newInterest, icon: 'üìç'})}
                          className="absolute -top-1 -right-1 bg-gray-600 text-white rounded-full w-3.5 h-3.5 text-[8px] font-bold flex items-center justify-center leading-none"
                        >‚úï</button>
                      </div>
                    ) : (
                      <input
                        type="text"
                        value={newInterest.icon}
                        onChange={(e) => {
                          const firstEmoji = [...e.target.value][0] || '';
                          setNewInterest({...newInterest, icon: firstEmoji});
                        }}
                        placeholder="üìç"
                        className="w-full p-2 text-xl border-2 border-gray-300 rounded-lg text-center"
                        disabled={newInterest.builtIn && !isUnlocked}
                      />
                    )}
                    {(!newInterest.builtIn || isUnlocked) && (
                      <label className="block w-full mt-1 p-1 border border-dashed border-gray-300 rounded text-center cursor-pointer hover:bg-gray-50 text-[9px] text-gray-500">
                        üìÅ File
                        <input
                          type="file"
                          accept="image/*"
                          onChange={(e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                              const reader = new FileReader();
                              reader.onload = () => setNewInterest({...newInterest, icon: reader.result});
                              reader.readAsDataURL(file);
                            }
                          }}
                          className="hidden"
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Search Configuration */}
                <div className="bg-blue-50 border-2 border-blue-200 rounded-lg p-3">
                  <label className="block text-xs font-bold mb-2 text-blue-800">{`üîç ${t("general.searchSettings")}`}</label>
                  
                  <div className="mb-2">
                    <label className="block text-[10px] text-gray-600 mb-1" style={{ direction: 'ltr' }}>{`${t("general.searchMode")}:`}</label>
                    <select
                      value={newInterest.searchMode || 'types'}
                      onChange={(e) => setNewInterest({...newInterest, searchMode: e.target.value})}
                      className="w-full p-1.5 text-sm border rounded"
                      style={{ direction: 'ltr' }}
                    >
                      <option value="types">{t('interests.categorySearch')}</option>
                      <option value="text">{t('interests.textSearch')}</option>
                    </select>
                  </div>
                  
                  {newInterest.searchMode === 'text' ? (
                    <div className="mb-2">
                      <label className="block text-[10px] text-gray-600 mb-1" style={{ direction: 'ltr' }}>{`${t('interests.textQuery')}:`}</label>
                      <input
                        type="text"
                        value={newInterest.textSearch || ''}
                        onChange={(e) => setNewInterest({...newInterest, textSearch: e.target.value})}
                        placeholder="e.g., street art"
                        className="w-full p-1.5 text-sm border rounded"
                        style={{ direction: 'ltr' }}
                      />
                      <p className="text-[9px] text-gray-500 mt-0.5" style={{ direction: 'ltr' }}>
                        Searches: "[query] [area] {window.BKK.cityNameForSearch || 'City'}"
                      </p>
                    </div>
                  ) : (
                    <div className="mb-2">
                      <label className="block text-[10px] text-gray-600 mb-1" style={{ direction: 'ltr' }}>{`${t('interests.placeTypes')}:`}</label>
                      <input
                        type="text"
                        value={newInterest.types || ''}
                        onChange={(e) => setNewInterest({...newInterest, types: e.target.value})}
                        placeholder="e.g., movie_theater, museum"
                        className="w-full p-1.5 text-sm border rounded"
                        style={{ direction: 'ltr' }}
                      />
                      <p className="text-[9px] text-gray-500 mt-0.5" style={{ direction: 'ltr' }}>
                        <a href="https://developers.google.com/maps/documentation/places/web-service/place-types" target="_blank" className="text-blue-500 underline">{t('interests.seeTypesList')}</a>
                      </p>
                    </div>
                  )}
                  
                  <div>
                    <label className="block text-[10px] text-gray-600 mb-1" style={{ direction: 'ltr' }}>{`${t('interests.blacklistWords')}:`}</label>
                    <input
                      type="text"
                      value={newInterest.blacklist || ''}
                      onChange={(e) => setNewInterest({...newInterest, blacklist: e.target.value})}
                      placeholder="e.g., cannabis, massage"
                      className="w-full p-1.5 text-sm border rounded"
                      style={{ direction: 'ltr' }}
                    />
                  </div>
                  
                  {/* Private Only toggle - only for custom interests */}
                  {!newInterest.builtIn && (
                  <div className="mt-2 pt-2 border-t border-blue-200">
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="checkbox"
                        checked={newInterest.privateOnly || false}
                        onChange={(e) => setNewInterest({...newInterest, privateOnly: e.target.checked})}
                        className="rounded" style={{ accentColor: "#7c3aed", width: "16px", height: "16px" }}
                      />
                      <span className="text-xs font-bold text-blue-800">{`üîí ${t("interests.privateInterest")}`}</span>
                      <span className="text-[9px] text-gray-500">{`‚Äî ${t("interests.myPlacesOnly")}`}</span>
                    </label>
                  </div>
                  )}
                </div>
                </div>{/* close inner wrapper */}

                {/* Status toggles - hidden for locked non-admin */}
                {!(editingCustomInterest?.locked && !isUnlocked) && (
                <div className="flex gap-3 px-4 py-2 bg-gray-50 border-t border-gray-100">
                  <button type="button"
                    onClick={() => setNewInterest({...newInterest, inProgress: !newInterest.inProgress})}
                    className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${newInterest.inProgress ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                  >
                    {newInterest.inProgress ? '‚è≥' : '‚óã'} {t("general.inProgress")}
                  </button>
                  {isUnlocked && (
                    <button type="button"
                      onClick={() => setNewInterest({...newInterest, locked: !newInterest.locked})}
                      className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${newInterest.locked ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                    >
                      {newInterest.locked ? 'üîí' : '‚óã'} {t("general.locked")}
                    </button>
                  )}
                </div>
                )}

                {/* Actions: Enable/Disable + Delete (edit mode only) - hidden for locked non-admin */}
                {editingCustomInterest && !(editingCustomInterest.locked && !isUnlocked) && (
                  <div className="border-t border-red-200 bg-red-50 px-4 py-2">
                    <div className="flex gap-2">
                      <button
                        onClick={() => {
                          toggleInterestStatus(editingCustomInterest.id);
                          setShowAddInterestDialog(false);
                          setEditingCustomInterest(null);
                        }}
                        className={`flex-1 py-2 rounded-lg text-sm font-bold ${
                          interestStatus[editingCustomInterest.id] === false 
                            ? 'bg-green-500 text-white hover:bg-green-600'
                            : 'bg-blue-500 text-white hover:bg-blue-600'
                        }`}
                      >
                        {interestStatus[editingCustomInterest.id] === false ? t('general.enable') : t('general.disable')}
                      </button>
                      {(!newInterest.builtIn || isUnlocked) && (
                        <button
                          onClick={() => {
                            const msg = newInterest.builtIn 
                              ? `Delete system interest "${newInterest.label}" permanently?`
                              : `Delete custom interest "${newInterest.label}"?`;
                            showConfirm(msg, () => {
                              if (newInterest.builtIn) {
                                toggleInterestStatus(editingCustomInterest.id);
                                if (isFirebaseAvailable && database) {
                                  database.ref(`settings/interestConfig/${editingCustomInterest.id}`).remove();
                                }
                                showToast(t('interests.builtInRemoved'), 'success');
                              } else {
                                deleteCustomInterest(editingCustomInterest.id);
                              }
                              setShowAddInterestDialog(false);
                              setEditingCustomInterest(null);
                            });
                          }}
                          className="flex-1 py-2 bg-red-600 text-white rounded-lg text-sm font-bold hover:bg-red-700"
                        >
                          üóëÔ∏è {t("general.deleteInterest")}
                        </button>
                      )}
                    </div>
                  </div>
                )}
              </div>
              
              {/* Footer */}
              <div className="px-4 py-2.5 border-t border-gray-200 flex gap-2" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}>
                {(() => {
                  const isLockedInterest = editingCustomInterest?.locked && !isUnlocked;
                  return isLockedInterest ? (
                    <div className="flex-shrink-0 py-2.5 px-3 bg-yellow-100 text-yellow-800 rounded-lg text-[11px] font-bold text-center flex items-center">
                      üîí View only
                    </div>
                  ) : (
                    <button
                      onClick={() => {
                        if (!newInterest.label.trim()) return;
                        
                        const searchConfig = {};
                        if (newInterest.searchMode === 'text' && newInterest.textSearch) {
                          searchConfig.textSearch = newInterest.textSearch.trim();
                        } else if (newInterest.types) {
                          searchConfig.types = newInterest.types.split(',').map(t => t.trim()).filter(t => t);
                        }
                        if (newInterest.blacklist) {
                          searchConfig.blacklist = newInterest.blacklist.split(',').map(t => t.trim().toLowerCase()).filter(t => t);
                        }
                        
                        if (editingCustomInterest) {
                          // EDIT MODE
                          const interestId = editingCustomInterest.id;
                          
                          if (newInterest.builtIn) {
                            // Built-in interest - save search config + admin overrides to interestConfig
                            const configData = { ...searchConfig };
                            if (isUnlocked) {
                              configData.labelOverride = newInterest.label.trim();
                              configData.iconOverride = newInterest.icon || '';
                              configData.inProgress = newInterest.inProgress || false;
                              configData.locked = newInterest.locked || false;
                            }
                            if (isFirebaseAvailable && database) {
                              database.ref(`settings/interestConfig/${interestId}`).set(configData);
                            } else {
                              setInterestConfig(prev => ({...prev, [interestId]: configData}));
                            }
                          } else {
                            // Custom interest - update in customInterests
                            const updatedInterest = {
                              ...editingCustomInterest,
                              label: newInterest.label.trim(),
                              name: newInterest.label.trim(),
                              icon: newInterest.icon || 'üìç',
                              privateOnly: newInterest.privateOnly || false,
                              inProgress: newInterest.inProgress || false,
                              locked: newInterest.locked || false
                            };
                            delete updatedInterest.builtIn;
                            
                            if (isFirebaseAvailable && database) {
                              database.ref(`customInterests/${editingCustomInterest.firebaseId || interestId}`).update(updatedInterest);
                              if (Object.keys(searchConfig).length > 0) {
                                database.ref(`settings/interestConfig/${interestId}`).set(searchConfig);
                              }
                            } else {
                              const updated = customInterests.map(ci => ci.id === interestId ? updatedInterest : ci);
                              setCustomInterests(updated);
                              localStorage.setItem('bangkok_custom_interests', JSON.stringify(updated));
                            }
                          }
                          
                          showToast(t('interests.interestUpdated'), 'success');
                        } else {
                          // ADD MODE
                          const interestId = 'custom_' + Date.now();
                          const newInterestData = {
                            id: interestId,
                            label: newInterest.label.trim(),
                            name: newInterest.label.trim(),
                            icon: newInterest.icon || 'üìç',
                            privateOnly: newInterest.privateOnly || false,
                            inProgress: newInterest.inProgress || false,
                            locked: newInterest.locked || false,
                            cityId: selectedCityId
                          };
                          
                          if (isFirebaseAvailable && database) {
                            database.ref(`customInterests/${interestId}`).set(newInterestData);
                            if (Object.keys(searchConfig).length > 0) {
                              database.ref(`settings/interestConfig/${interestId}`).set(searchConfig);
                            }
                          } else {
                            const updated = [...customInterests, newInterestData];
                            setCustomInterests(updated);
                            localStorage.setItem('bangkok_custom_interests', JSON.stringify(updated));
                          }
                          
                          showToast(t('interests.interestAdded'), 'success');
                        }
                        
                        setShowAddInterestDialog(false);
                        showToast(editingCustomInterest ? t('toast.interestUpdated') : t('toast.interestAdded'), 'success');
                        setNewInterest({ label: '', icon: 'üìç', searchMode: 'types', types: '', textSearch: '', blacklist: '', privateOnly: false, inProgress: false, locked: false });
                        setEditingCustomInterest(null);
                      }}
                      disabled={!newInterest.label?.trim()}
                      className={`flex-1 py-2.5 rounded-lg text-sm font-bold transition-all ${
                        newInterest.label?.trim()
                          ? 'bg-purple-500 text-white hover:bg-purple-600'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                    >
                      {editingCustomInterest ? t('general.update') : t('general.add')}
                    </button>
                  );
                })()}
                <button
                  onClick={() => {
                    setShowAddInterestDialog(false);
                    setNewInterest({ label: '', icon: 'üìç', searchMode: 'types', types: '', textSearch: '', blacklist: '', privateOnly: false, inProgress: false, locked: false });
                    setEditingCustomInterest(null);
                  }}
                  className="px-5 py-2.5 rounded-lg bg-green-500 text-white text-sm font-bold hover:bg-green-600"
                >
                  {`‚úì ${t("general.close")}`}
                </button>
              </div>

            </div>
          </div>
        )}

            {/* Access Log Dialog */}
      {showAccessLog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
            <div className="p-4 border-b border-gray-200 flex items-center justify-between bg-gradient-to-r from-blue-50 to-indigo-50">
              <h2 className="text-xl font-bold text-gray-800">{`üîí ${t("general.viewAccessLog")}`}</h2>
              <button
                onClick={() => setShowAccessLog(false)}
                className="text-2xl font-bold text-gray-600 hover:text-gray-800"
              >
                ‚úï
              </button>
            </div>
            
            <div className="flex-1 overflow-y-auto p-4">
              {accessLogs.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  <p className="text-4xl mb-2">üì≠</p>
                  <p>{t("general.noRegisteredUsers")}</p>
                </div>
              ) : (
                <div className="space-y-2">
                  {accessLogs.map((log, index) => {
                    const date = new Date(log.timestamp);
                    const isNew = log.timestamp > parseInt(localStorage.getItem('bangkok_last_seen') || '0');
                    
                    return (
                      <div
                        key={log.id}
                        className={`p-3 rounded-lg border-2 ${
                          isNew ? 'border-red-400 bg-red-50' : 'border-gray-200 bg-gray-50'
                        }`}
                      >
                        <div className="flex items-start justify-between">
                          <div className="flex-1">
                            <div className="flex items-center gap-2 flex-wrap">
                              {isNew && <span className="text-red-500 font-bold">üÜï</span>}
                              <span className="font-bold text-sm">
                                {`User #${log.userId.slice(-8)}`}
                              </span>
                              {log.country && (
                                <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full font-bold">
                                  {log.countryCode === 'IL' ? 'üáÆüá±' : log.countryCode === 'TH' ? 'üáπüá≠' : 'üåç'} {log.country}
                                </span>
                              )}
                            </div>
                            {(log.city || log.region) && (
                              <div className="text-xs text-indigo-600 mt-1 font-medium">
                                üìç {[log.city, log.region].filter(Boolean).join(', ')}
                              </div>
                            )}
                            <div className="text-xs text-gray-600 mt-1">
                              üìÖ {date.toLocaleDateString('he-IL', { 
                                day: '2-digit', 
                                month: '2-digit', 
                                year: 'numeric' 
                              })}
                              {' '}
                              üïê {date.toLocaleTimeString('he-IL', { 
                                hour: '2-digit', 
                                minute: '2-digit' 
                              })}
                            </div>
                            <div className="flex items-center gap-2 mt-1 flex-wrap">
                              {log.browser && (
                                <span className="text-[10px] bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded">
                                  üåê {log.browser}
                                </span>
                              )}
                              {log.os && (
                                <span className="text-[10px] bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded">
                                  {log.os === 'iPhone' || log.os === 'iPad' || log.os === 'Android' ? 'üì±' : 'üíª'} {log.os}
                                </span>
                              )}
                              {log.screenSize && (
                                <span className="text-[10px] bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded">
                                  üìê {log.screenSize}
                                </span>
                              )}
                              {log.language && (
                                <span className="text-[10px] bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded">
                                  üó£Ô∏è {log.language}
                                </span>
                              )}
                            </div>
                            {(log.isp || log.ip) && (
                              <div className="text-[10px] text-gray-400 mt-1">
                                {log.isp && <span>üè¢ {log.isp}</span>}
                                {log.ip && <span className="mr-2">  IP: {log.ip}</span>}
                              </div>
                            )}
                            {!log.country && log.userAgent && (
                              <div className="text-[10px] text-gray-400 mt-1 truncate">
                                {log.userAgent}
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
            
            <div className="p-4 border-t border-gray-200 bg-gray-50">
              <div className="flex items-center justify-between">
                <div className="text-xs text-gray-600">
                  {`Total: ${accessLogs.length}`}
                  {hasNewEntries && (
                    <span className="text-red-600 font-bold mr-2">
                      ‚Ä¢ New entries
                    </span>
                  )}
                </div>
                {accessLogs.length > 0 && (
                  <button
                    onClick={() => {
                      showConfirm(t('settings.deleteAllConfirm'), () => {
                        if (isFirebaseAvailable && database) {
                          database.ref('accessLog').remove()
                            .then(() => {
                              setAccessLogs([]);
                              setHasNewEntries(false);
                              localStorage.setItem('bangkok_last_seen', Date.now().toString());
                              showToast(t('toast.logCleared'), 'success');
                            })
                            .catch(err => {
                              console.error('[ACCESS LOG] Clear error:', err);
                              showToast(t('toast.logClearError'), 'error');
                            });
                        }
                      });
                    }}
                    className="text-xs px-3 py-1.5 rounded-lg bg-red-500 text-white font-bold hover:bg-red-600 transition"
                  >
                    üóëÔ∏è {t("general.clearLog")}
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Route Dialog */}
      {showRouteDialog && editingRoute && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-2">
          <div className="bg-white rounded-xl w-full max-w-md max-h-[90vh] flex flex-col shadow-2xl">
            
            {/* Header */}
            <div className="bg-gradient-to-r from-blue-500 to-cyan-500 text-white px-4 py-2.5 rounded-t-xl flex items-center justify-between">
              <div className="flex items-center gap-2">
                <h3 className="text-base font-bold">{routeDialogMode === 'add' ? t('route.addSavedRoute') : t('route.editSavedRoute')}</h3>
              </div>
              <button
                onClick={() => { setShowRouteDialog(false); setEditingRoute(null); }}
                className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
              >‚úï</button>
            </div>
            
            {/* Content */}
            <div className="flex-1 overflow-y-auto px-4 py-3 space-y-3">
              <div style={{ position: 'relative' }}>
              {editingRoute?.locked && !isUnlocked && (
                <div style={{ position: 'absolute', inset: 0, zIndex: 10, backgroundColor: 'rgba(255,255,255,0.3)' }} />
              )}
              {/* Route info */}
              <div className="bg-blue-50 rounded-lg p-3 space-y-1.5">
                {/* Area */}
                <div className="text-xs text-gray-700">
                  <span className="font-bold">{`üìç ${t('general.area')}:`}</span> {editingRoute.areaName || t('general.noArea')}
                </div>
                {/* Interests */}
                {(() => {
                  const ids = [...new Set((editingRoute.stops || []).flatMap(s => s.interests || []))];
                  return ids.length > 0 && (
                    <div className="flex gap-1 flex-wrap items-center">
                      <span className="text-xs font-bold text-gray-700">{`üè∑Ô∏è ${t('general.interestsHeader')}:`}</span>
                      {ids.map((intId, idx) => {
                        const obj = allInterestOptions.find(o => o.id === intId);
                        return obj ? (
                          <span key={idx} className="text-[10px] bg-white px-1.5 py-0.5 rounded" title={obj.label}>
                            {obj.icon?.startsWith?.('data:') ? <img src={obj.icon} alt="" className="w-3.5 h-3.5 object-contain inline" /> : obj.icon} {obj.label}
                          </span>
                        ) : null;
                      })}
                    </div>
                  );
                })()}
                {/* Circular / Linear */}
                <div className="text-xs text-gray-700">
                  <span className="font-bold">{`üîÄ ${t("route.routeType")}:`}</span> {editingRoute.circular ? t('route.circularRoute') : t('route.linearRoute')}
                </div>
                {/* Start point */}
                <div className="text-xs text-gray-700">
                  <span className="font-bold">{`üö© ${t("route.startPoint")}:`}</span> {editingRoute.startPoint || editingRoute.startPointCoords?.address || t('form.startPointFirst')}
                </div>
              </div>

              {/* Name */}
              <div>
                <label className="block text-xs font-bold mb-1">{t("general.routeName")}</label>
                <input
                  type="text"
                  value={editingRoute.name || ''}
                  onChange={(e) => setEditingRoute({...editingRoute, name: e.target.value})}
                  className="w-full p-2 text-sm border-2 border-blue-300 rounded-lg"
                  style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                  disabled={editingRoute.locked && !isUnlocked}
                />
              </div>

              {/* Notes */}
              <div>
                <label className="block text-xs font-bold mb-1">{`üí¨ ${t('general.notesLabel')}`}</label>
                <textarea
                  value={editingRoute.notes || ''}
                  onChange={(e) => setEditingRoute({...editingRoute, notes: e.target.value})}
                  placeholder={t("places.notes")}
                  className="w-full p-2 text-sm border-2 border-gray-300 rounded-lg h-16 resize-none"
                  style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                  disabled={editingRoute.locked && !isUnlocked}
                />
              </div>

              {/* Stops list */}
              <div>
                <label className="block text-xs font-bold mb-1">{t("general.stopsCount")} ({editingRoute.stops?.length || 0})</label>
                <div className="max-h-32 overflow-y-auto space-y-0.5">
                  {(editingRoute.stops || []).map((stop, idx) => (
                    <div key={idx} className="flex items-center gap-1 text-xs bg-gray-50 px-2 py-1 rounded">
                      <span className="text-gray-400">{idx + 1}.</span>
                      <span className="font-medium truncate">{stop.name}</span>
                      {stop.rating && <span className="text-yellow-600">‚≠ê{stop.rating}</span>}
                    </div>
                  ))}
                </div>
              </div>
              </div>{/* close inner wrapper */}

              {/* Share buttons - always available */}
              <div className="flex gap-2">
                <button
                  onClick={() => {
                    const shareText = `üó∫Ô∏è ${editingRoute.name}\nüìç ${editingRoute.areaName}\nüéØ ${editingRoute.stops?.length || 0} stops\n${editingRoute.circular ? t('route.circularRoute') : t('route.linearDesc')}\n\nstops:\n${(editingRoute.stops || []).map((s, i) => `${i+1}. ${s.name}${s.address ? ' - ' + s.address : ''}`).join('\n')}`;
                    if (navigator.share) {
                      navigator.share({ title: editingRoute.name, text: shareText });
                    } else {
                      navigator.clipboard.writeText(shareText);
                      showToast(t('route.routeCopied'), 'success');
                    }
                  }}
                  className="flex-1 py-2 bg-green-500 text-white rounded-lg text-sm font-bold hover:bg-green-600"
                >
                  üì§ {t("general.shareRoute")}
                </button>
                <button
                  onClick={() => {
                    const pois = (editingRoute.stops || []).map((s, i) => {
                      let line = `${i+1}. ${s.name}`;
                      if (s.address) line += `\n   üìç ${s.address}`;
                      if (s.description) line += `\n   ${s.description}`;
                      if (s.todayHours) line += `\n   üïê ${s.todayHours}`;
                      if (s.rating) line += `\n   ‚≠ê ${s.rating}`;
                      const mapsUrl = (() => { const u = window.BKK.getGoogleMapsUrl(s); return u === '#' ? '' : u; })();
                      if (mapsUrl) line += `\n   üó∫Ô∏è ${mapsUrl}`;
                      return line;
                    }).join('\n\n');
                    const text = `üìç POI - ${editingRoute.name}\n${'‚îÄ'.repeat(30)}\n\n${pois}`;
                    if (navigator.share) {
                      navigator.share({ title: `POI - ${editingRoute.name}`, text });
                    } else {
                      navigator.clipboard.writeText(text);
                      showToast(t('route.pointsCopied'), 'success');
                    }
                  }}
                  className="flex-1 py-2 bg-indigo-500 text-white rounded-lg text-sm font-bold hover:bg-indigo-600"
                >
                  üìã {t("general.sharePoi")}
                </button>
              </div>

              {/* Status toggles - hidden for locked non-admin */}
              {!(editingRoute.locked && !isUnlocked) && (
              <div className="flex gap-3 px-4 py-2 bg-gray-50 border-t border-gray-100">
                <button type="button"
                  onClick={() => setEditingRoute({...editingRoute, inProgress: !editingRoute.inProgress})}
                  className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${editingRoute.inProgress ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                >
                  {editingRoute.inProgress ? '‚è≥' : '‚óã'} {t("general.inProgress")}
                </button>
                {isUnlocked && (
                  <button type="button"
                    onClick={() => setEditingRoute({...editingRoute, locked: !editingRoute.locked})}
                    className={`flex items-center gap-1 px-3 py-1 rounded-full text-xs font-medium border transition-all ${editingRoute.locked ? 'border-gray-400 bg-gray-100 text-gray-800' : 'border-gray-200 bg-white text-gray-400'}`}
                  >
                    {editingRoute.locked ? 'üîí' : '‚óã'} {t("general.locked")}
                  </button>
                )}
              </div>
              )}

              {/* Actions: Delete - hidden for locked non-admin */}
              {!(editingRoute.locked && !isUnlocked) && (
              <div className="border-t border-red-200 bg-red-50 px-4 py-2">
                <div className="flex gap-2">
                  <button
                    onClick={() => {
                      showConfirm(`{t("general.deleteRoute")} "${editingRoute.name}"?`, () => {
                        deleteRoute(editingRoute.id);
                        setShowRouteDialog(false);
                        setEditingRoute(null);
                      });
                    }}
                    className="flex-1 py-2 bg-red-600 text-white rounded-lg text-sm font-bold hover:bg-red-700"
                  >
                    üóëÔ∏è {t("general.deleteRoute")}
                  </button>
                </div>
              </div>
              )}
            </div>
            
            {/* Footer */}
            <div className="px-4 py-2.5 border-t border-gray-200 flex gap-2" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}>
              {(() => {
                const isLockedRoute = editingRoute.locked && !isUnlocked;
                return (
                  <>
                    {isLockedRoute ? (
                      <>
                        <button
                          onClick={() => {
                            loadSavedRoute(editingRoute);
                            setShowRouteDialog(false);
                            setEditingRoute(null);
                          }}
                          className="flex-1 py-2.5 bg-blue-500 text-white rounded-lg text-sm font-bold hover:bg-blue-600"
                        >
                          üìç {t("general.openRoute")}
                        </button>
                        <div className="flex-shrink-0 py-2.5 px-3 bg-yellow-100 text-yellow-800 rounded-lg text-[11px] font-bold text-center">
                          üîí View only
                        </div>
                      </>
                    ) : (
                      <>
                        <button
                          onClick={() => {
                            updateRoute(editingRoute.id, {
                              name: editingRoute.name,
                              notes: editingRoute.notes,
                              inProgress: editingRoute.inProgress,
                              locked: editingRoute.locked
                            });
                            setShowRouteDialog(false);
                            setEditingRoute(null);
                          }}
                          className="flex-1 py-2.5 bg-blue-500 text-white rounded-lg text-sm font-bold hover:bg-blue-600"
                        >
                          üíæ Update
                        </button>
                        <button
                          onClick={() => {
                            loadSavedRoute(editingRoute);
                            setShowRouteDialog(false);
                            setEditingRoute(null);
                          }}
                          className="flex-1 py-2.5 bg-blue-500 text-white rounded-lg text-sm font-bold hover:bg-blue-600"
                        >
                          üìç {t("general.openRoute")}
                        </button>
                      </>
                    )}
                    <button
                      onClick={() => { setShowRouteDialog(false); setEditingRoute(null); }}
                      className="px-5 py-2.5 rounded-lg bg-green-500 text-white text-sm font-bold hover:bg-green-600"
                    >
                      {`‚úì ${t("general.close")}`}
                    </button>
                  </>
                );
              })()}
            </div>
          </div>
        </div>
      )}

      {/* Manual Add Stop Dialog */}
      {showManualAddDialog && (() => {
        const searchManualPlace = async () => {
          const input = document.getElementById('manual-stop-input');
          const resultsDiv = document.getElementById('manual-stop-results');
          const q = input?.value?.trim();
          if (!q || !resultsDiv) return;
          
          resultsDiv.innerHTML = '<p style="text-align:center;color:#9ca3af;font-size:12px;padding:8px">{t("general.searching")}...</p>';
          
          try {
            const result = await window.BKK.geocodeAddress(q);
            if (result) {
              const display = result.displayName || result.address || q;
              resultsDiv.innerHTML = '';
              const btn = document.createElement('button');
              btn.className = 'w-full p-3 text-right bg-purple-50 hover:bg-purple-100 border border-purple-200 rounded-lg transition';
              btn.style.direction = 'rtl';
              btn.innerHTML = `<div style="font-weight:bold;font-size:14px;color:#6d28d9">üìç ${display}</div><div style="font-size:10px;color:#6b7280;margin-top:2px">${result.lat.toFixed(5)}, ${result.lng.toFixed(5)}</div>`;
              btn.onclick = () => {
                const newStop = {
                  name: display,
                  lat: result.lat,
                  lng: result.lng,
                  description: `‚≠ê N/A`,
                  address: result.address || display,
                  duration: 45,
                  interests: ['_manual'],
                  manuallyAdded: true,
                  googlePlace: false,
                  rating: 0,
                  ratingCount: 0
                };
                
                // Check duplicates against current route
                const isDup = route?.stops?.some(s => s.name.toLowerCase().trim() === newStop.name.toLowerCase().trim());
                if (isDup) {
                  showToast(`"${display}" ${t("places.alreadyInRoute")}`, 'warning');
                  return;
                }
                
                // Add to manualStops (session state)
                setManualStops(prev => [...prev, newStop]);
                
                // Add to current route if exists
                if (route) {
                  setRoute(prev => prev ? {
                    ...prev,
                    stops: [...prev.stops, newStop]
                  } : prev);
                }
                
                showToast(`‚ûï ${display} ${t("interests.added")}`, 'success');
                
                // Clear input for next add
                const inp = document.getElementById('manual-stop-input');
                if (inp) inp.value = '';
                resultsDiv.innerHTML = '<p style="text-align:center;color:#16a34a;font-size:12px;padding:8px">‚úÖ Added! You can add more or close</p>';
              };
              resultsDiv.appendChild(btn);
            } else {
              resultsDiv.innerHTML = '<p style="text-align:center;color:#ef4444;font-size:12px;padding:8px">‚ùå No results found</p>';
            }
          } catch (err) {
            console.error('[MANUAL_ADD] Search error:', err);
            resultsDiv.innerHTML = '<p style="text-align:center;color:#ef4444;font-size:12px;padding:8px">‚ùå Search error</p>';
          }
        };
        
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-3">
            <div className="bg-white rounded-xl w-full max-w-md shadow-2xl" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}>
              {/* Header */}
              <div className="bg-gradient-to-r from-purple-500 to-violet-600 text-white px-4 py-2.5 rounded-t-xl flex items-center justify-between">
                <h3 className="text-sm font-bold">{t("route.addManualStop")}</h3>
                <button
                  onClick={() => setShowManualAddDialog(false)}
                  className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
                >
                  ‚úï
                </button>
              </div>
              
              {/* Search input */}
              <div className="p-4 space-y-3">
                <div className="flex gap-2">
                  <input
                    id="manual-stop-input"
                    type="text"
                    onKeyDown={(e) => { if (e.key === 'Enter') searchManualPlace(); }}
                    placeholder={t("form.typeAddressAlt")}
                    className="flex-1 p-2.5 border border-gray-300 rounded-lg text-sm"
                    style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                    autoFocus
                  />
                  <button
                    onClick={searchManualPlace}
                    className="px-4 py-2 rounded-lg text-sm font-bold whitespace-nowrap bg-purple-500 text-white hover:bg-purple-600"
                  >
                    {`üîç ${t('general.search')}`}
                  </button>
                </div>
                
                <p className="text-[11px] text-gray-500">
                  {t('general.searchAndAddHint')}
                </p>
                
                {manualStops.length > 0 && (
                  <div className="text-[11px] text-purple-600 font-bold">
                    {`üìç ${manualStops.length} ${t('general.placesAddedManually')}`}
                  </div>
                )}
                
                {/* Results container */}
                <div id="manual-stop-results" className="space-y-2 max-h-60 overflow-y-auto"></div>
              </div>
            </div>
          </div>
        );
      })()}

      {/* Address Search Dialog */}
      {showAddressDialog && (() => {
        const searchAddress = async () => {
          const input = document.getElementById('addr-search-input');
          const resultsDiv = document.getElementById('addr-search-results');
          const q = input?.value?.trim();
          if (!q || !resultsDiv) return;
          
          resultsDiv.innerHTML = '<p style="text-align:center;color:#9ca3af;font-size:12px;padding:8px">{t("general.searching")}...</p>';
          
          try {
            const result = await window.BKK.geocodeAddress(q);
            if (result) {
              const addr = result.address || result.displayName || q;
              const display = result.displayName || result.address || q;
              resultsDiv.innerHTML = '';
              const btn = document.createElement('button');
              btn.className = 'w-full p-3 text-right bg-green-50 hover:bg-green-100 border border-green-200 rounded-lg transition';
              btn.style.direction = 'rtl';
              btn.innerHTML = `<div style="font-weight:bold;font-size:14px;color:#166534">üìç ${display}</div><div style="font-size:10px;color:#6b7280;margin-top:2px">${result.lat.toFixed(5)}, ${result.lng.toFixed(5)}</div>`;
              btn.onclick = () => {
                setFormData(prev => ({ ...prev, startPoint: display }));
                setStartPointCoords({ lat: result.lat, lng: result.lng, address: display });
                if (route?.optimized) setRoute(prev => prev ? {...prev, optimized: false} : prev);
                showToast(`‚úÖ ${display}`, 'success');
                setShowAddressDialog(false);
              };
              resultsDiv.appendChild(btn);
            } else {
              resultsDiv.innerHTML = '<p style="text-align:center;color:#ef4444;font-size:12px;padding:8px">‚ùå No results found</p>';
            }
          } catch (err) {
            console.error('[ADDRESS_DIALOG] Search error:', err);
            resultsDiv.innerHTML = '<p style="text-align:center;color:#ef4444;font-size:12px;padding:8px">‚ùå Search error</p>';
          }
        };
        
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-3">
            <div className="bg-white rounded-xl w-full max-w-md shadow-2xl" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}>
              {/* Header */}
              <div className="bg-gradient-to-r from-green-500 to-teal-500 text-white px-4 py-2.5 rounded-t-xl flex items-center justify-between">
                <h3 className="text-sm font-bold">{`üìç ${t("form.searchAddress")}`}</h3>
                <button
                  onClick={() => setShowAddressDialog(false)}
                  className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
                >
                  ‚úï
                </button>
              </div>
              
              {/* Search input */}
              <div className="p-4 space-y-3">
                <div className="flex gap-2">
                  <input
                    id="addr-search-input"
                    type="text"
                    onKeyDown={(e) => { if (e.key === 'Enter') searchAddress(); }}
                    placeholder={t("form.typeAddress")}
                    className="flex-1 p-2.5 border border-gray-300 rounded-lg text-sm"
                    style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr' }}
                    autoFocus
                  />
                  <button
                    onClick={searchAddress}
                    className="px-4 py-2 rounded-lg text-sm font-bold whitespace-nowrap bg-green-500 text-white hover:bg-green-600"
                  >
                    {`üîç ${t('general.search')}`}
                  </button>
                </div>
                
                <p className="text-[11px] text-gray-500">
                  üí° Enter full address, hotel name, train station, or any place in {tLabel(window.BKK.selectedCity) || t('general.city')}
                </p>
                
                {/* Results container */}
                <div id="addr-search-results" className="space-y-2 max-h-60 overflow-y-auto"></div>
              </div>
            </div>
          </div>
        );
      })()}

      {/* Image Modal */}
      {showImageModal && modalImage && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-80 z-[100] flex items-center justify-center p-4"
          onClick={() => { setShowImageModal(false); setModalImage(null); }}
        >
          <button
            onClick={() => { setShowImageModal(false); setModalImage(null); }}
            className="absolute top-4 right-4 bg-white bg-opacity-90 text-black rounded-full w-9 h-9 flex items-center justify-center text-xl font-bold shadow-lg hover:bg-opacity-100 z-10"
          >‚úï</button>
          <img src={modalImage} alt="enlarged" className="max-w-full max-h-full rounded-lg shadow-2xl" />
        </div>
      )}

      {/* Help Dialog */}
      {showHelp && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100] p-4">
          <div className="bg-white rounded-xl max-w-md w-full max-h-[80vh] overflow-hidden flex flex-col shadow-2xl">
            <div className="bg-gradient-to-r from-blue-500 to-indigo-500 text-white px-4 py-3 flex items-center justify-between">
              <h3 className="text-base font-bold flex items-center gap-2">
                <span>‚ÑπÔ∏è</span>
                {helpContent[helpContext]?.title || t('general.help')}
              </h3>
              <button
                onClick={() => setShowHelp(false)}
                className="text-xl hover:bg-white hover:bg-opacity-20 rounded-full w-7 h-7 flex items-center justify-center"
              >‚úï</button>
            </div>
            <div className="flex-1 overflow-y-auto p-4 text-sm text-gray-700" style={{ direction: window.BKK.i18n.isRTL() ? 'rtl' : 'ltr', textAlign: window.BKK.i18n.isRTL() ? 'right' : 'left' }}>
              {helpContent[helpContext]?.content.split('\n').map((line, i) => {
                // Render inline **bold** anywhere in the line
                const renderBold = (text) => {
                  const parts = text.split(/\*\*(.*?)\*\*/g);
                  return parts.map((part, j) => j % 2 === 1 ? <strong key={j}>{part}</strong> : part);
                };
                if (line.startsWith('**') && line.endsWith('**')) {
                  return <h4 key={i} className="font-bold text-gray-900 mt-3 mb-1">{line.replace(/\*\*/g, '')}</h4>;
                } else if (line.startsWith('‚Ä¢ ')) {
                  return <p key={i} style={{ marginInlineStart: '12px' }} className="mb-0.5">‚Ä¢ {renderBold(line.substring(2))}</p>;
                } else if (line.trim() === '') {
                  return <div key={i} className="h-2" />;
                }
                return <p key={i} className="mb-1">{renderBold(line)}</p>;
              })}
            </div>
            <div className="px-4 py-3 border-t border-gray-200 bg-gray-50">
              <button
                onClick={() => setShowHelp(false)}
                className="w-full py-2 rounded-lg bg-blue-500 text-white font-bold hover:bg-blue-600 text-sm"
              >{t('general.close')} ‚úì</button>
            </div>
          </div>
        </div>
      )}

      {/* Confirm Dialog */}
      {showConfirmDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-[60] flex items-center justify-center p-4">
          <div className="bg-white rounded-xl p-4 max-w-sm w-full shadow-2xl">
            <p className="text-sm text-gray-800 mb-4 text-center font-medium">{confirmConfig.message}</p>
            <div className="flex gap-2">
              <button
                onClick={() => {
                  setShowConfirmDialog(false);
                  if (confirmConfig.onConfirm) confirmConfig.onConfirm();
                }}
                className="flex-1 py-2 bg-red-500 text-white rounded-lg font-bold hover:bg-red-600"
              >
                OK
              </button>
              <button
                onClick={() => setShowConfirmDialog(false)}
                className="flex-1 py-2 bg-gray-300 text-gray-700 rounded-lg font-bold hover:bg-gray-400"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Toast Notification - Subtle */}
      {/* Feedback Dialog */}
      {showFeedbackDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-end sm:items-center justify-center p-0 sm:p-4">
          <div className="bg-white rounded-t-2xl sm:rounded-xl w-full max-w-sm shadow-2xl">
            <div className="bg-gradient-to-r from-slate-600 to-slate-700 text-white p-3 rounded-t-2xl sm:rounded-t-xl flex justify-between items-center">
              <h3 className="text-base font-bold">{`üí¨ ${t("settings.sendFeedback")}`}</h3>
              <button onClick={() => { setShowFeedbackDialog(false); setFeedbackText(''); }} className="text-white opacity-70 hover:opacity-100 text-xl leading-none">‚úï</button>
            </div>
            <div className="p-4 space-y-3">
              <div className="flex gap-2">
                {[
                  { id: 'bug', label: t('general.bug'), color: 'red' },
                  { id: 'idea', label: t('general.idea'), color: 'yellow' },
                  { id: 'general', label: t('general.generalFeedback'), color: 'blue' }
                ].map(cat => (
                  <button
                    key={cat.id}
                    onClick={() => setFeedbackCategory(cat.id)}
                    className={`flex-1 py-1.5 rounded-lg text-xs font-bold transition-all ${
                      feedbackCategory === cat.id
                        ? cat.color === 'red' ? 'bg-red-100 border-2 border-red-400 text-red-700'
                        : cat.color === 'yellow' ? 'bg-yellow-100 border-2 border-yellow-400 text-yellow-700'
                        : 'bg-blue-100 border-2 border-blue-400 text-blue-700'
                        : 'bg-gray-100 border-2 border-transparent text-gray-500'
                    }`}
                  >
                    {cat.label}
                  </button>
                ))}
              </div>
              
              <textarea
                value={feedbackText}
                onChange={(e) => setFeedbackText(e.target.value)}
                placeholder={t("settings.feedbackPlaceholder")}
                className="w-full p-3 border-2 border-gray-200 rounded-lg text-sm resize-none focus:border-blue-400 focus:outline-none"
                rows={4}
                autoFocus
                dir={window.BKK.i18n.isRTL() ? "rtl" : "ltr"}
              />
              
              <button
                onClick={submitFeedback}
                disabled={!feedbackText.trim()}
                className={`w-full py-2.5 rounded-lg font-bold text-sm transition-all ${
                  feedbackText.trim()
                    ? 'bg-blue-500 text-white hover:bg-blue-600'
                    : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                }`}
              >
                üì® Send
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback List Dialog (Admin Only) */}
      {showFeedbackList && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl w-full max-w-lg shadow-2xl max-h-[80vh] flex flex-col">
            <div className="bg-gradient-to-r from-purple-600 to-pink-600 text-white p-3 rounded-t-xl flex justify-between items-center">
              <h3 className="text-base font-bold">{`üí¨ Feedback (`}{feedbackList.length})</h3>
              <div className="flex items-center gap-2">
                {feedbackList.length > 0 && (
                  <button
                    onClick={() => {
                      showConfirm(t('settings.deleteAllFeedback'), () => {
                        if (isFirebaseAvailable && database) {
                          database.ref('feedback').remove().then(() => {
                            setFeedbackList([]);
                            showToast(t('toast.allFeedbackDeleted'), 'success');
                          });
                        }
                      });
                    }}
                    className="text-white opacity-70 hover:opacity-100 text-sm"
                    title={t("general.deleteAll")}
                  >
                    üóëÔ∏è
                  </button>
                )}
                <button onClick={() => setShowFeedbackList(false)} className="text-white opacity-70 hover:opacity-100 text-xl leading-none">‚úï</button>
              </div>
            </div>
            <div className="overflow-y-auto flex-1 p-3">
              {feedbackList.length === 0 ? (
                <div className="text-center text-gray-400 py-8">
                  <div className="text-3xl mb-2">üì≠</div>
                  <p className="text-sm">{t("general.noRegisteredUsers")}</p>
                </div>
              ) : (
                <div className="space-y-2">
                  {feedbackList.map((item) => (
                    <div key={item.firebaseId} className={`p-3 rounded-lg border-2 transition-all ${
                      item.resolved ? 'bg-gray-50 border-gray-200 opacity-60' : 'bg-white border-gray-300'
                    }`}>
                      <div className="flex justify-between items-start mb-1">
                        <div className="flex items-center gap-2">
                          <span className="text-sm">
                            {item.category === 'bug' ? 'üêõ' : item.category === 'idea' ? 'üí°' : 'üí≠'}
                          </span>
                          <span className="text-[10px] text-gray-400 font-mono">{item.userId?.slice(-8)}</span>
                          <span className="text-[10px] text-gray-400">{`From: ${item.currentView || '?'}`}</span>
                        </div>
                        <div className="flex items-center gap-1">
                          <button
                            onClick={() => toggleFeedbackResolved(item)}
                            className={`text-sm px-1 ${item.resolved ? 'opacity-50' : ''}`}
                            title={item.resolved ? t('places.markUnhandled') : t('places.markHandled')}
                          >
                            {item.resolved ? '‚Ü©Ô∏è' : '‚úÖ'}
                          </button>
                          <button
                            onClick={() => deleteFeedback(item)}
                            className="text-sm px-1 opacity-50 hover:opacity-100"
                            title={t("general.delete")}
                          >
                            üóëÔ∏è
                          </button>
                        </div>
                      </div>
                      <p className="text-sm text-gray-700 whitespace-pre-wrap">{item.text}</p>
                      <div className="text-[10px] text-gray-400 mt-1">
                        {item.date ? new Date(item.date).toLocaleString('he-IL', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' }) : ''}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Import Confirmation Dialog */}
      {showImportDialog && importedData && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl w-full max-w-sm shadow-2xl">
            <div className="bg-gradient-to-r from-green-600 to-emerald-600 text-white p-3 rounded-t-xl">
              <h3 className="text-base font-bold">{`üì• ${t('general.importExport')}`}</h3>
            </div>
            <div className="p-4 space-y-3">
              {importedData.exportDate && (
                <p className="text-xs text-gray-500 text-center">
                  {`Date: ${new Date(importedData.exportDate).toLocaleDateString()}`}
                  {importedData.version && ` | v${importedData.version}`}
                </p>
              )}
              
              <div className="bg-gray-50 rounded-lg p-3 space-y-1.5">
                <div className="flex justify-between text-sm">
                  <span>{`üè∑Ô∏è ${t('interests.customCount')}`}</span>
                  <span className="font-bold text-purple-600">{(importedData.customInterests || []).length}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>{`üìç ${t("nav.myPlaces")}`}</span>
                  <span className="font-bold text-blue-600">{(importedData.customLocations || []).length}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>{`üó∫Ô∏è ${t("nav.saved")}`}</span>
                  <span className="font-bold text-blue-600">{(importedData.savedRoutes || []).length}</span>
                </div>
                {importedData.interestConfig && (
                  <div className="flex justify-between text-sm">
                    <span>{`‚öôÔ∏è ${t("general.searchSettings")}`}</span>
                    <span className="font-bold text-gray-600">{Object.keys(importedData.interestConfig).length}</span>
                  </div>
                )}
                {importedData.interestStatus && (
                  <div className="flex justify-between text-sm">
                    <span>{`‚úÖ ${t('interests.interestStatus')}`}</span>
                    <span className="font-bold text-gray-600">{Object.keys(importedData.interestStatus).length}</span>
                  </div>
                )}
              </div>
              
              <div className="bg-yellow-50 border border-yellow-300 rounded-lg p-2">
                <p className="text-xs text-yellow-800">
                  üí° Existing items won't be overwritten. Only new items will be added.
                </p>
              </div>
              
              <div className="flex gap-2">
                <button
                  onClick={handleImportMerge}
                  className="flex-1 py-2.5 bg-green-500 text-white rounded-lg font-bold hover:bg-green-600 transition text-sm"
                >
                  ‚úÖ {t("general.importFromFile")}
                </button>
                <button
                  onClick={() => {
                    setShowImportDialog(false);
                    setImportedData(null);
                  }}
                  className="flex-1 py-2.5 bg-gray-300 text-gray-700 rounded-lg font-bold hover:bg-gray-400 transition text-sm"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Add City Dialog */}
      {showAddCityDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl w-full max-w-md shadow-2xl" style={{ maxHeight: '90vh', overflow: 'auto' }}>
            <div className="bg-gradient-to-r from-emerald-500 to-teal-600 text-white p-3 rounded-t-xl flex justify-between items-center">
              <h3 className="text-base font-bold">{`üåç ${t('settings.addCity')}`}</h3>
              <button onClick={() => { setShowAddCityDialog(false); setAddCityInput(''); setAddCitySearchStatus(''); setAddCityFound(null); setAddCityGenerated(null); }} className="text-white text-lg font-bold">‚úï</button>
            </div>
            <div className="p-4">
                  <div className="space-y-4">
                    {/* Search input */}
                    <div className="flex gap-2">
                      <input
                        type="text" value={addCityInput} onChange={(e) => setAddCityInput(e.target.value)}
                        placeholder={t('settings.enterCityName')}
                        className="flex-1 p-2 border-2 border-gray-300 rounded-lg text-sm"
                        autoFocus
                        onKeyDown={(e) => { if (e.key === 'Enter') {
                          const doSearch = async () => {
                            if (!addCityInput.trim()) return;
                            setAddCitySearchStatus('searching');
                            setAddCityFound(null);
                            setAddCityGenerated(null);
                            try {
                              const resp = await fetch(window.BKK.GOOGLE_PLACES_TEXT_SEARCH_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY, 'X-Goog-FieldMask': 'places.displayName,places.formattedAddress,places.location,places.types,places.viewport,places.id' },
                                body: JSON.stringify({ textQuery: addCityInput + ' city', languageCode: 'en' })
                              });
                              const data = await resp.json();
                              if (data.places && data.places.length > 0) {
                                const place = data.places[0];
                                const cityName = place.displayName?.text || addCityInput;
                                const lat = place.location?.latitude;
                                const lng = place.location?.longitude;
                                if (lat && lng) {
                                  const cityId = cityName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                  if (window.BKK.cities[cityId]) {
                                    setAddCitySearchStatus('error');
                                    showToast(t('settings.cityAlreadyExists'), 'warning');
                                    return;
                                  }
                                  setAddCityFound({ name: cityName, lat, lng, address: place.formattedAddress, id: cityId, viewport: place.viewport });
                                  setAddCitySearchStatus('found');
                                } else { setAddCitySearchStatus('error'); }
                              } else { setAddCitySearchStatus('error'); }
                            } catch (err) { console.error('[ADD CITY] Search error:', err); setAddCitySearchStatus('error'); }
                          };
                          doSearch();
                        }}}
                      />
                      <button onClick={async () => {
                            if (!addCityInput.trim()) return;
                            setAddCitySearchStatus('searching');
                            setAddCityFound(null);
                            setAddCityGenerated(null);
                            try {
                              const resp = await fetch(window.BKK.GOOGLE_PLACES_TEXT_SEARCH_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY, 'X-Goog-FieldMask': 'places.displayName,places.formattedAddress,places.location,places.types,places.viewport,places.id' },
                                body: JSON.stringify({ textQuery: addCityInput + ' city', languageCode: 'en' })
                              });
                              const data = await resp.json();
                              if (data.places && data.places.length > 0) {
                                const place = data.places[0];
                                const cityName = place.displayName?.text || addCityInput;
                                const lat = place.location?.latitude;
                                const lng = place.location?.longitude;
                                if (lat && lng) {
                                  const cityId = cityName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                  if (window.BKK.cities[cityId]) {
                                    setAddCitySearchStatus('error');
                                    showToast(t('settings.cityAlreadyExists'), 'warning');
                                    return;
                                  }
                                  setAddCityFound({ name: cityName, lat, lng, address: place.formattedAddress, id: cityId, viewport: place.viewport });
                                  setAddCitySearchStatus('found');
                                } else { setAddCitySearchStatus('error'); }
                              } else { setAddCitySearchStatus('error'); }
                            } catch (err) { console.error('[ADD CITY] Search error:', err); setAddCitySearchStatus('error'); }
                      }} disabled={!addCityInput.trim() || addCitySearchStatus === 'searching'}
                        className="px-4 py-2 bg-emerald-500 text-white rounded-lg font-bold text-sm hover:bg-emerald-600 disabled:opacity-50"
                      >{addCitySearchStatus === 'searching' ? '...' : `üîç ${t('general.search')}`}</button>
                    </div>

                    {/* Search result */}
                    {addCitySearchStatus === 'error' && (
                      <p className="text-sm text-red-500 text-center">{t('settings.cityNotFound')}</p>
                    )}
                    
                    {addCitySearchStatus === 'found' && addCityFound && (
                      <div className="bg-emerald-50 border border-emerald-200 rounded-lg p-3 text-center">
                        <p className="font-bold text-lg">{addCityFound.name}</p>
                        <p className="text-xs text-gray-500">{addCityFound.address}</p>
                        <p className="text-xs text-gray-400 mt-1">{addCityFound.lat.toFixed(4)}, {addCityFound.lng.toFixed(4)}</p>
                        <button onClick={async () => {
                          if (!addCityFound) return;
                          setAddCitySearchStatus('generating');
                          try {
                            const areasResp = await fetch(window.BKK.GOOGLE_PLACES_TEXT_SEARCH_URL, {
                              method: 'POST',
                              headers: { 'Content-Type': 'application/json', 'X-Goog-Api-Key': window.BKK.GOOGLE_PLACES_API_KEY, 'X-Goog-FieldMask': 'places.displayName,places.location,places.types,places.formattedAddress' },
                              body: JSON.stringify({ textQuery: `popular neighborhoods districts areas in ${addCityFound.name}`, languageCode: 'en', maxResultCount: 10 })
                            });
                            const areasData = await areasResp.json();
                            const areas = [];
                            const seen = new Set();
                            if (areasData.places) {
                              areasData.places.forEach((p, i) => {
                                const areaName = p.displayName?.text || `Area ${i+1}`;
                                const areaId = areaName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                if (seen.has(areaId) || !p.location) return;
                                seen.add(areaId);
                                areas.push({ id: areaId, label: areaName, labelEn: areaName, desc: p.formattedAddress || '', descEn: p.formattedAddress || '', lat: p.location.latitude, lng: p.location.longitude, radius: 2000, size: 'medium', safety: 'safe' });
                              });
                            }
                            if (areas.length === 0) {
                              areas.push({ id: 'center', label: 'Center', labelEn: 'Center', desc: 'City center', descEn: 'City center', lat: addCityFound.lat, lng: addCityFound.lng, radius: 3000, size: 'large', safety: 'safe' });
                            }
                            const defaultInterests = [
                              { id: 'food', label: '◊ê◊ï◊õ◊ú', labelEn: 'Food', icon: 'üçú' },
                              { id: 'cafes', label: '◊ß◊§◊î', labelEn: 'Coffee', icon: '‚òï' },
                              { id: 'culture', label: '◊™◊®◊ë◊ï◊™', labelEn: 'Culture', icon: 'üé≠' },
                              { id: 'history', label: '◊î◊ô◊°◊ò◊ï◊®◊ô◊î', labelEn: 'History', icon: 'üèõÔ∏è' },
                              { id: 'parks', label: '◊§◊ê◊®◊ß◊ô◊ù', labelEn: 'Parks', icon: 'üå≥' },
                              { id: 'shopping', label: '◊ß◊†◊ô◊ï◊™', labelEn: 'Shopping', icon: 'üõçÔ∏è' },
                              { id: 'nightlife', label: '◊ú◊ô◊ú◊î', labelEn: 'Nightlife', icon: 'üåÉ' },
                              { id: 'galleries', label: '◊í◊ú◊®◊ô◊ï◊™', labelEn: 'Galleries', icon: 'üñºÔ∏è' },
                              { id: 'markets', label: '◊©◊ï◊ï◊ß◊ô◊ù', labelEn: 'Markets', icon: 'üè™' },
                              { id: 'graffiti', label: '◊í◊®◊§◊ô◊ò◊ô', labelEn: 'Street Art', icon: 'üé®' },
                              { id: 'beaches', label: '◊ó◊ï◊§◊ô◊ù', labelEn: 'Beaches', icon: 'üèñÔ∏è' },
                              { id: 'architecture', label: '◊ê◊®◊õ◊ô◊ò◊ß◊ò◊ï◊®◊î', labelEn: 'Architecture', icon: 'üèóÔ∏è' }
                            ];
                            const defaultPlaceTypes = {
                              food: ['restaurant', 'meal_takeaway'], cafes: ['cafe', 'coffee_shop'],
                              culture: ['performing_arts_theater', 'cultural_center', 'museum'], history: ['historical_landmark', 'museum'],
                              parks: ['park', 'national_park'], shopping: ['shopping_mall', 'store'],
                              nightlife: ['bar', 'night_club'], galleries: ['art_gallery', 'museum'],
                              markets: ['market'], graffiti: ['art_gallery'], beaches: ['beach'], architecture: ['historical_landmark']
                            };
                            let allCityRadius = 15000;
                            if (addCityFound.viewport) {
                              const vp = addCityFound.viewport;
                              if (vp.high && vp.low) {
                                const latDiff = Math.abs(vp.high.latitude - vp.low.latitude);
                                const lngDiff = Math.abs(vp.high.longitude - vp.low.longitude);
                                allCityRadius = Math.round(Math.max(latDiff, lngDiff) * 111000 / 2);
                              }
                            }
                            const newCity = {
                              id: addCityFound.id, name: addCityFound.name, nameEn: addCityFound.name,
                              country: addCityFound.address?.split(',').pop()?.trim() || '',
                              icon: 'üìç', secondaryIcon: 'üèôÔ∏è', active: false, distanceMultiplier: 1.2,
                              center: { lat: addCityFound.lat, lng: addCityFound.lng },
                              allCityRadius, areas, interests: defaultInterests,
                              interestToGooglePlaces: defaultPlaceTypes,
                              textSearchInterests: { graffiti: 'street art' },
                              uncoveredInterests: [], interestTooltips: {}
                            };
                            setAddCityGenerated(newCity);
                            setAddCitySearchStatus('done');
                          } catch (err) {
                            console.error('[ADD CITY] Generate error:', err);
                            setAddCitySearchStatus('error');
                            showToast(t('general.error'), 'error');
                          }
                        }}
                          className="mt-3 px-6 py-2 bg-emerald-500 text-white rounded-lg font-bold text-sm hover:bg-emerald-600"
                        >{`üèóÔ∏è ${t('settings.generateCity')}`}</button>
                      </div>
                    )}

                    {addCitySearchStatus === 'generating' && (
                      <div className="text-center py-4">
                        <div className="text-2xl animate-spin inline-block">üåç</div>
                        <p className="text-sm text-gray-500 mt-2">{t('settings.generatingCity')}</p>
                      </div>
                    )}

                    {addCitySearchStatus === 'done' && addCityGenerated && (
                      <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                        <p className="font-bold text-center mb-2">{addCityGenerated.icon} {addCityGenerated.nameEn}</p>
                        <div className="text-xs text-gray-600 space-y-1">
                          <p>üìç {addCityGenerated.areas.length} {t('general.areas')}: {addCityGenerated.areas.map(a => a.labelEn).join(', ')}</p>
                          <p>‚≠ê {addCityGenerated.interests.length} {t('nav.interests')}</p>
                          <p>üîç {t('settings.radius')}: {addCityGenerated.allCityRadius}m</p>
                        </div>
                        <p className="text-[10px] text-amber-600 mt-2 text-center">{t('settings.cityStartsInactive')}</p>
                        <button onClick={() => {
                          if (!addCityGenerated) return;
                          window.BKK.cities[addCityGenerated.id] = addCityGenerated;
                          window.BKK.cityData[addCityGenerated.id] = addCityGenerated;
                          window.BKK.cityRegistry[addCityGenerated.id] = {
                            id: addCityGenerated.id, name: addCityGenerated.name, nameEn: addCityGenerated.nameEn,
                            country: addCityGenerated.country, icon: addCityGenerated.icon, file: `city-${addCityGenerated.id}.js`
                          };
                          try {
                            const customCities = JSON.parse(localStorage.getItem('custom_cities') || '{}');
                            customCities[addCityGenerated.id] = addCityGenerated;
                            localStorage.setItem('custom_cities', JSON.stringify(customCities));
                          } catch(e) { console.error('Failed to save city:', e); }
                          window.BKK.exportCityFile(addCityGenerated);
                          showToast(`‚úì ${addCityGenerated.nameEn} ${t('settings.cityAdded')}`, 'success');
                          setShowAddCityDialog(false);
                          setAddCityInput(''); setAddCitySearchStatus(''); setAddCityFound(null); setAddCityGenerated(null);
                          switchCity(addCityGenerated.id);
                          setFormData(prev => ({...prev}));
                        }}
                          className="mt-3 w-full py-2 bg-blue-500 text-white rounded-lg font-bold text-sm hover:bg-blue-600"
                        >{`‚úì ${t('settings.addCityConfirm')}`}</button>
                      </div>
                    )}
                  </div>
            </div>
          </div>
        </div>
      )}

      {/* Version Long-Press Password Dialog (does NOT add to admin list) */}
      {showVersionPasswordDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl w-full max-w-sm shadow-2xl">
            <div className="bg-gradient-to-r from-gray-700 to-gray-800 text-white p-3 rounded-t-xl">
              <h3 className="text-base font-bold">{`üîí ${t("settings.lockedSettings")}`}</h3>
            </div>
            <div className="p-4 space-y-4">
              <p className="text-sm text-gray-600 text-center">{t("settings.enterPassword")}</p>
              <input
                type="password"
                value={passwordInput}
                onChange={(e) => setPasswordInput(e.target.value)}
                placeholder={t("settings.password")}
                className="w-full p-3 border rounded-lg text-center text-lg"
                autoFocus
                onKeyDown={async (e) => {
                  if (e.key === 'Enter') {
                    const hashedInput = await window.BKK.hashPassword(passwordInput);
                    if (hashedInput === adminPassword || passwordInput === adminPassword) {
                      setIsUnlocked(true);
                      setShowVersionPasswordDialog(false);
                      setPasswordInput('');
                      setCurrentView('settings');
                      showToast('üîì', 'success');
                    } else {
                      showToast(t('settings.wrongPassword'), 'error');
                      setPasswordInput('');
                    }
                  }
                }}
              />
              <div className="flex gap-2">
                <button
                  onClick={async () => {
                    const hashedInput = await window.BKK.hashPassword(passwordInput);
                    if (hashedInput === adminPassword || passwordInput === adminPassword) {
                      setIsUnlocked(true);
                      setShowVersionPasswordDialog(false);
                      setPasswordInput('');
                      setCurrentView('settings');
                      showToast('üîì', 'success');
                    } else {
                      showToast(t('settings.wrongPassword'), 'error');
                      setPasswordInput('');
                    }
                  }}
                  className="flex-1 py-2.5 rounded-lg font-bold text-sm bg-blue-500 text-white hover:bg-blue-600"
                >{t("general.ok")}</button>
                <button
                  onClick={() => { setShowVersionPasswordDialog(false); setPasswordInput(''); }}
                  className="flex-1 py-2.5 rounded-lg font-bold text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                >{t("general.cancel")}</button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Password Dialog */}
      {showPasswordDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl w-full max-w-sm shadow-2xl">
            <div className="bg-gradient-to-r from-gray-700 to-gray-800 text-white p-3 rounded-t-xl">
              <h3 className="text-base font-bold">{`üîí ${t("settings.lockedSettings")}`}</h3>
            </div>
            <div className="p-4 space-y-4">
              <p className="text-sm text-gray-600 text-center">{t("settings.enterPassword")}</p>
              <input
                type="password"
                value={passwordInput}
                onChange={(e) => setPasswordInput(e.target.value)}
                placeholder={t("settings.password")}
                className="w-full p-3 border rounded-lg text-center text-lg"
                autoFocus
                onKeyDown={async (e) => {
                  if (e.key === 'Enter') {
                    const hashedInput = await window.BKK.hashPassword(passwordInput);
                    // Support both hashed and legacy plaintext passwords
                    if (hashedInput === adminPassword || passwordInput === adminPassword) {
                      const userId = localStorage.getItem('bangkok_user_id');
                      const userName = localStorage.getItem('bangkok_user_name') || 'Unknown';
                      if (isFirebaseAvailable && database) {
                        // If password was plaintext, upgrade to hash
                        if (passwordInput === adminPassword && hashedInput !== adminPassword) {
                          database.ref('settings/adminPassword').set(hashedInput);
                          setAdminPassword(hashedInput);
                        }
                        database.ref(`settings/adminUsers/${userId}`).set({
                          addedAt: new Date().toISOString(),
                          name: userName
                        }).then(() => {
                          setIsUnlocked(true);
                          setIsCurrentUserAdmin(true);
                          localStorage.setItem('bangkok_is_admin', 'true');
                          setShowPasswordDialog(false);
                          setPasswordInput('');
                          setCurrentView('settings');
                          showToast(t('route.openedSuccess'), 'success');
                        });
                      }
                    } else {
                      showToast(t('settings.wrongPassword'), 'error');
                      setPasswordInput('');
                    }
                  }
                }}
              />
              <div className="flex gap-2">
                <button
                  onClick={async () => {
                    const hashedInput = await window.BKK.hashPassword(passwordInput);
                    // Support both hashed and legacy plaintext passwords
                    if (hashedInput === adminPassword || passwordInput === adminPassword) {
                      const userId = localStorage.getItem('bangkok_user_id');
                      const userName = localStorage.getItem('bangkok_user_name') || 'Unknown';
                      if (isFirebaseAvailable && database) {
                        // If password was plaintext, upgrade to hash
                        if (passwordInput === adminPassword && hashedInput !== adminPassword) {
                          database.ref('settings/adminPassword').set(hashedInput);
                          setAdminPassword(hashedInput);
                        }
                        database.ref(`settings/adminUsers/${userId}`).set({
                          addedAt: new Date().toISOString(),
                          name: userName
                        }).then(() => {
                          setIsUnlocked(true);
                          setIsCurrentUserAdmin(true);
                          localStorage.setItem('bangkok_is_admin', 'true');
                          setShowPasswordDialog(false);
                          setPasswordInput('');
                          setCurrentView('settings');
                          showToast(t('route.openedSuccess'), 'success');
                        });
                      }
                    } else {
                      showToast(t('settings.wrongPassword'), 'error');
                      setPasswordInput('');
                    }
                  }}
                  className="flex-1 py-2 bg-green-500 text-white rounded-lg font-medium"
                >
                  OK
                </button>
                <button
                  onClick={() => {
                    setShowPasswordDialog(false);
                    setPasswordInput('');
                  }}
                  className="flex-1 py-2 bg-gray-300 text-gray-700 rounded-lg font-medium"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

            {toastMessage && (
        <div
          onClick={() => setToastMessage(null)}
          style={{
            position: 'fixed',
            top: '10px',
            right: '10px',
            left: '10px',
            maxWidth: '350px',
            margin: '0 auto',
            padding: '6px 12px',
            borderRadius: '6px',
            backgroundColor: toastMessage.type === 'error' ? '#fecaca' : toastMessage.type === 'warning' ? '#fde68a' : toastMessage.type === 'info' ? '#dbeafe' : '#bbf7d0',
            border: `1px solid ${toastMessage.type === 'error' ? '#ef4444' : toastMessage.type === 'warning' ? '#f59e0b' : toastMessage.type === 'info' ? '#3b82f6' : '#22c55e'}`,
            boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
            zIndex: 9999,
            animation: 'slideDown 0.15s ease-out',
            cursor: toastMessage.sticky ? 'pointer' : 'default'
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', justifyContent: 'center' }}>
            <span style={{ fontSize: '12px' }}>
              {toastMessage.type === 'error' ? '‚úó' : toastMessage.type === 'warning' ? '!' : toastMessage.type === 'info' ? '‚Ñπ' : '‚úì'}
            </span>
            <div style={{ fontSize: '12px', fontWeight: '500', color: '#374151' }}>
              {toastMessage.message}
            </div>
            {toastMessage.sticky && (
              <span style={{ fontSize: '14px', fontWeight: 'bold', color: '#6b7280', marginLeft: '8px' }}>‚úï</span>
            )}
          </div>
        </div>
      )}





      </div>
    </div>
  );
};

// Wait for Firebase SDK, then init and render
window.__firebaseReady.then(function(sdkLoaded) {
  if (sdkLoaded) {
    initFirebase();
  } else {
    console.log('[FIREBASE] SDK not loaded - running without Firebase');
  }
  ReactDOM.createRoot(document.getElementById('root')).render(<CityExplorer />);
});
    </script>
</body>
</html>
